/* (big endian notation)
   
	seeeeeee_eeeemmmm_mmmmmmmm_mmmmmmmm  mmmmmmmm_mmmmmmmm_mmmmmmmm_mmmmmmmm = ieee double
	
	x1111111_1111xxxx_xxxxxxxx_xxxxxxxx  xxxxxxxx_xxxxxxxx_xxxxxxxx_xxxxxxxx = ieee NaN/Inf
	
	I assume same endianness for double and integer.
 */

#define PMATH_TAGMASK_BITCOUNT   12          /* |||||||| |||| */
#define PMATH_TAGMASK_NONDOUBLE  0x7FF00000U /* 01111111_11110000_00000000_00000000 0...0 : ieee double NaN or Inf */
#define PMATH_TAGMASK_OBJECT     0xFFF00000U /* 11111111_11110000_00000000_00000000 0...0 */
#define PMATH_TAG_NULL           (PMATH_TAGMASK_NONDOUBLE | 0x00000)
#define PMATH_TAG_MAGIC          (PMATH_TAGMASK_NONDOUBLE | 0x10000)
#define PMATH_TAG_INT32          (PMATH_TAGMASK_NONDOUBLE | 0x20000)

#define PMATH_PUBLIC_ASSERT  assert

struct pmath_object_t{
	uintptr_t  typeid;        
	intptr_t   refcount;
};

enum{
	PMATH_TYPEID_EXPR_GENERAL =   0,
	PMATH_TYPEID_EXPR_PART    =   1,
	PMATH_TYPEID_MAX_EXPR     =  99,
	
	PMATH_TYPEID_SYMBOL       = 100,
	
	PMATH_TYPEID_STRING       = 101,
	PMATH_TYPEID_BIGINT       = 102,
	PMATH_TYPEID_BIGFLOAT     = 103,
	PMATH_TYPEID_CUSTOM       = 104
};

typedef union {
	uint64_t  as_bits;
	double    as_double;
	
	#if PMATH_BITSIZE == 64
		struct pmath_object_t *as_pointer_64;
	#endif
	
	struct {
	    /* most significant word is the tag */
		#if PMATH_BYTE_ORDER < 0 /* little endian */
			union{
				int32_t   as_int32;
				#if PMATH_BITSIZE == 32
					struct pmath_object_t *as_pointer_32;
				#endif
			} u;
			uint32_t  tag;
		#else
			uint32_t  tag;
			union{
				int32_t   as_int32;
				#if PMATH_BITSIZE == 32
					struct pmath_object_t *as_pointer_32;
				#endif
			} u;
		#endif
	} s;
} pmath_t;

#define PMATH_EQ(a, b)  ((a).as_bits == (b).as_bits)

#define pmath_is_double(o)   (((o).s.tag & PMATH_TAGMASK_NONDOUBLE) != PMATH_TAGMASK_NONDOUBLE)
#define pmath_is_object(o)   (((o).s.tag & PMATH_TAGMASK_OBJECT)    == PMATH_TAGMASK_POINTER)
#define pmath_is_other(o)    (((o).s.tag & PMATH_TAGMASK_OBJECT)    == PMATH_TAGMASK_NONDOUBLE)
#define pmath_is_int32(o)    ((o).s.tag == PMATH_TAG_INT32)
#define pmath_is_null(o)     ((o).s.tag == PMATH_TAG_NULL)
#define pmath_is_magic(o)    ((o).s.tag == PMATH_TAG_MAGIC)

#define pmath_is_object_of(o, tid)  (pmath_is_object((o)) && PMATH_TO_OBJECT((o))->typeid == (tid))
#define pmath_is_expr(o)            (pmath_is_object((o)) && PMATH_TO_OBJECT((o))->typeid <= PMATH_TYPEID_MAX_EXPR)
#define pmath_is_symbol(o)          pmath_is_object_of((o), PMATH_TYPEID_SYMBOL)
#define pmath_is_string(o)          pmath_is_object_of((o), PMATH_TYPEID_STRING)
#define pmath_is_bigint(o)          pmath_is_object_of((o), PMATH_TYPEID_BIGINT)
#define pmath_is_bigfloat(o)        pmath_is_object_of((o), PMATH_TYPEID_BIGFLOAT)

#define PMATH_TO_DOUBLE(o)  ((o).as_double)
#define PMATH_TO_OTHER(o)   ((o).s.u.as_int32)

#if PMATH_BITSIZE == 32
	
	#define PMATH_TO_OBJECT(o)  ((o).s.u.as_pointer_32)
	
#elif PMATH_BITSIZE == 64
	
	#define PMATH_TO_OBJECT(o)  ((struct pmath_object_t*)(((o).as_bits << PMATH_TAGMASK_BITCOUNT) >> PMATH_TAGMASK_BITCOUNT))
	
#endif

PMATH_FORCE_INLINE
pmath_t pmath_from_good_double(double d){ /* d must not be NaN or Inf */
	pmath_t result;
	
	result.as_double = d;
	
	PMATH_PUBLIC_ASSERT(pmath_is_double(result));
	
	return result;
}

PMATH_FORCE_INLINE
pmath_t pmath_from_good_object(struct pmath_object_t *p){ /* p: valid heap pointer, esp. p != NULL */
/* 64bit system: p must have most significant 12 bits cleared */
	pmath_t result;
	
	PMATH_PUBLIC_ASSERT(p != NULL);
	
	#if PMATH_BITSIZE == 32
		
		result.s.tag             = PMATH_TAGMASK_POINTER;
		result.s.u.as_pointer_32 = p
		
	#elif PMATH_BITSIZE == 64
		
		result.as_bits = (((uint64_t)p) << PMATH_TAGMASK_BITCOUNT) >> PMATH_TAGMASK_BITCOUNT;
		
	#endif
	
	PMATH_PUBLIC_ASSERT(pmath_is_object(result));
	
	return result;
}

PMATH_FORCE_INLINE
pmath_t pmath_from_other(uint32_t tag, int32_t value){
	pmath_t result;
	
	result.s.tag        = tag;
	result.s.u.as_int32 = value;
	
	PMATH_PUBLIC_ASSERT(pmath_is_other(result));
	
	return result;
}

#define PMATH_NULL        (PMATH_FROM_OTHER(PMATH_TAG_NULL,  0))
#define PMATH_UNDEFINED   (PMATH_FROM_OTHER(PMATH_TAG_MAGIC, 0))
#define PMATH_ZERO        (PMATH_FROM_OTHER(PMATH_TAG_INT32, 0))

PMATH_FORCE_INLINE
intptr_t pmath_refcount(pmath_t o){
	if(pmath_is_object(o)){
		return PMATH_TO_OBJECT(o)->refcount;
	}
	else
		return 0;
}

PMATH_FORCE_INLINE
pmath_t pmath_ref(pmath_t o){
	if(pmath_is_object(o)){
		pmath_atomic_fetch_add(&PMATH_TO_OBJECT(o)->refcount, 1);
	}
	
	return 0;
}


PMATH_FORCE_INLINE
void pmath_unref(pmath_t o){
	if(pmath_is_object(o) && pmath_atomic_fetch_add(&PMATH_TO_OBJECT(o)->refcount, -1) == 1){
		_pmath_destroy_object(PMATH_TO_OBJECT(o));
	}
}
