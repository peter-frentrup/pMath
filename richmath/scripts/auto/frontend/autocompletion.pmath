Begin("FE`Private`")

FE`AutoCompleteName(~part:String)::= 
	With({fullnames:= Names(), np:= namespacePattern(part)},
		With({namespaces:= Union(fullnames.StringCases(~~~ns ++ "`" :> ns, 1).Apply(Join), allNamespacesFromPath())},
			With({byPrefix:= fullnames.selectByPrefix(np, part),
					byCamelCase:= fullnames.selectByCamelCase(np, part),
					nsByPrefix:= namespaces.selectByPrefix(StartOfString, part).Map(# ++ "`" &)
				},
				Join(
					byPrefix
						.makeShortNameList(part)
						.Sort()[All,2],
					nsByPrefix, 
					byCamelCase
						.Complement(byPrefix)
						.makeShortNameList(part)
						.Sort()[All,2])
				)
			)
		)

FE`AutoCompleteFile(~part:String)::=
	With({split:= part.StringCases(~~~dir ++ ("/"|$PathnameSeparator) ++ (file:Except("/"|$PathnameSeparator)***) :> {dir,file})},
		If(split.Length =!= 1,
			Return({}));
		
		Return(FileNames(split[1,1], split[1,2] ++ "*"));
	)

namespacePattern(~part:String)::= 
	If(part.containsSubstring("`"), 
		StartOfString
	,/*else*/ 
		StartOfString ++ Prepend($NamespacePath, $Namespace))

selectByPrefix(~list, ~np, ~part)::= (
		list.StringCases(
				np ++ part ++ Except("`")*** ++ EndOfString, 
				1, IgnoreCase -> True)
			.Apply(Join)
	)

selectByCamelCase(~list, ~np, ~part)::= (
		list.StringCases(
				np ++ makeCamelCasePattern(part) ++ Except("`")*** ++ EndOfString,
				1)
			.Apply(Join)
	)

allNamespacesFromPath()::= Union(
	$Path
		.FileNames(WordCharacter*** ++ ".pmath")
		.StringCases(
			$PathnameSeparator ++ (s: "A".."Z" ++ Except($PathnameSeparator)**) ++ ".pmath" :> s,
			1)
		.Apply(Join),
	$Path
		.FileNames(WordCharacter***)
		.FileNames("init.pmath")
		.StringCases(
			$PathnameSeparator ++ (s:"A".."Z" ++ Except($PathnameSeparator)**) ++ $PathnameSeparator ++ "init.pmath" :> s,
			1)
		.Apply(Join)
	)
	
stringLength(~str:String)::= str.StringPosition(EndOfString)[1,1]

makeCamelCasePattern(~str:String)::= 
	With({anyNonUpper:= "a".."z" /*If(str.containsSubstring("`"), Except("A".."Z"|"`"), Except("A".."Z"))*/},
		(RegularExpression("(?i)" ++ escapeRegex(str))
		| str.StringReplace({
			s: "A".."Z" ++ ("a".."z")*** ++ EndOfString :> s,
			s: "A".."Z" ++ ("a".."z")*** :> s ++ anyNonUpper***,
			WordBoundary ++ (char: "a".."z") ++ (s: ("a".."z")*** ++ RegularExpression("(?=[^a-z])")) :> ((WordBoundary ++ char) | upperCaseChar(char)) ++ s ++ anyNonUpper***,
			char: "a".."z" ++ EndOfString :> upperCaseChar(char),
			char: "a".."z" :> upperCaseChar(char) ++ anyNonUpper***}))
		)

escapeRegex(~str:String)::= str.StringReplace(c: Characters("\[RawBackslash]^$.[|()?*+{") :> "\[RawBackslash]" ++ c)

upperCaseChar("a"):= "A"
upperCaseChar("b"):= "B"
upperCaseChar("c"):= "C"
upperCaseChar("d"):= "D"
upperCaseChar("e"):= "E"
upperCaseChar("f"):= "F"
upperCaseChar("g"):= "G"
upperCaseChar("h"):= "H"
upperCaseChar("i"):= "I"
upperCaseChar("j"):= "J"
upperCaseChar("k"):= "K"
upperCaseChar("l"):= "L"
upperCaseChar("m"):= "M"
upperCaseChar("n"):= "N"
upperCaseChar("o"):= "O"
upperCaseChar("p"):= "P"
upperCaseChar("q"):= "Q"
upperCaseChar("r"):= "R"
upperCaseChar("s"):= "S"
upperCaseChar("t"):= "T"
upperCaseChar("u"):= "U"
upperCaseChar("v"):= "V"
upperCaseChar("w"):= "W"
upperCaseChar("x"):= "X"
upperCaseChar("y"):= "Y"
upperCaseChar("z"):= "Z"
upperCaseChar(~c)::= c

containsSubstring(~str:String, ~sub:String)::= str.StringPosition(sub, 1).Length > 0

makeShortNameList(~list:List, ~part:String)::=
	If(StringPosition(part, "`", 1).Length > 0,
		list.Map({#,#}&)
	, /* else */
		list.Map(makeShortName)
	)
makeShortName(~fullname:String)::= 
	fullname.StringReplace({
			long: ~~~ ++ "`" ++ (short: Except("`")**) :> 
				{short, 
					If(Names(short).Length===1, 
						short
					,
						long
					)},
			~~long :> {long, long}
		},
		IgnoreCase -> True)

End()
