Begin("FE`Private`")

FE`AutoCompleteName(~part:String)::= 
	Join(
		Names(part, IgnoreCase -> True).makeShortNameList(part).Sort()[All,2],
		Union(
			If(stringLength(part) > 1,
				Names(makeCamelCasePattern(part))
			, /* else */
				{}),
			If(StringPosition(part, "`", 1).Length > 0,
				Names(part ++ Except("`")**, IgnoreCase -> True)
			, /* else */
				Names(part ++ ~~, IgnoreCase -> True))
		).makeShortNameList(part).Sort()[All,2],
		Names(StartOfString ++ part ++ (~ | "`")***, IgnoreCase -> True).Map(Namespace @@ MakeExpression(#) &).Union
		)

FE`AutoCompleteFile(~part:String)::=
	With({split:= part.StringCases(~~~dir ++ ("/"|$PathnameSeparator) ++ (file:Except("/"|$PathnameSeparator)***) :> {dir,file})},
		If(split.Length =!= 1,
			Return({}));
		
		Return(FileNames(split[1,1], split[1,2] ++ "*"));
	)

stringLength(~str:String)::= str.StringPosition(EndOfString)[1,1]

makeCamelCasePattern(~str:String)::= 
	( str.StringReplace(
			{
				s: ~~~ ++ "`" :> s,
				s: "A".."Z" ++ Except("A".."Z")*** :> s ++ Except("A".."Z")***,
				(StartOfString | RegularExpression("(?<=[^A-Z])")) ++ (char: "a".."z") :> (char|upperCaseChar(char)) ++ Except("A".."Z")***,
				char: "a".."z" :> upperCaseChar(char) ++ Except("A".."Z")***})
	++ ~~~)

upperCaseChar("a"):= "A"
upperCaseChar("b"):= "B"
upperCaseChar("c"):= "C"
upperCaseChar("d"):= "D"
upperCaseChar("e"):= "E"
upperCaseChar("f"):= "F"
upperCaseChar("g"):= "G"
upperCaseChar("h"):= "H"
upperCaseChar("i"):= "I"
upperCaseChar("j"):= "J"
upperCaseChar("k"):= "K"
upperCaseChar("l"):= "L"
upperCaseChar("m"):= "M"
upperCaseChar("n"):= "N"
upperCaseChar("o"):= "O"
upperCaseChar("p"):= "P"
upperCaseChar("q"):= "Q"
upperCaseChar("r"):= "R"
upperCaseChar("s"):= "S"
upperCaseChar("t"):= "T"
upperCaseChar("u"):= "U"
upperCaseChar("v"):= "V"
upperCaseChar("w"):= "W"
upperCaseChar("x"):= "X"
upperCaseChar("y"):= "Y"
upperCaseChar("z"):= "Z"
upperCaseChar(~c)::= c

makeShortNameList(~list:List, ~part:String)::=
	If(StringPosition(part, "`", 1).Length > 0,
		list.Map({#,#}&)
	, /* else */
		list.Map(makeShortName)
	)
makeShortName(~fullname:String)::= 
	fullname.StringReplace({
			long: ~~~ ++ "`" ++ (short: Except("`")**) :> 
				{short, 
					If(Names(short).Length===1, 
						short
					,
						long
					)},
			~~long :> {long, long}
		},
		IgnoreCase -> True)

End()
