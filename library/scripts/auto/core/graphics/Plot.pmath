
BeginPackage("System`Graphics`Plot`", {"Developer`"})

System`Plot


Begin("System`Graphics`Plot`Private`")


$PlotFailed	

Attributes(Plot):= {HoldAll}
p: Plot(~~~args)::= With({g:= Catch(tryPlot(p, args), $PlotFailed)}, g /? Head(g) === Graphics)

Plot::plld:= "Endpoints for `1` in `2` must have distinct machine-precision numerical values."
Plot::plld1:= "Endpoints in `1` must have distinct machine-precision numerical values."
Plot::pllim:= "Range specification `1` is not of the form x -> xmin..xmax  or  xmin..xmax."

Protect(Plot)

Attributes(isNotHeldOption):= {HoldAll}
isNotHeldOption(~x)::= !IsOption(Unevaluated(x))

Function makeNiceRange({~mi, ~ma}) {
	If(mi - (ma - mi)/5 < 0 < mi) {
		Return(0 .. ma)
	} Else If(ma < 0 < ma + (ma - mi)/5) {
		Return(mi .. 0)
	} Else If(mi < ma) {
		Return(mi .. ma)
	} Else If(IsNumber(mi) && IsReal(mi)) {
		Return(mi - 1 .. mi + 1)
	}
	Return(-1 .. 1)
}

getPlotRangeYs(~xys, ~xrange)::= makeNiceRange(getRangeList(xys[All, 2]))

Function getRangeList(~ys) {
	With(nys:= ys.Select(IsReal))
	
	If(nys === {}) {
		Return({-1, 1})
	} Else If(Length(nys) = 1) {
		Return(First(nys) + {-1, 1})
	}

	With(dys:= Abs(nys.ListConvolve({1, -1})))
	With(cut:= Quantile(dys, 0.7, {{0,0},{0,1}})) % Going down to 0.6 would give degenerate results in Plot(Sqrt(Sin(x)),x->-5..5)
	With(is:= Flatten @ Position(dys, ~d /? d < cut, 1..1))
	
	With(mima:= MinMax(If(is === {}, nys, {nys[is], nys[is + 1]})))

	If(First(mima) = Last(mima)) {
		Return(First(mima) + {-1, 1})
	}
	Return(mima)
}

getRange(~ys)::= getRangeList(ys) |> {{~min, ~max} :> min .. max}

Function initDataXsYs(~f, ~xmin .. ~xmax, ~numPoints, ~prec) {
	With(xs:= Array(Numericalize(SetPrecision(xmin .. xmax .. (xmax - xmin)/(numPoints - 1), prec), prec)))
	Return({xs, xs.Map(f)}.Developer`ToPackedArray)
}

Function calcCosinesXsYs(~xs, ~ys, ~xmin .. ~xmax, ~ymin .. ~ymax) {
	With(ndxs:= xs.ListConvolve({1, -1}) / (xmax - xmin))  % Differences
	With(ndys:= ys.ListConvolve({1, -1}) / (ymax - ymin))  % Differences
	With(tans:= ndys / ndxs)
	With(tas:= Most(tans), tbs:= Rest(tans))
	Return((1 + tas tbs) / Sqrt((1 + tas^2)*(1 + tbs^2)) |> Replace(Undefined -> 0, 1..1))
}

Function cosMinFunction(~stepNumber, ~numPoints) {
	Max(
		With({n:= numPoints}, Cos(180.0 Degree * Piecewise({{1, n < 2000}, {1 - ((n - 2000) / (4000 - 2000))^3, n < 4000}}, 0))),
		With({n:= stepNumber}, Cos(180.0 Degree * Piecewise({{1, n < 10}, {1 - ((n - 10) / (20 - 10))^2, n < 20}}, 0))))
}

Function refineDataXsYs(~f, ~xrange, {~xs, ~ys}, ~prec, ~stepNumber) {
	With(cosines:= calcCosinesXsYs(xs, ys, xrange, getRange(ys)))
	With(cosMax:= Cos(5.0 Degree))
	With(cosMin:= cosMinFunction(stepNumber, Length(xs)))
	
	Local(is, newxs)
	is:= Flatten @ Position(cosines, ~ ? (cosMin <= # <= cosMax &), 1..1, Heads -> False);
	
	If(Length(is) = 0) {
		Return({})
	}
	
	% Print(StringForm("step `1`: cos: `2`..`3`, actual: `4`..`5`, marks: `6` of `7` (`8`%)", 
	% 	stepNumber, 
	% 	cosMin, 
	% 	cosMax, 
	% 	Min(cosines),
	% 	Max(cosines),
	% 	Length(is), 
	% 	Length(cosines), 
	% 	100.0 Length(is) / Length(cosines)));
	is:= Union(is, is + 1);
	
	newxs:= Numericalize(SetPrecision(xs[is] / 2 + xs[is + 1] / 2, prec), prec) %.Developer`ToPackedArray;
	
	Return({newxs, newxs.Map(f)})
}

Function generateData(~f, ~xrange, ~numPoints, ~prec, ~maxrecurs) {
	Local(xs, ys, newxsys, is, step)
	{xs, ys}:= initDataXsYs(f, xrange, numPoints, prec)
	step:= 0
	While(step < maxrecurs) {
		step+= 1;
		newxsys:= refineDataXsYs(f, xrange, {xs, ys}, prec, step);
		If(newxsys === {}) {
			Break()
		}

		% TODO: improve SortBy so that it does not unpack below:
		%xys:= SortBy(Join(xys, newxys), First).Developer`ToPackedArray;

		xs:= Join(xs, newxsys[1])
		ys:= Join(ys, newxsys[2])
		is:= Ordering(xs)
		xs:= xs[is]
		ys:= ys[is]
	}
	Return(Developer`ToPackedArray(Thread({xs, ys})))
}

joinLists():= {}
joinLists(~~~args)::= Join(args)

automaticPlotRangePadding(Automatic)::= {None, Scaled(0.04)}
automaticPlotRangePadding(All)::= {None, Scaled(0.04)}
automaticPlotRangePadding({~xr, Automatic})::= {None, Scaled(0.04)}
automaticPlotRangePadding({~xr, All})::= {None, Scaled(0.04)}
%automaticPlotRangePadding(~pr: Range)::= None
automaticPlotRangePadding(~)::= None

normalizePlotRange(~xyDatas, ~xrange, ~r: Range)::= {xrange, r}
normalizePlotRange(~xyDatas, ~xrange, Automatic)::= {xrange, getPlotRangeYs(joinLists @@ xyDatas, xrange)}
normalizePlotRange(~xyDatas, ~xrange, {~xr, Automatic})::= {xr, getPlotRangeYs(joinLists @@ xyDatas, xrange)}
normalizePlotRange(~xyDatas, ~xrange, ~r)::= r /* TODO: handle errors */

Function tryPlotFunction(~fs, ~xrange, opts: OptionsPattern(Plot)) {
	Local(allRules, plotPoints, workingPrecision, maxRecursion, plotRange, xyDatas, gRules)
	
	allRules:= Flatten({opts})
	allRules:= allRules |> Join(Options(Plot) |> FilterRules(Except(allRules)))
	
	plotPoints:= PlotPoints.Replace(allRules)
	If(plotPoints === Automatic) {
		plotPoints:= 15
	} Else If(!IsInteger(plotPoints) || plotPoints < 2) {
		% error message ...
		plotPoints:= 15
	}
	
	maxRecursion:= MaxRecursion.Replace(allRules)
	If(maxRecursion === Automatic) {
		maxRecursion:= Infinity
	}
	
	workingPrecision:= WorkingPrecision.Replace(allRules)
	If(Try(SetPrecision(1, workingPrecision), $Failed, SetPrecision::invprec) === $Failed) {
		Message(Plot::invprec, workingPrecision)
		Return($PlotFailed)
	}
	
	xyDatas:= fs.Map(Function(generateData(#, xrange, plotPoints, workingPrecision, maxRecursion)))
	
	plotRange:= Lookup(allRules, PlotRange)
	If(Lookup(allRules, PlotRangePadding) === Automatic) {
		allRules:= allRules |> 
			FilterRules(Except(PlotRangePadding)) |> 
			Join({PlotRangePadding -> automaticPlotRangePadding(plotRange)})
	}
	plotRange:= normalizePlotRange(xyDatas, xrange, plotRange)
	allRules:= allRules |> FilterRules(Except(PlotRange)) |> Join({PlotRange -> plotRange})
	gRules:= allRules |> FilterRules(Options(ListLinePlot)) |> Complement(Options(ListLinePlot))
	
	Return(ListLinePlot(xyDatas, gRules))
}


Attributes(makeHoldForm):= {HoldAll}
makeHoldForm(~x)::= 
	With({debugMetadata:= GetDebugMetadata(x)},
		HoldForm(x).SetDebugMetadataAt(debugMetadata))

Attributes(checkRange):= {HoldAll}
checkRange(spec: (~x:Symbol -> ~range))::= checkRangeRest(makeHoldForm(x), range, makeHoldForm(spec))
checkRange(~range)::= checkRangeRest(None, range, makeHoldForm(range))
Function checkRangeRest(~holdformx, ~xmin..~xmax, ~) {
	With(evalxmin:= xmin, evalxmax:= xmax)
	If((evalxmin < evalxmax) =!= True) {
		If(holdformx === None) {
			Message(Plot::plld1, HoldForm(spec));
		} Else {
			Message(Plot::plld, holdformx, HoldForm(spec));
		}
		Throw($PlotFailed);
	}
	Return(evalxmin .. evalxmax);
}
checkRangeRest(~, ~, ~heldspec)::= (Message(Plot::pllim, heldspec); Throw($PlotFailed))


/* Attributes(makeFunction):= {HoldAll}
makeFunction(~fx, ~x:Symbol -> ~)::= With({x:= x}, Function(x, fx))
makeFunction(~, ~)::= (Undefined &) */

makeReal(~y) ::= If(IsNumber(y) && IsReal(y), y, Undefined, Undefined)

Attributes(makeFunctionList):= {HoldAll}
makeFunctionList(~fx, ~xspec)::= makeFunctionList({fx}, xspec)
makeFunctionList({~~~fxs}, ~xspec)::= List @@ Hold(fxs).Map(
	Function(f, With({f:= f}, Function(makeReal(f(#)) ))))
makeFunctionList({~~~fxs}, ~x:Symbol -> ~)::= 
	List @@ Hold(fxs).Map(
		Function(, 
			With({x::= x}, Function(x, makeReal(#))), 
			{HoldAllComplete}))


Attributes(tryPlot):= {HoldAll}
tryPlot(~orig, ~fx, ~xspec, opts: OptionsPattern(Plot))::= 
	tryPlotFunction(
		makeFunctionList(fx, xspec), 
		checkRange(xspec), 
		opts)
	
tryPlot(~)::=  (IsValidArgumentCount(Plot, 0, 2, 2); $Failed)
tryPlot(~, ~)::= (IsValidArgumentCount(Plot, 1, 2, 2); $Failed)
tryPlot(~orig, PatternSequence(~, ~, ~~~, ~err ? isNotHeldOption, ~~~))::=
	(Message(Plot::nonopt, makeHoldForm(err), 2, makeHoldForm(orig)); $Failed)
	
End()

EndPackage()
