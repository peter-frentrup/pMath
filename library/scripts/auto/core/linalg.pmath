Begin("System`linalg`")

Cross(~~vectors)::= With({dim:= Dimensions({vectors})},
	(-1)^dim[1] Array(
		Function({k}, Det({UnitVector(dim[2], k), vectors})),
		dim[2]) 
	/? dim.Length === 2 && dim[1] + 1 === dim[2])


MakeBoxes(Transpose(~x))::= {ParenthesizeBoxes(MakeBoxes(x), Power, "Postfix"), SuperscriptBox("\[DownTee]")}
Transpose(~tensor:List, ?perm:{2,1})::= With({result:= Catch(transposeHelper(tensor, perm), $Failed)}, result /? result =!= $Failed)

transposeHelper(~tensor, ~perm:List)::= Local({tdim, rdim, invperm, indices, result, is, tis, i},
	Do(
		If(!IsInteger(i) || i <= 0, 
			Message(Transpose::perm1, i, perm); 
			Throw($Failed));
		If(i > Length(perm),
			Message(Transpose::perm2, i, perm); 
			Throw($Failed)), 
		i -> perm);
		
	invperm:=Table(
		Select(Array(Length(perm)), perm[#] = ri &),
		ri -> 1..Max(perm));
	tdim:= Dimensions(tensor);
	rdim:= Table(
		If(Length(invperm[i]) < 1, 
			Message(Transpose::newdims, perm, i); 
			Throw($Failed));
		If(Length(Union(tdim[invperm[i]])) != 1, 
			Message(Transpose::diagnl, perm);
			Throw($Failed));
		tdim[First(invperm[i])],
		i -> 1..Length(invperm));
	result:= Array(List, rdim);
	indices:= Flatten(result, Length(rdim)-1);
	tis:= ConstantArray(0, Length(tdim));
	Do(
		Do(
			tis[invperm[i]]:= is[i],
			i -> 1..Length(is));
		result[Sequence @@ is]:= tensor[Sequence @@ tis],
		is -> indices);
	Return(result))



/* QR decomposition via givvens rotation */

givRot(~i,~k,~m,~c,~s)::= Local({A:= IdentityMatrix(m)},
	A[i,i]:= A[k,k]:= c;
	A[i,k]:= s;
	A[k,i]:= -s;
	A)

QRDecomposition(~A?IsMatrix)::= Local({Q, R, G, r, i, j, m:= Length(A)},
	R:= A;
	Q:= IdentityMatrix(m);
	Do(
		Do(
			If((R[i,j] = 0) =!= True,
				r:= Sqrt(R[j,j]^2 + R[i,j]^2);
				G:= givRot(j, i, m, R[j,j]/r, R[i,j]/r);
				R:= Dot(G, R);
				Q:= Dot(G, Q);
				)
			, i -> j+1 .. m)
		, j -> Length(A[1]));
		{Transpose(Q), R}) /* not ConjugateTranspose!!! */
	
/* QR decomposition via Householder transformation 
QRDecomposition(~A?IsMatrix)::=With({dims:= Dimensions(A)},
	Local({H, Q, R, u, k},
		Q:= IdentityMatrix(dims[1]);
		R:= A;
		Do(
			u:= R[k..,k];
			u[1]+= Sign(u[1]) Norm(u);
			u/= Norm(u);
			u:= Join(ConstantArray(0,k-1), u);
			H:= IdentityMatrix(dims[1]) - 2 Dot(Transpose({u}), {Conjugate(u)});
			Q:= Dot(H, Q);
			R:= Dot(H, R);
			, k -> Min(dims));
		{Conjugate(Transpose(Q)), R * Array(Boole(#1 <= #2) &, dims)})) */

End()
