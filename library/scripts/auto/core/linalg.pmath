Begin("System`linalg`")

Cross(~~vectors)::= With({dim:= Dimensions({vectors})},
	(-1)^dim[1] Array(
		Function({k}, Det({UnitVector(dim[2], k), vectors})),
		dim[2]) 
	/? dim.Length === 2 && dim[1] + 1 === dim[2])


MakeBoxes(Transpose(~x))::= {ParenthesizeBoxes(MakeBoxes(x), Power, "Postfix"), SuperscriptBox("\[DownTee]")}
Transpose(~tensor:List, ?perm:{2,1})::= With({result:= Catch(transposeHelper(tensor, perm), $Failed)}, result /? result =!= $Failed)

transposeHelper(~tensor, perm: Except(~:List))::= (Message(Transpose::list, HoldForm(Transpose(tensor, perm)), 2); $Failed)
transposeHelper(~tensor, ~perm:List)::= Local({tdim, rdim, invperm, indices, result, is, tis, i},
	Do(
		If(!IsInteger(i) || i <= 0, 
			Message(Transpose::perm1, i, perm); 
			Throw($Failed));
		If(i > Length(perm),
			Message(Transpose::perm2, i, perm); 
			Throw($Failed)), 
		i -> perm);
		
	invperm:=Table(
		Select(Array(Length(perm)), perm[#] = ri &),
		ri -> 1..Max(perm));
	tdim:= Dimensions(tensor);
	rdim:= Table(
		If(Length(invperm[i]) < 1, 
			Message(Transpose::newdims, perm, i); 
			Throw($Failed));
		If(Length(Union(tdim[invperm[i]])) != 1, 
			Message(Transpose::diagnl, perm);
			Throw($Failed));
		tdim[First(invperm[i])],
		i -> 1..Length(invperm));
	result:= Array(List, rdim);
	indices:= Flatten(result, Length(rdim)-1);
	tis:= ConstantArray(0, Length(tdim));
	Do(
		Do(
			tis[invperm[i]]:= is[i],
			i -> 1..Length(is));
		result[Sequence @@ is]:= tensor[Sequence @@ tis],
		is -> indices);
	Return(result))



/* QR decomposition with Givens rotation */

givensRot(~i,~k,~m,~c,~s)::= Local({A:= IdentityMatrix(m)},
	A[i,i]:= c;
	A[i,k]:= Conjugate(s);
	A[k,i]:= -s;
	A[k,k]:= Conjugate(c);
	A)

QRDecomposition(~A?IsMatrix)::= Local({Q, R, G, r, i, j, m:= Length(A)},
	R:= A;
	Q:= IdentityMatrix(m);
	Do(
		Do(
			If((R[i,j] = 0) =!= True,
				r:= Norm({R[j,j], R[i,j]});
				G:= givensRot(j, i, m, R[j,j]/r, R[i,j]/r);
				R:= Dot(G, R);
				Q:= Dot(G, Q);
				)
			, i -> j+1 .. m)
		, j -> Length(A[1]));
	{Conjugate(Transpose(Q)), R})




/* SVD - does not yet work */
SIGN(~a, ~b)::= If((b < 0) === True, -Abs(a), Abs(a))

svdcmp(~M?IsMatrix)::= 
	Local({A:= M, m:= Length(M), n:= Length(M[1]), W, V, rv1, i, j, l, nm, its, maxits:= 30, flag, c, f, g, h, s, scale, anorm, x, y, z, 
			ONE:= SetPrecision(1, Precision(M)),
			ZERO:= ONE - ONE
		},
		W:= ConstantArray(Undefined, n);
		V:= ConstantArray(Undefined, {n, n});
		
		Print("Householder reduction to bidiagonal form...");
		
		/* Householder reduction to bidiagonal form.  */
		rv1:= ConstantArray(Undefined, n);
		g:= scale:= anorm:= ZERO;
		Do(
			l:= i+1;
			rv1[i]:= scale * g;
			g:= s:= scale:= ZERO;
			If(i <= m,
				scale:= Total(Abs(A[i..m, i]));
				If((scale = ZERO) =!= True,
					A[i..m, i] /= scale;
					s:= Total(A[i..m, i]^2);
					f:= A[i, i];
					g:= -SIGN(Sqrt(s), f);
					h:= f * g - s;
					A[i, i]:= f - g;
					Do(
						s:= Total(A[i..m,i] * A[i..m,j]);
						f:= s/h;
						A[i..m, j]+= f * A[i..m, i];
						, j->l .. n);
					A[i..m, i] *= scale;
					);
				);
			W[i]:= scale * g;
			g:= s:= scale:= ZERO;
			If(i <= m && i != n,
				scale:= Total(Abs(A[i, l..n]));
				If((scale = ZERO) =!= True,
					A[i, l..n] /= scale;
					s:= Total(A[i, l..n]^2);
					f:= A[i, l];
					g:= -SIGN(Sqrt(s), f);
					h:= f * g - s;
					A[i, l]:= f - g;
					rv1[l..n]:= A[i, l..n] / h;
					Do(
						s:= Total(A[j, l..n] * A[i, l..n]);
						A[j, l..n] += s * rv1[l..n];
						, j-> l..m);
					A[i, l..n] *= scale;
					);
				);
			anorm:= Max(anorm, Abs(W[i]) + Abs(rv1[i]));
			, i -> 1..n);
		
		Print("Accumulation of right-hand transformations....");
		
		/* Accumulation of right-hand transformations. */
		Do(
			l:= i+1;
			If(i < n,
				g:= rv1[l];
				If((g = ZERO) =!= True,
					V[l..n, i]:= A[i, l..n] / A[i, l] / g;
					Do(
						s:= Total(A[i, l..n] * V[l..n, j]);
						V[l..n, j]+= s * V[l..n, i];
						, j -> l..n);
					);
				V[i, l..n]:= V[l..n, i]:= ConstantArray(ZERO, n - l + 1);
				);
			V[i,i]:= 1;
			, i->n..1..-1);
		
		Print("Accumulation of left-hand transformations....");
		
		/* Accumulation of left-hand transformations. */
		Do(
			l:= i+1;
			g:= W[i];
			A[i, l..n]:= ConstantArray(ZERO, n - l + 1);
			If((g = 0) =!= True,
				g:= 1 / g;
				Do(
					s:= Total(A[l..m, i] * A[l..m, j]);
					f:= s / A[i,i] * g;
					A[i..m, j] += f * A[i..m, i];
					, j->l..n);
				A[i..m, i] *= g;
			, /* else */
				A[i..m, i]:= ConstantArray(ZERO, m - i + 1);
				);
			A[i,i]+= 1;
			, i -> Min(m, n)..1..-1);
			
		Print("Diagonalization of the bidiagonal form...");
		
		/* Diagonalization of the bidiagonal form: Loop over singular values, and over allowed iterations. */
		Do(
			Print("k = ", k);
			Do(
				Print("its = ", its);
			
				/* Test for splitting */
				flag:= True;
				nm:= Undefined;
				For(l:= k, l >= 1, --l,
					nm:= l-1; /* Note that rv1[1] is always zero. */
					If(Abs(rv1[l]) + anorm = anorm,
						flag:= False;
						Break();
						);
					If(Abs(W[nm]) + anorm = anorm,
						Break());
					);
				
				If(flag,
					c:= ZERO; /* Cancellation of rv1[l] , if l > 1 */
					s:= ONE;
					Do(
						f:= s * rv1[i];
						rv1[i] *= c;
						If(Abs(f) + anorm = anorm, 
							Break());
						g:= W[i];
						h:= Norm({f, g});
						W[i]:= h;
						h:= 1 / h;
						c:= g * h;
						s:= -f * h;
						{A[1..m, nm], A[1..m, i]}:= {A[1..m, nm] c + A[1..m, i] s, A[1..m, i] c - A[1..m, nm] s};
						, i -> l..k);
					);
					
				z:= W[k];
				If(l = k, /* Convergence */
					If(z < 0, /* Singular value is made nonnegative. */
						W[k]:= -z;
						V[1..n, k]:= -V[1..n, k]
						);
					Break();
					);
					
				If(its = maxits,
					Print(StringForm("no convergence after `1` svdcmp iterations", maxits));
					Return($Failed);
					);
					
				x:= W[l];
				nm:= k-1;
				y:= W[nm];
				g:= rv1[nm];
				h:= rv1[k];
				f:= ((y-z) * (y+z) + (g-h) * (g+h)) / (2 h y); 
				g:= Norm({f, ONE});
				f:=((x-z) * (x+z) + h* (y / (f + SIGN(g, f)) - h)) / x; 
				c:= s:= 1.0; 
				/* Next QR transformation: */
				Do(
					i:= j+1;
					g:= rv1[i];
					y:= W[i];
					h:= s g;
					g:= c g;
					z:= Norm({f, h});
					rv1[j]:= z;
					c:= f / z;
					s:= h / z;
					f:= x c + g s;
					g:= g c - x s;
					h:= y s;
					{V[1..n, j], V[1..n, i] } := {V[1..n, j] c + V[1..n, i] s, V[1..n, i] c - V[1..n, j] s};
					z:= Norm({f, h});
					
					W[j]:= z;
					If((z = 0) =!= True, /* Rotation can be arbitrary if z = 0. */
						z:= 1 / z;
						c:= f z;
						s:= h z;
						);
					f:= c g + s y;
					x:= c y - s g;
					{A[1..m, j], A[1..m, i]}:= {A[1..m, j] c + A[1..m, i] s, A[1..m, i] c - A[1..m, j] s};
					
					, j -> l .. nm);
				
				rv1[l]:= ZERO;
				rv1[k]:= f;
				W[k]:= x;
				
				, its -> 1 .. maxits);
			, k -> n..1..-1);
			
		Return({A, W, V})
	)


End()
