$Aborted::usage:= "$Aborted is a special symbol that is returned when an evaluation is aborted."
$ApplicationFileName::usage:= "$ApplicationFileName gives the file name of the \(StyleBox(\"pMath\", \"TI\")\) executable."
$BaseDirectory::usage:= "$BaseDirectory gives the scripts directory of you installation."
$ByteOrdering::usage:= "$ByteOrdering gives the native ordering of bytes in binary data on your computer."
$Canceled::usage:= "$Canceled is a symbol returned when user input is canceled, for example from a dialog box."
$CharacterEncoding::usage:= "$CharacterEncoding is the default character encoding for opening text files."
$CommandLine::usage:= "$CommandLine is a list of the command line arguments that \(StyleBox(\"pMath\", \"TI\")\) was started with."
$CreationDate::usage:= "$CreationDate is a list of the form {\(StyleBox(\"year\", \"Arg\")\), \(StyleBox(\"month\", \"Arg\")\), \(StyleBox(\"day\", \"Arg\")\), \(StyleBox(\"hour\", \"Arg\")\), \(StyleBox(\"minute\", \"Arg\")\), \(StyleBox(\"second\", \"Arg\")\)} which gives the compilation date and time of the \(StyleBox(\"pMath\", \"TI\")\) library."
$DialogLevel::usage:= "$DialogLevel gives the current subsession level."
$DirectoryStack::usage:= "$DirectoryStack is the list of current directories used."
$Failed::usage:= "$Failed is a special symbol that is returned when a particular operation did not succeed."
$History::usage:= "$History(-\(\"n\".StyleBox(\"Arg\")\)) gives the \(\"n\".StyleBox(\"Arg\")\)-th last evaluation result.\n$History(\(\"n\".StyleBox(\"Arg\")\)) gives the \(\"n\".StyleBox(\"Arg\")\)-th evaluation result."
$HistoryLength::usage:= "$HistoryLength defines the number of results to be remembered by $History."
$InitialDirectory::usage:= "$InitialDirectory gives the initial directory when \(StyleBox(\"pMath\", \"TI\")\) was started."
$Input::usage:= "$Input gives the current input file name."
$Line::usage:= "$Line is the number of the current evaluation."
$MachineEpsilon::usage:= "$MachineEpsilon is the smallest positive-machine precision number which can be added to 1.0 such that the result is not rounded back to 1.0."
$MachinePrecision::usage:= "$MachinePrecision gives the number of decimal digits of precision used for machine precision numbers."
$MaxExtraPrecision::usage:= "$MaxExtraPrecision specifies the maximum extra number of decimal digits of precision used for iterative approximation."
$MaxMachineNumber::usage:= "$MaxMachineNumber is the largest machine-precision number which is representable on the computer system."
$MessageCount::usage:= "$MessageCount(\(\"symbol::tag\".StyleBox(\"Arg\")\)) gives the number of times the \(\"symbol::tag\".StyleBox(\"Arg\")\) message was generated during the current evaluation."
$MinMachineNumber::usage:= "$MinMachineNumber is the smallest machine-precision number which is representable on the computer system."
$Namespace::usage:= "$Namespace defines the current namespace."
$NamespacePath::usage:= "$NamespacePath is a list of namespaces, after $Namespace, to search in trying to find a symbol that has been entered."
$NewMessage::usage:= "$NewMessage is a global variable which, if set, is applied to the symbol name and tag of messages that are requested but have not yet been defined."
$NewSymbol::usage:= "$NewSymbol is a global variable which, if set, is applied to the name and namespace of newly created symbols."
$Packages::usage:= "$Packages is a list of all loaded packages."
$PageWidth::usage:= "$PageWidth is a global variable that defines the approximate number of characters per line."
$Path::usage:= "$Path gives the default search path for Get and related functions."
$PathListSeparator::usage:= "$PathListSeparator is the character you operating system uses to separate search paths."
$PathnameSeparator::usage:= "$PathnameSeparator is the character you operating system uses to separate directory names."
$ProcessId::usage:= "$ProcessId gives the ID assigned to the current \(StyleBox(\"pMath\", \"TI\")\) process by the operating system."
$ProcessorCount::usage:= "$ProcessorCount gives the number of CPUs on your computer."
$ProcessorType::usage:= "$ProcessorType gives a string that specifies your CPU type."
$SystemCharacterEncoding::usage:= "$SystemCharacterEncoding is the default character encoding on your system."
$SystemId::usage:= "$SystemId gives a string that specifies your operating system."
$ThreadId::usage:= "$ThreadId gives the ID assigned to the current thread by the operating system/threading library."
$TimeZone::usage:= "$TimeZone is the current time zone assumed for dates and times."
$VersionList::usage:= "$VersionList is a list {\(StyleBox(\"mayor\", \"Arg\")\), \(StyleBox(\"minor\", \"Arg\")\), \(StyleBox(\"revision\", \"Arg\")\), \(StyleBox(\"repository\", \"Arg\")\)} that describes the \(StyleBox(\"pMath\", \"TI\")\) version."
$VersionNumber::usage:= "$VersionNumber gives the \(StyleBox(\"pMath\", \"TI\")\) version number e.g. 0.01."
Abort::usage:= "Abort() aborts the current evaluation.\nAbort(\(\"task\".StyleBox(\"Arg\")\)) aborts another task."
Abs::usage:= "Abs(\(\"z\".StyleBox(\"Arg\")\)) gives the absolute value of the real or complex number \(\"z\".StyleBox(\"Arg\")\)."
AbsArg::usage:= "AbsArg(\(StyleBox(\"z\", \"Arg\")\)) gives the list {Abs(\(StyleBox(\"z\", \"Arg\")\)), Arg(\(StyleBox(\"z\", \"Arg\")\))} of the complex number \(StyleBox(\"z\", \"Arg\")\)."
AffineTransform::usage:= "AffineTransform(\(StyleBox(\"m\", \"Arg\")\)) gives a TransformationFunction that represents an affine transformation which maps \(StyleBox(\"r\", \"Arg\")\) to \({\"m\", \"\\[Dot]\", \"r\"}\).\nAffineTransform({\(StyleBox(\"m\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\)}) gives an affine transformation which maps \(StyleBox(\"r\", \"Arg\")\) to \({{\"m\", \"\\[Dot]\", \"r\"}, \"+\", \"b\"}\)."
AiryAi::usage:= "AiryAi(\(\"z\".StyleBox(\"Arg\")\)) gives the Airy function \({\"Ai\", \"(\", StyleBox(\"z\", \"Arg\"), \")\"}\)."
AiryAiPrime::usage:= "AiryAi(\(\"z\".StyleBox(\"Arg\")\)) gives the derivative of the Airy function \({{\"Ai\", SuperscriptBox(\"\\[Prime]\")}, \"(\", StyleBox(\"z\", \"Arg\"), \")\"}\)."
AiryBi::usage:= "AiryAi(\(\"z\".StyleBox(\"Arg\")\)) gives the Airy function \({\"Bi\", \"(\", StyleBox(\"z\", \"Arg\"), \")\"}\)."
AiryBiPrime::usage:= "AiryAi(\(\"z\".StyleBox(\"Arg\")\)) gives the derivative of the Airy function \({{\"Bi\", SuperscriptBox(\"\\[Prime]\")}, \"(\", StyleBox(\"z\", \"Arg\"), \")\"}\)."
All::usage:= "All is a setting used for certain options. In Part and related functions, All specifies all parts at a particular level."
Alternatives::usage:= "\({{\"p\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \"|\", {\"p\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \"|\", \"\[Ellipsis]\"}\) is a pattern object which represents any of the patterns \({\"p\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\)."
And::usage:= "\({{\"e\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \"&&\", {\"e\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \"&&\", \"\[Ellipsis]\"}\) is the logical AND function. It evaluates its arguments in order, giving False immediately if any of them is False, and True if all of them are True."
Antialiasing::usage:= "Antialiasing is an option for Section and Style for setting antialiasing of graphics on and off."
Append::usage:= "Apend(\({\"list\".StyleBox(\"Arg\"), \",\", \"elem\".StyleBox(\"Arg\")}\)) returns \(\"list\".StyleBox(\"Arg\")\) with \(\"elem\".StyleBox(\"Arg\")\) appended."
Apply::usage:= "\({\"f\".StyleBox(\"Arg\"), \"@@\", \"list\".StyleBox(\"Arg\")}\) or Apply(\({\"list\".StyleBox(\"Arg\"), \",\", \"f\".StyleBox(\"Arg\")}\)) returns \(\"list\".StyleBox(\"Arg\")\) with head \(\"f\".StyleBox(\"Arg\")\)."
ArcCos::usage:= "ArcCos(\(\"z\".StyleBox(\"Arg\")\)) gives the arc cosine \({{\"cos\",SuperscriptBox({\"-\", \"1\"})}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\) of the complex number \(\"z\".StyleBox(\"Arg\")\)."
ArcCosh::usage:= "ArcCosh(\(StyleBox(\"z\", \"Arg\")\)) gives the inverse hyperbolic cosine of \(StyleBox(\"z\", \"Arg\")\)."
ArcCot::usage:= "ArcCot(\(\"z\".StyleBox(\"Arg\")\)) gives the arc cotangent \({{\"cot\",SuperscriptBox({\"-\", \"1\"})}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\) of the complex number \(\"z\".StyleBox(\"Arg\")\)."
ArcCoth::usage:= "ArcCoth(\(StyleBox(\"z\", \"Arg\")\)) gives the inverse hyperbolic cotangent of \(StyleBox(\"z\", \"Arg\")\)."
ArcCsc::usage:= "ArcCsc(\(\"z\".StyleBox(\"Arg\")\)) gives the arc cosecant \({{\"csc\",SuperscriptBox({\"-\", \"1\"})}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\) of the complex number \(\"z\".StyleBox(\"Arg\")\)."
ArcCsch::usage:= "ArcCsch(\(StyleBox(\"z\", \"Arg\")\)) gives the inverse hyperbolic cosecant of \(StyleBox(\"z\", \"Arg\")\)."
ArcSec::usage:= "ArcSec(\(\"z\".StyleBox(\"Arg\")\)) gives the arc secant \({{\"sec\",SuperscriptBox({\"-\", \"1\"})}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\) of the complex number \(\"z\".StyleBox(\"Arg\")\)."
ArcSech::usage:= "ArcSech(\(StyleBox(\"z\", \"Arg\")\)) gives the inverse hyperbolic secant of \(StyleBox(\"z\", \"Arg\")\)."
ArcSin::usage:= "ArcSin(\(\"z\".StyleBox(\"Arg\")\)) gives the arc sine \({{\"sin\",SuperscriptBox({\"-\", \"1\"})}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\) of the complex number \(\"z\".StyleBox(\"Arg\")\)."
ArcSinh::usage:= "ArcSinh(\(StyleBox(\"z\", \"Arg\")\)) gives the inverse hyperbolic sine of \(StyleBox(\"z\", \"Arg\")\)."
ArcTan::usage:= "ArcTan(\(\"z\".StyleBox(\"Arg\")\)) gives the arc tangent \({{\"tan\",SuperscriptBox({\"-\", \"1\"})}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\) of the complex number \(\"z\".StyleBox(\"Arg\")\)."
ArcTanh::usage:= "ArcTanh(\(StyleBox(\"z\", \"Arg\")\)) gives the inverse hyperbolic tangent of \(StyleBox(\"z\", \"Arg\")\)."
Arg::usage:= "Arg(\(\"z\".StyleBox(\"Arg\")\)) gives the argument of the complex number \(\"z\".StyleBox(\"Arg\")\)."
Array::usage:= "Array(\(StyleBox(\"n\", \"Arg\")\)) generates a list of Length \(StyleBox(\"n\", \"Arg\")\) with elements 1, 2, \[Ellipsis], \(StyleBox(\"n\", \"Arg\")\).\nArray(\(StyleBox(\"s\", \"Arg\")\) .. \(StyleBox(\"e\", \"Arg\")\)) generates a list with elements \(StyleBox(\"s\", \"Arg\")\), \(StyleBox(\"s\", \"Arg\")\)+1, \[Ellipsis], \(StyleBox(\"e\", \"Arg\")\).\nArray(\(StyleBox(\"s\", \"Arg\")\) .. \(StyleBox(\"e\", \"Arg\")\) .. \(StyleBox(\"d\", \"Arg\")\)) uses steps of length \(StyleBox(\"d\", \"Arg\")\) (default 1).\nArray(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) generates a list of length \(StyleBox(\"n\", \"Arg\")\) with elements \({StyleBox(\"f\", \"Arg\"), \"(\", StyleBox(\"i\", \"Arg\"), \")\"}\).\nArray(\(StyleBox(\"f\", \"Arg\")\), {\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) generates an \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\)\[Times]\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\)\[Times]\[Ellipsis] array of lists, with elements \({StyleBox(\"f\", \"Arg\"), \"(\", {{StyleBox(\"i\", \"Arg\"), SubscriptBox(\"1\")}, \",\", {StyleBox(\"i\", \"Arg\"), SubscriptBox(\"2\")}, \",\", \"\\[Ellipsis]\"}, \")\"}\).\nArray(\(StyleBox(\"f\", \"Arg\")\), {\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, {\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) generates a list using the index origins \(StyleBox(\"s\", \"Arg\")\)\(StyleBox(SubscriptBox(StyleBox(\"i\", \"Arg\")), \"Arg\")\) (default 1).\nArray(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"dims\", \"Arg\")\), \(StyleBox(\"orgins\", \"Arg\")\), \(StyleBox(\"h\", \"Arg\")\)) uses head \(StyleBox(\"h\", \"Arg\")\), rather than List, for each level of the array."
AspectRatio::usage:= "AspectRatio is an option for graphics functions which specifies the ratio of height to width for a plot."
Assign::usage:= "\({\"lhs\".StyleBox(\"Arg\"), \"\[Assign]\", \"rhs\".StyleBox(\"Arg\")}\) evaluates \(\"rhs\".StyleBox(\"Arg\")\) and assigns the rules to be the value of \(\"lhs\".StyleBox(\"Arg\")\) in subsequent evaluations.\n\({{\"{\", {{\"l\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"l\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}, \"\[Assign]\", {\"{\", {{\"r\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"r\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}}\) evaluates the \({\"r\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\) and assigns the results to be the values of the corresponding \({\"l\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\)."
AssignDelayed::usage:= "\({\"lhs\".StyleBox(\"Arg\"), \"\[AssignDelayed]\", \"rhs\".StyleBox(\"Arg\")}\) assigns \(\"rhs\".StyleBox(\"Arg\")\) to be the delayed value of \(\"lhs\".StyleBox(\"Arg\")\). \(\"rhs\".StyleBox(\"Arg\")\) is maintained in an unevaluated form. When \(\"lhs\".StyleBox(\"Arg\")\) appears, it is replaces by \(\"rhs\".StyleBox(\"Arg\")\), evaluated afresh each time."
Associative::usage:= "Associative is an attribute that can be assigned to a symbol \(\"f\".StyleBox(\"Arg\")\) to indicate that all expressions involving nested functions \(\"f\".StyleBox(\"Arg\")\) should be flattened out. This property is accounted for pattern matching."
Attributes::usage:= "Attributes(\(\"symbol\".StyleBox(\"Arg\")\)) gives the attributes for a symbol."
AutoDelete::usage:= "AutoDelete is an option for boxes that specifies whether a box is automatically deleted when its contents is edited."
Automatic::usage:= "Automatic represents an option or other value that is to be chosen automatically by a built-in function."
AutoNumberFormating::usage:= "AutoNumberFormating is an option for Section that specifies whether numbers should be pretty-printed before output."
AutoSpacing::usage:= "AutoSpacing is an option for Style and Section which specifies whether spaces between successive characters should be adjusted automatically."
Axes::usage:= "Axes is an option for graphics functions which specifies whether axes should be drawn."
AxesOrigin::usage:= "AxesOrigin is an option for Graphics which specifies where the axes origin should be."
Background::usage:= "Background is an option for boxes to specify its background color."
BaseForm::usage:= "BaseForm(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\)) displays as \(StyleBox(\"expr\", \"Arg\")\) with all numbers given in base \(StyleBox(\"b\", \"Arg\")\)."
BaseStyle::usage:= "BaseStyle is an option for boxes to specify the base style to use for them."
Begin::usage:= "Begin(\"\(StyleBox(\"namespace\", \"Arg\")\) `\") resets the current namespace."
BeginPackage::usage:= "BeginPackage(\"\(StyleBox(\"namespace\", \"Arg\")\) `\") makes \(StyleBox(\"namespace\", \"Arg\")\)` and System` the only active namespaces.\nBeginPackage(\"\(StyleBox(\"namespace\", \"Arg\")\) `\", {\(StyleBox(\"need\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"need\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) additionally calls Get on the \(StyleBox({\"need\", SubscriptBox(\"i\")}, \"Arg\")\)."
BernoulliB::usage:= "BernoulliB(\(StyleBox(\"n\", \"Arg\")\)) gives the \(StyleBox(\"n\", \"Arg\")\)-th Bernoulli number \({\"B\", SubscriptBox(\"n\".StyleBox(\"Arg\"))}\)."
BesselI::usage:= "BesselI(\(\"n\".StyleBox(\"Arg\")\), \(\"z\".StyleBox(\"Arg\")\)) gives the modified Bessel function of the first kind \({{\"I\", SubscriptBox(\"n\".StyleBox(\"Arg\"))}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
BesselJ::usage:= "BesselJ(\(\"n\".StyleBox(\"Arg\")\), \(\"z\".StyleBox(\"Arg\")\)) gives the Bessel function of the first kind \({{\"J\", SubscriptBox(\"n\".StyleBox(\"Arg\"))}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
BesselK::usage:= "BesselK(\(\"n\".StyleBox(\"Arg\")\), \(\"z\".StyleBox(\"Arg\")\)) gives the modified Bessel function of the second kind \({{\"K\", SubscriptBox(\"n\".StyleBox(\"Arg\"))}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
BesselY::usage:= "BesselY(\(\"n\".StyleBox(\"Arg\")\), \(\"z\".StyleBox(\"Arg\")\)) gives the Bessel function of the second kind \({{\"Y\", SubscriptBox(\"n\".StyleBox(\"Arg\"))}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
BinaryFormat::usage:= "BinaryFormat is an option for OpenRead and related functions which specifies that a stream should be opened in binary format, so that no textual interpretation of newlines and other data is done."
BinaryRead::usage:= "BinaryRead(\(\"stream\".StyleBox(\"Arg\")\)) reads one byte of raw data from a binary input stream and returns an integer from 0 to 255.\nBinaryRead(\({\"stream\".StyleBox(\"Arg\"), \",\", \"type\".StyleBox(\"Arg\")}\)) reads an object of the specified type.\nBinaryRead(\({\"stream\".StyleBox(\"Arg\"), \",\", {\"{\", {{\"type\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"type\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}}\)) reads a sequence of objects of the specified types."
BinaryReadList::usage:= "BinaryReadList(\(\"file\".StyleBox(\"Arg\")\)) reads all remaining bytes from a binary input stream or file and returns a list of integers from 0 to 255.\nBinaryReadList(\({\"file\".StyleBox(\"Arg\"), \",\", \"type\".StyleBox(\"Arg\")}\)) reads objects of the specified type until the end of file is reached. The list of objects is returned.\nBinaryReadList(\({\"file\".StyleBox(\"Arg\"), \",\", {\"{\", {{\"type\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"type\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}}\)) reads objects with a sequence of types until the end of file is reached.\nBinaryReadList(\({\"file\".StyleBox(\"Arg\"), \",\", \"types\".StyleBox(\"Arg\")}\)) reads at most the first \(\"n\".StyleBox(\"Arg\")\) objects of the specified types."
BinaryWrite::usage:= "BinaryWrite(\({\"channel\".StyleBox(\"Arg\"), \",\", \"b\".StyleBox(\"Arg\")}\)) writes a byte of data, specified as an integer between 0 and 255.\nBinaryWrite(\({\"channel\".StyleBox(\"Arg\"), \",\", {\"{\", {{\"b\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"b\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}}\)) writes a sequence of bytes.\nBinaryWrite(\(\"channel\".StyleBox(\"Arg\")\), \"\(\"string\".StyleBox(\"Arg\")\)\") writes the raw sequence of characters in \(\"string\".StyleBox(\"Arg\")\), terminated with a 0 byte.\nBinaryWrite(\({\"channel\".StyleBox(\"Arg\"), \",\", \"x\".StyleBox(\"Arg\"), \",\", \"type\".StyleBox(\"Arg\")}\)) writes an object of the specified type.\nBinaryWrite(\({\"channel\".StyleBox(\"Arg\"), \",\", {\"{\", {{\"x\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"x\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}, \",\", \"type\".StyleBox(\"Arg\")}\)) writes a sequence of objects of the specified type.\nBinaryWrite(\({\"channel\".StyleBox(\"Arg\"), \",\", {\"{\", {{\"x\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"x\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}, \",\", {\"{\", {{\"type\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"type\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}}\)) writes a sequence of objects with a sequence of types."
Binomial::usage:= "Binomial(\(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"k\", \"Arg\")\)) gives the binomial coefficient \({\"(\", GridBox({{\"n\"}, {\"k\"}}), \")\"}\)."
BitAnd::usage:= "BitAnd(\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) returns the bitwise AND of the integers \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\), assuming twos complement for negative numbers."
BitClear::usage:= "BitClear(\(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"k\", \"Arg\")\)) returns \(StyleBox(\"n\", \"Arg\")\) with the bit corresponding to 2\(SuperscriptBox(StyleBox(\"k\", \"Arg\"))\) set to 0."
BitGet::usage:= "BitGet(\(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"k\", \"Arg\")\)) returns the bit corresponding to 2\(SuperscriptBox(StyleBox(\"k\", \"Arg\"))\)."
BitLength::usage:= "BitLength(\(StyleBox(\"n\", \"Arg\")\)) gives the number of binary bits necessary to represent the integer \(StyleBox(\"n\", \"Arg\")\)."
BitNot::usage:= "BitNot(\(StyleBox(\"n\", \"Arg\")\)) returns the bitwise NOT of the integer \(StyleBox(\"n\", \"Arg\")\), assuming twos complement."
BitOr::usage:= "BitOr(\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) returns the bitwise OR of the integers \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\), assuming twos complement for negative numbers."
BitSet::usage:= "BitSet(\(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"k\", \"Arg\")\)) returns \(StyleBox(\"n\", \"Arg\")\) with the bit corresponding to 2\(SuperscriptBox(StyleBox(\"k\", \"Arg\"))\) set to 1."
BitShiftLeft::usage:= "BitShiftLeft(\(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"k\", \"Arg\")\)) returns \(StyleBox(\"n\", \"Arg\")\) with all bits shifted to the left by \(StyleBox(\"k\", \"Arg\")\) places, padding with zeros on the right."
BitShiftRight::usage:= "BitShiftRight(\(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"k\", \"Arg\")\)) returns \(StyleBox(\"n\", \"Arg\")\) with all bits shifted to the right by \(StyleBox(\"k\", \"Arg\")\) places, dropping bits that are shifted past the unit's position on the right.\nBitShiftRight(\(StyleBox(\"n\", \"Arg\")\)) shifts one bit to the right."
BitXor::usage:= "BitXor(\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) returns the bitwise XOR (exclusive OR) of the integers \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\), assuming twos complement for negative numbers."
Black::usage:= "Black represents the color black in graphics and style specifications."
Block::usage:= "Block({\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \[Ellipsis]}, \(StyleBox(\"expr\", \"Arg\")\)) returns \(StyleBox(\"expr\", \"Arg\")\) evaluated while temporary resetting definitions of the symbols \(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \[Ellipsis].\nBlock({\(StyleBox(\"x\", \"Arg\")\) \[Assign] \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"0\")\), \[Ellipsis]}, \(StyleBox(\"expr\", \"Arg\")\)) defines initial local values for \(StyleBox(\"x\", \"Arg\")\), \[Ellipsis] after resetting."
Blue::usage:= "Blue represents the color blue in graphics and style specifications."
Bold::usage:= "Bold represents a bold font weight."
Boole::usage:= "Boole(\(StyleBox(\"expr\", \"Arg\")\)) yields 1 if \(StyleBox(\"expr\", \"Arg\")\) is True and 0 if it is False."
BorderRadius::usage:= "BorderRadius is an option for Style, Framed and related constructs which specifies the border radii to be used for the top-left, top-right, bottom-right and bottom-left corner."
BoxData::usage:= "BoxData(\(StyleBox(\"boxes\", \"Arg\")\)) represents the content of a non-text-Section."
BoxRotation::usage:= "BoxRotation is an option for RotationBox that specifies the angle by which its content should be rotated."
BoxTransformation::usage:= "BoxTransformation is an option for TransformatBox which specifies the affine transformation matrix to apply to its content."
BracketingBar::usage:= "BracketingBar(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \[Ellipsis]) displays as \[LeftBracketingBar]\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \[Ellipsis]\[RightBracketingBar]."
Break::usage:= "Break() exits the nearest enclosing Do, For or While.\nBreak(\(\"n\".StyleBox(\"Arg\")\)) exits the \(\"n\".StyleBox(\"Arg\")\)-th nearest enclosing Do, For or While."
Brown::usage:= "Brown represents the color brown in graphics and style specifications."
Button::usage:= "Button(\({\"label\".StyleBox(\"Arg\"), \",\", \"action\".StyleBox(\"Arg\")}\)) represents a button, that is labeled with \(\"label\".StyleBox(\"Arg\")\) and evaluates \(\"action\".StyleBox(\"Arg\")\) whenever it is pressed."
ButtonBox::usage:= "ButtonBox(\(\"boxes\".StyleBox(\"Arg\")\)) is a low-level box construct that represents a button in a document expression."
ButtonFrame::usage:= "ButtonFrame is an option for Button and ButtonBox which specifies the type of frame to display around a button."
ButtonFunction::usage:= "ButtonFunction is an option for ButtonBox which specifies the action to perform when the button is clicked."
ByteCount::usage:= "ByteCount(\(\"expr\".StyleBox(\"Arg\")\)) gives the number of bytes used internally to store \(\"expr\".StyleBox(\"Arg\")\)."
ByteOrdering::usage:= "ByteOrdering is an option for BinaryRead, BinaryWrite and related functions which specifies what ordering of bytes should be assumed for your computer."
Cases::usage:= "Cases(\({{\"{\", {{\"e\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"e\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}, \",\", \"pattern\".StyleBox(\"Arg\")}\)) gives a list of the \({\"e\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\) that match the pattern.\nCases(\({{\"{\", {{\"e\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"e\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}, \",\", {\"pattern\".StyleBox(\"Arg\"), \"->\", \"rhs\".StyleBox(\"Arg\")}}\)) gives a list of the \(\"rhs\".StyleBox(\"Arg\")\) corresponding to the \({\"e\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\) that match the pattern.\nCases(\({\"expr\".StyleBox(\"Arg\"), \",\", \"pattern\".StyleBox(\"Arg\"), \",\", \"levelspec\".StyleBox(\"Arg\")}\)) gives a list of all parts of \(\"expr\".StyleBox(\"Arg\")\) at levels specified by \(\"levelspec\".StyleBox(\"Arg\")\) which match the pattern.\nCases(\({\"expr\".StyleBox(\"Arg\"), \",\", {\"pattern\".StyleBox(\"Arg\"), \"->\", \"rhs\".StyleBox(\"Arg\")}, \",\", \"levelspec\".StyleBox(\"Arg\")}\)) gives the values of \(\"rhs\".StyleBox(\"Arg\")\) for parts which match the pattern.\nCases(\({\"expr\".StyleBox(\"Arg\"), \",\", \"pattern\".StyleBox(\"Arg\"), \",\", \"levelspec\".StyleBox(\"Arg\"), \",\", \"n\".StyleBox(\"Arg\")}\)) gives the first \(\"n\".StyleBox(\"Arg\")\) parts in \(\"expr\".StyleBox(\"Arg\")\) which match the pattern."
Catch::usage:= "Catch(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"pat\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"pat\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) evaluates and returns \(StyleBox(\"expr\", \"Arg\")\)  unless an exception which matches any of the \(StyleBox(\"pat\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) is thrown during that evaluation. In this case, the exception is returned.\nCatch(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"pat\", \"Arg\")\)\(SubscriptBox(\"1\")\) \[RuleDelayed] \(StyleBox(\"err\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"pat\", \"Arg\")\)\(SubscriptBox(\"2\")\) \[RuleDelayed] \(StyleBox(\"err\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) returns \(StyleBox(\"err\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) if an exception which matches \(StyleBox(\"pat\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) occurs during the evaluation of \(StyleBox(\"expr\", \"Arg\")\)."
Ceiling::usage:= "Ceiling(\(\"x\".StyleBox(\"Arg\")\)) gives the smallest integer greater than or equal to \(\"x\".StyleBox(\"Arg\")\).\nCeiling(\({\"x\".StyleBox(\"Arg\"), \",\", \"a\".StyleBox(\"Arg\")}\)) gives the smallest multiple of \(\"a\".StyleBox(\"Arg\")\) greater than or equal to \(\"x\".StyleBox(\"Arg\")\)."
Character::usage:= "Character represents a single character in Read."
CharacterEncoding::usage:= "CharacterEncoding is an option for OpenRead and related functions which the character encoding for text input and output."
Characters::usage:= "Characters(\(StyleBox(\"string\", \"Arg\")\)) gives a list of the characters in a string."
Checkbox::usage:= "Checkbox(\(StyleBox(\"x\", \"Arg\")\)) represents a checkbox with setting \(StyleBox(\"x\", \"Arg\")\), displayed as \(CheckboxBox(True)\) when \(StyleBox(\"x\", \"Arg\")\) is True, \(CheckboxBox(False)\) when it is False and \(CheckboxBox(Undefined)\) otherwise.\nCheckbox(Dynamic(\(StyleBox(\"x\", \"Arg\")\))) also dynamically sets the value of \(StyleBox(\"x\", \"Arg\")\) to True or False when the checkbox is clicked.\nCheckbox(\(StyleBox(\"x\", \"Arg\")\), {\(StyleBox(\"fval\", \"Arg\")\), \(StyleBox(\"tval\", \"Arg\")\)}) represents a checkbox which toggles between \(StyleBox(\"fval\", \"Arg\")\) and \(StyleBox(\"tval\", \"Arg\")\)."
ChebyshevT::usage:= "ChebyshevT(\(\"n\".StyleBox(\"Arg\")\), \(\"z\".StyleBox(\"Arg\")\)) gives the Chebyshev polynomial of the first kind \({{\"T\", SubscriptBox(\"n\".StyleBox(\"Arg\"))}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
ChebyshevU::usage:= "ChebyshevU(\(\"n\".StyleBox(\"Arg\")\), \(\"z\".StyleBox(\"Arg\")\)) gives the Chebyshev polynomial of the second kind \({{\"U\", SubscriptBox(\"n\".StyleBox(\"Arg\"))}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
CheckboxBox::usage:= "CheckboxBox(\(StyleBox(\"x\", \"Arg\")\), {\(StyleBox(\"fval\", \"Arg\")\), \(StyleBox(\"tval\", \"Arg\")\)}) is a low-level construct that represents a checkbox with setting \(StyleBox(\"x\", \"Arg\")\) toggling between \(StyleBox(\"fval\", \"Arg\")\) and \(StyleBox(\"tval\", \"Arg\")\)."
Chop::usage:= "Chop(\(\"expr\".StyleBox(\"Arg\")\)) replaces approximate real numbers in \(\"expr\".StyleBox(\"Arg\")\) which are close to zero by the exact integer 0."
CirclePlus::usage:= "CirclePlus(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[CirclePlus]\", \"y\".StyleBox(\"Arg\"), \"\[CirclePlus]\", \"\[Ellipsis]\"}\) in StandardForm."
CircleTimes::usage:= "CircleTimes(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[CircleTimes]\", \"y\".StyleBox(\"Arg\"), \"\[CircleTimes]\", \"\[Ellipsis]\"}\) in StandardForm."
Clear::usage:= "Clear(\({{\"symbol\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"symbol\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}\)) clears values and definitions for the \({\"symbol\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\).\nClear(\({{\"form\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"form\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}\)) clears values and definitions for all symbols whose names match any of the string patterns \({\"form\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\)."
ClearAll::usage:= "ClearAll(\({{\"symbol\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"symbol\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}\)) clears values, definitions, attributes and options for the \({\"symbol\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\).\nClear(\({{\"form\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"form\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}\)) clears values, definitions attributes and options for all symbols whose names match any of the string patterns \({\"form\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\)."
ClearAttributes::usage:= "ClearAttributes(\(StyleBox(\"symbol\", \"Arg\")\), \(StyleBox(\"attr\", \"Arg\")\)) removes \(StyleBox(\"attr\", \"Arg\")\) from the list of attributes of \(StyleBox(\"symbol\", \"Arg\")\)."
Clip::usage:= "Clip(\(StyleBox(\"x\", \"Arg\")\)) gives \(StyleBox(\"x\", \"Arg\")\) clipped to the range from -1 to 1.\nClip(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"min\", \"Arg\")\) .. \(StyleBox(\"max\", \"Arg\")\)) clips to the range from \(StyleBox(\"min\", \"Arg\")\) to \(StyleBox(\"max\", \"Arg\")\).\nClip(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"min\", \"Arg\")\) .. \(StyleBox(\"max\", \"Arg\")\), \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) gives \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) for \(StyleBox(\"x\", \"Arg\")\) < \(StyleBox(\"min\", \"Arg\")\) and \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\) for \(StyleBox(\"x\", \"Arg\")\) > \(StyleBox(\"max\", \"Arg\")\)."
Clock::usage:= "Clock() represents a clock variable whose value cycles continuously form 0 to 1 once per second when it appears inside Dynamic or similar objects.\nClock(\(StyleBox(\"t\", \"Arg\")\)) cycles from 0 to \(StyleBox(\"t\", \"Arg\")\) every \(StyleBox(\"t\", \"Arg\")\) seconds.\nClock(\(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(\"max\")\) , \(StyleBox(\"t\", \"Arg\")\)) cycles from 0 to \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(\"max\")\) every \(StyleBox(\"t\", \"Arg\")\) seconds.\nClock(\(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(\"min\")\) .. \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(\"max\")\)) cycles through the range \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(\"min\")\) to \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(\"max\")\) over the course of \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(\"max\")\) - \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(\"min\")\) seconds.\nClock(\(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(\"min\")\) .. \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(\"max\")\) .. \(StyleBox(\"dv\", \"Arg\")\)) cycles from \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(\"min\")\) to \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(\"max\")\) in steps of \(StyleBox(\"dv\", \"Arg\")\), spending \(StyleBox(\"dv\", \"Arg\")\) seconds at each value.\nClock(\(StyleBox(\"vals\", \"Arg\")\), \(StyleBox(\"t\", \"Arg\")\)) takes \(StyleBox(\"t\", \"Arg\")\) seconds for each cycle.\nClock(\(StyleBox(\"vals\", \"Arg\")\), \(StyleBox(\"t\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) goes through the cycle only \(StyleBox(\"n\", \"Arg\")\) times, then always yields only the maximum value."
Close::usage:= "Close(\(\"stream\".StyleBox(\"Arg\")\)) closes a stream."
Colon::usage:= "Colon(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[Colon]\", \"y\".StyleBox(\"Arg\"), \"\[Colon]\", \"\[Ellipsis]\"}\)."
Column::usage:= "Column(\(StyleBox(\"list\", \"Arg\")\)) displays a \(StyleBox(\"list\", \"Arg\")\) of items in a column."
ColumnSpacing::usage:= "ColumnSpacing is an option for Grid which specifies the spacing between adjacent columns in points."
Complement::usage:= "Complement(\({{\"e\",SubscriptBox(\"all\")}.StyleBox(\"Arg\"), \",\", {\"e\".StyleBox(\"Arg\"),SubscriptBox(\"1\")}, \",\", {\"e\".StyleBox(\"Arg\"),SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}\)) gives the elements in \({\"e\",SubscriptBox(\"all\")}.StyleBox(\"Arg\")\) which are not in any of the \({\"e\",SubscriptBox(\"i\")}.StyleBox(\"Arg\")\)."
Complex::usage:= "Complex(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\")}\)) represents a complex number with real part \(\"x\".StyleBox(\"Arg\")\) and imaginary part \(\"y\".StyleBox(\"Arg\")\)."
ComplexInfinity::usage:= "ComplexInfinity represents an infinite numerical quantity whose direction in the complex plane is unknown."
Compress::usage:= "Compress(\(StyleBox(\"expr\", \"Arg\")\)) returns a compressed representation of \(StyleBox(\"expr\", \"Arg\")\)."
CompressStream::usage:= "CompressStream(\(StyleBox(\"stream\", \"Arg\")\)) returns a new binary stream that compresses its data into the existing writable \(StyleBox(\"stream\", \"Arg\")\)."
Condition::usage:= "\({\"patt\".StyleBox(\"Arg\"), \"/?\", \"test\".StyleBox(\"Arg\")}\) is a pattern which matches only if the evaluation of \(\"test\".StyleBox(\"Arg\")\) yields True.\n\({\"lhs\".StyleBox(\"Arg\"), \":>\", {\"rhs\".StyleBox(\"Arg\"), \"/?\", \"test\".StyleBox(\"Arg\")}}\) represents a rule which applies only if the evaluation of \(\"test\".StyleBox(\"Arg\")\) yields True.\n\({\"lhs\".StyleBox(\"Arg\"), \"::=\", {\"rhs\".StyleBox(\"Arg\"), \"/?\", \"test\".StyleBox(\"Arg\")}}\) is a definition to be used only if \(\"test\".StyleBox(\"Arg\")\) yields True."
ConditionalExpression::usage:= "ConditionalExpression(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"test\", \"Arg\")\)) represents an expression that is only defined where \(StyleBox(\"test\", \"Arg\")\) evaluates to True."
Congruent::usage:= "Congruent(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[Congruent] \(StyleBox(\"y\", \"Arg\")\) \[Congruent] \[Ellipsis]."
Conjugate::usage:= "Conjugate(\(StyleBox(\"z\", \"Arg\")\)) gives the conjugate of the complex number \(StyleBox(\"z\", \"Arg\")\)."
ConstantArray::usage:= "ConstantArray(\(StyleBox(\"c\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) generates a list of \(StyleBox(\"n\", \"Arg\")\) copies of the element \(StyleBox(\"c\", \"Arg\")\).\nConstantArray(\(StyleBox(\"c\", \"Arg\")\), {\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) generates an \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\) \[Times] \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\) \[Times] \[Ellipsis] array of nested lists containing the element \(StyleBox(\"c\", \"Arg\")\)."
Continue::usage:= "Continue() jumps to the next iteration of the nearest enclosing For, Do or While loop."
ContinuousAction::usage:= "ContinuousAction is an option for Slider and related functions which specifies whether values should be updated continuously while controls are being moved or only when the mouse is released."
ControlActive::usage:= "ControlActive(\(StyleBox(\"act\", \"Arg\")\), \(StyleBox(\"norm\", \"Arg\")\)) evaluates to \(StyleBox(\"act\", \"Arg\")\) if the user is currently interacting with a control (i.e. a mouse button is pressed), and \(StyleBox(\"norm\", \"Arg\")\) otherwise."
CopyDirectory::usage:= "CopyDirectory(\({{\"dir\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"dir\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}}\)) copies the directory \({\"dir\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}\) to \({\"dir\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}\)."
CopyFile::usage:= "CopyFile(\({{\"file\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"file\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}}\)) copies \({\"file\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}\) to \({\"file\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}\)."
Cos::usage:= "Cos(\(\"z\".StyleBox(\"Arg\")\)) gives the cosine of \(\"z\".StyleBox(\"Arg\")\)."
Cosh::usage:= "Cosh(\(\"z\".StyleBox(\"Arg\")\)) gives the hyperbolic cosine of \(\"z\".StyleBox(\"Arg\")\)."
CoshIntegral::usage:= "CoshIntegral(\(\"z\".StyleBox(\"Arg\")\)) gives the hyperbolic cosine integral function \({\"Chi\", \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
CosIntegral::usage:= "CosIntegral(\(\"z\".StyleBox(\"Arg\")\)) gives the cosine integral function \({\"Ci\", \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
Cot::usage:= "Cot(\(\"z\".StyleBox(\"Arg\")\)) gives the cotangent of \(\"z\".StyleBox(\"Arg\")\)."
Coth::usage:= "Coth(\(\"z\".StyleBox(\"Arg\")\)) gives the hyperbolic cotangent of \(\"z\".StyleBox(\"Arg\")\)."
Count::usage:= "Count(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"pattern\", \"Arg\")\)) gives the number of elements in \(StyleBox(\"list\", \"Arg\")\) that match \(StyleBox(\"pattern\", \"Arg\")\).\nCount(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"pattern\", \"Arg\")\), \(StyleBox(\"levelspec\", \"Arg\")\)) gives the total number of subexpressions matching \(StyleBox(\"pattern\", \"Arg\")\) that appear at the levels in \(StyleBox(\"expr\", \"Arg\")\) specified by \(StyleBox(\"levelspec\", \"Arg\")\)."
CreateDirectory::usage:= "Create(\"\(\"dir\".StyleBox(\"Arg\")\) \") creates a directory with name \(\"dir\".StyleBox(\"Arg\")\)."
CreateDocument::usage:= "CreateDocument() creates a new empty document window.\nCreateDocument({\(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) creates a new document window with sections containing the \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
Cross::usage:= "Cross(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\)) gives the vector cross product of \(StyleBox(\"a\", \"Arg\")\) and \(StyleBox(\"b\", \"Arg\")\)."
Csc::usage:= "Csc(\(\"z\".StyleBox(\"Arg\")\)) gives the cosecant of \(\"z\".StyleBox(\"Arg\")\)."
Csch::usage:= "Csch(\(\"z\".StyleBox(\"Arg\")\)) gives the hyperbolic cosecant of \(\"z\".StyleBox(\"Arg\")\)."
CubeRoot::usage:= "CubeRoot(\(StyleBox(\"x\", \"Arg\")\)) gives the real-valued cube root of \(StyleBox(\"x\", \"Arg\")\)."
CupCap::usage:= "CupCap(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[CupCap] \(StyleBox(\"y\", \"Arg\")\) \[CupCap] \[Ellipsis]."
CurrentValue::usage:= "CurrentValue(\(StyleBox(\"item\", \"Arg\")\)) gives the current value of \(StyleBox(\"item\", \"Arg\")\) at a location in the \(StyleBox(\"pMath\", \"TI\")\) interface or system.\nCurrentValue(\(StyleBox(\"obj\", \"Arg\")\), \(StyleBox(\"item\", \"Arg\")\)) gives the current value of \(StyleBox(\"item\", \"Arg\")\) associated with a frontend object \(StyleBox(\"obj\", \"Arg\")\)."
Cyan::usage:= "Cyan represents the color cyan in graphics and style specifications."
DataRange::usage:= "DataRange is an option for functions like ListLinePlot which specifies the assumed coordinate range of height data."
DateList::usage:= "DateList() gives the current local date and time in the form {\(StyleBox(\"year\", \"Arg\")\), \(StyleBox(\"month\", \"Arg\")\), \(StyleBox(\"day\", \"Arg\")\), \(StyleBox(\"hour\", \"Arg\")\), \(StyleBox(\"minute\", \"Arg\")\), \(StyleBox(\"second\", \"Arg\")\)}.\nDateList(\(StyleBox(\"time\", \"Arg\")\)) gives the date list corresponding to the date which is \(StyleBox(\"time\", \"Arg\")\) seconds after 1 January, 1970 UTC."
Decrement::usage:= "\({\"--\", StyleBox(\"x\", \"Arg\")}\) decreases the value of \(StyleBox(\"x\", \"Arg\")\) by 1 and returns the new value.\n\({StyleBox(\"x\", \"Arg\"), \"-=\", \"y\"}\) decreases \(StyleBox(\"x\", \"Arg\")\) by \(StyleBox(\"y\", \"Arg\")\) and returns the new value."
DeepHoldAll::usage:= "DeepHoldAll is an attribute that can be assigned to a symbol \(\"f\".StyleBox(\"Arg\")\) to indicate that all arguments \(\"x\".StyleBox(\"Arg\")\), \(\"y\".StyleBox(\"Arg\")\), \[Ellipsis] in \({{\"f\".StyleBox(\"Arg\"), \"(\", {\"a\".StyleBox(\"Arg\"), \",\", \"b\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}, \")\"}, \"(\", {\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}, \")\"}\) are to be maintained in unevaluated form."
Default::usage:= "Default(\(StyleBox(\"f\", \"Arg\")\)) gives the default value for arguments of the function \(StyleBox(\"f\", \"Arg\")\) obtained with the ?\(StyleBox(\"x\", \"Arg\")\) pattern.\nDefault(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\)) gives the default value to use when ?\(StyleBox(\"x\", \"Arg\")\) appears as the \(StyleBox(\"i\", \"Arg\")\)\(SuperscriptBox(\"th\")\) argument of \(StyleBox(\"f\", \"Arg\")\).\nDefault(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) gives the default value for the \(StyleBox(\"i\", \"Arg\")\)\(SuperscriptBox(\"th\")\) argument out of a total of \(StyleBox(\"n\", \"Arg\")\) arguments.\nDefault(\(StyleBox(\"f\", \"Arg\")\), \[Ellipsis]):= \(StyleBox(\"val\", \"Arg\")\) defines the default value for arguments of \(StyleBox(\"f\", \"Arg\")\)."
DefaultDuplicateSectionStyle::usage:= "DefaultDuplicateSectionStyle is an option for Section which specifies the default new style when editing the section and SectionEditDuplicate is True."
DefaultNewSectionStyle::usage:= "DefaultNewSectionStyle is an option for Section which specifies the default style of newly created sections in the same section group."
DefaultReturnCreatedSectionStyle::usage:= "DefaultReturnCreatedSectionStyle is an option for Section which specifies the default style of the section created by pressing enter when ReturnCreatesNewSection is True."
DefaultRules::usage:= "DefaultRules(\(\"f\".StyleBox(\"Arg\")\)) gives a list of transformation rules corresponding to the Default and Options definitions of \(\"f\".StyleBox(\"Arg\")\)."
DefiniteFunction::usage:= "DefiniteFunction is an attribute that can be assigned to a symbol \(StyleBox(\"f\", \"Arg\")\) to indicate that \(StyleBox(\"f\", \"Arg\")\)(ConditionalExpression(\(StyleBox(\"arg\", \"Arg\")\), \(StyleBox(\"cond\", \"Arg\")\))) should become ConditionalExpression(\(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"arg\", \"Arg\")\)), \(StyleBox(\"cond\", \"Arg\")\))."
Degree::usage:= "Degree is the number of radians per degree. Its numerical value is \(FractionBox(\"\\[Pi]\", \"180\")\)."
DeleteContents::usage:= "DeleteContents is an option for DeleteDirectory which specifies whether the contents of directories should automatically be deleted."
DeleteDirectory::usage:= "DeleteDirectory(\"\(\"dir\".StyleBox(\"Arg\")\) \") deletes the specified directory."
DeleteFile::usage:= "DeleteFile(\"\(\"file\".StyleBox(\"Arg\")\) \") deletes a file."
Depth::usage:= "Depth(\(\"expr\".StyleBox(\"Arg\")\)) gives the maximum number of indices needed to specify any part of \(\"expr\".StyleBox(\"Arg\")\), plus one."
Det::usage:= "Det(\(StyleBox(\"m\", \"Arg\")\)) gives the determinant of a square matrix \(StyleBox(\"m\", \"Arg\")\)."
DiagonalMatrix::usage:= "DiagonalMatrix(\(StyleBox(\"list\", \"Arg\")\) ) gives a matrix with elements \(StyleBox(\"list\", \"Arg\")\) on the leading diagonal, and 0 elsewhere.\nDiagonalMatrix(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"k\", \"Arg\")\)) gives a matrix with the elements of \(StyleBox(\"list\", \"Arg\")\) on the \(StyleBox(\"k\", \"Arg\")\)\(SuperscriptBox(\"th\")\) diagonal."
Dialog::usage:= "Dialog() enters a new subsession."
DigitCharacter::usage:= "DigitCharacter represents a digit character 0-9 in StringExpression."
Dimensions::usage:= "Dimensions(\(\"expr\".StyleBox(\"Arg\")\)) gives a list of dimensions of \(\"expr\".StyleBox(\"Arg\")\).\nDimensions(\({\"expr\".StyleBox(\"Arg\"), \",\", \"n\".StyleBox(\"Arg\")}\)) gives a list of dimensions of \(\"expr\".StyleBox(\"Arg\")\) down to level \(\"n\".StyleBox(\"Arg\")\)."
DirectedInfinity::usage:= "DirectedInfinity() represents an infinite numerical quantity whose direction in the complex plane is unknown.\nDirectedInfinity(\(\"z\".StyleBox(\"Arg\")\)) represents an infinite numerical quantity that is a positive real multiple of the complex number \(\"z\".StyleBox(\"Arg\")\)."
Directive::usage:= "Directive(\(StyleBox(\"g\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"g\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) represents a single graphics directive composed of the directives \(StyleBox(\"g\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"g\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]."
Directory::usage:= "Directory() gives the current working directory."
DirectoryName::usage:= "DirectoryName(\"\(StyleBox(\"name\", \"Arg\")\) \") extracts the directory name from the specification for a file.\nDirectoryName(\"\(StyleBox(\"name\", \"Arg\")\) \", \(StyleBox(\"n\", \"Arg\")\)) applies DirectoryName \(StyleBox(\"n\", \"Arg\")\) times."
DivideBy::usage:= "\({\"x\", \"/=\", \"y\"}\) divides \(StyleBox(\"x\", \"Arg\")\) by \(StyleBox(\"y\", \"Arg\")\) and returns the new value."
Do::usage:= "Do(\({\"expr\".StyleBox(\"Arg\"), \",\", {\"i\", SubscriptBox(\"max\")}.StyleBox(\"Arg\")}\)) evaluates \(\"expr\".StyleBox(\"Arg\")\)  \({\"i\", SubscriptBox(\"max\")}.StyleBox(\"Arg\")\) times.\nDo(\({\"expr\".StyleBox(\"Arg\"), \",\", {\"i\".StyleBox(\"Arg\"), \"->\", {\"i\", SubscriptBox(\"max\")}.StyleBox(\"Arg\")}}\)) evaluates \(\"expr\".StyleBox(\"Arg\")\) with the variable \(\"i\".StyleBox(\"Arg\")\) successively taking the values 1 through \({\"i\", SubscriptBox(\"max\")}.StyleBox(\"Arg\")\).\nDo(\({\"expr\".StyleBox(\"Arg\"), \",\", {\"i\".StyleBox(\"Arg\"), \"->\", {{\"i\", SubscriptBox(\"min\")}.StyleBox(\"Arg\"), \"..\", {\"i\", SubscriptBox(\"max\")}.StyleBox(\"Arg\")}}}\)) evaluates \(\"expr\".StyleBox(\"Arg\")\) with the variable \(\"i\".StyleBox(\"Arg\")\) successively taking the values \({\"i\", SubscriptBox(\"min\")}.StyleBox(\"Arg\")\) through \({\"i\", SubscriptBox(\"max\")}.StyleBox(\"Arg\")\).\nDo(\({\"expr\".StyleBox(\"Arg\"), \",\", {\"i\".StyleBox(\"Arg\"), \"->\", {{{\"i\", SubscriptBox(\"min\")}.StyleBox(\"Arg\"), \"..\", {\"i\", SubscriptBox(\"max\")}.StyleBox(\"Arg\")}, \"..\", \"di\".StyleBox(\"Arg\")}}}\)) uses steps \(\"di\".StyleBox(\"Arg\")\).\nDo(\({\"expr\".StyleBox(\"Arg\"), \",\", {\"i\".StyleBox(\"Arg\"), \"->\", {\"{\", {{\"i\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"i\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"},\"}\"}}}\)) uses the successive values \({\"i\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}\), \({\"i\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}\), \(\"\[Ellipsis]\"\)."
DockedSections::usage:= "DockedSections is a document option to defined sections which should be docked to the top or bottom of the window."
Document::usage:= "Document(\({\"{\", {{\"section\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"section\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}\)) is a low-level construct that represents a document manipulated by the \(StyleBox(\"pMath\", \"TI\")\) front-end."
DocumentApply::usage:= "DocumentApply(\(StyleBox(\"document\", \"Arg\")\), \(StyleBox(\"data\", \"Arg\")\)) writes \(StyleBox(\"data\", \"Arg\")\) into a document at the current selection, replacing the first selection placeholder in \(StyleBox(\"data\", \"Arg\")\) by the current selection and then setting the cursor just after the data written."
DocumentDelete::usage:= "DocumentDelete() deletes the current selection.\nDocumentDelete(\(StyleBox(\"document\", \"Arg\")\)) deletes the current selection in the given document."
DocumentGet::usage:= "DocumentGet() gives the raw boxes expression of the currently selected document.\nDocumentGet(\(StyleBox(\"document\", \"Arg\")\)) gives the raw boxes expression of the given document."
DocumentRead::usage:= "DocumentRead() gives the raw boxes expression of the current selection.\nDocumentRead(\(StyleBox(\"document\", \"Arg\")\)) gives the raw boxes expression of the current selection in the given document."
Documents::usage:= "Documents() gives a list of all documents currently opened in the front-end."
DocumentSave::usage:= "DocumentSave() saves the current document.\nDocumentSave(\(StyleBox(\"doc\", \"Arg\")\)) saves some document identified by \(StyleBox(\"doc\", \"Arg\")\).\nDocumentSave(\(StyleBox(\"doc\", \"Arg\")\), \"\(StyleBox(\"filename\", \"Arg\")\)\") saves the document to a given file name."
DocumentWrite::usage:= "DocumentWrite(\(StyleBox(\"document\", \"Arg\")\), \(StyleBox(\"data\", \"Arg\")\)) writes \(StyleBox(\"data\", \"Arg\")\) into a document at the current selection and then setting the cursor just after the data written."
Dot::usage:= "Dot(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \[Ellipsis]) gives the products of vectors, matrices and tensors."
DotEqual::usage:= "DotEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[DotEqual] \(StyleBox(\"y\", \"Arg\")\) \[DotEqual] \[Ellipsis]."
DoubleBracketingBar::usage:= "DoubleBracketingBar(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \[Ellipsis]) displays as \[LeftDoubleBracketingBar]\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \[Ellipsis]\[RightDoubleBracketingBar]."
DoubleDownArrow::usage:= "DoubleDownArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[DoubleDownArrow]\", \"y\".StyleBox(\"Arg\"), \"\[DoubleDownArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
DoubleLeftArrow::usage:= "DoubleLeftArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[DoubleLeftArrow]\", \"y\".StyleBox(\"Arg\"), \"\[DoubleLeftArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
DoubleLeftRightArrow::usage:= "DoubleLeftRightArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[DoubleLeftRightArrow]\", \"y\".StyleBox(\"Arg\"), \"\[DoubleLeftRightArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
DoubleLowerLeftArrow::usage:= "DoubleLowerLeftArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[DoubleLowerLeftArrow]\", \"y\".StyleBox(\"Arg\"), \"\[DoubleLowerLeftArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
DoubleLowerRightArrow::usage:= "DoubleLowerRightArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[DoubleLowerRightArrow]\", \"y\".StyleBox(\"Arg\"), \"\[DoubleLowerRightArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
DoubleRightArrow::usage:= "DoubleRightArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[DoubleRightArrow]\", \"y\".StyleBox(\"Arg\"), \"\[DoubleRightArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
DoubleUpArrow::usage:= "DoubleUpArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[DoubleUpArrow]\", \"y\".StyleBox(\"Arg\"), \"\[DoubleUpArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
DoubleUpDownArrow::usage:= "DoubleUpDownArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[DoubleUpDownArrow]\", \"y\".StyleBox(\"Arg\"), \"\[DoubleUpDownArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
DoubleUpperLeftArrow::usage:= "DoubleUpperLeftArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[DoubleUpperLeftArrow]\", \"y\".StyleBox(\"Arg\"), \"\[DoubleUpperLeftArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
DoubleUpperRightArrow::usage:= "DoubleUpperRightArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[DoubleUpperRightArrow]\", \"y\".StyleBox(\"Arg\"), \"\[DoubleUpperRightArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
DownArrow::usage:= "DownArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[DownArrow]\", \"y\".StyleBox(\"Arg\"), \"\[DownArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
DownRules::usage:= "DownRules(\(StyleBox(\"f\", \"Arg\")\)) gives a list of transformation rules corresponding to all definitions \(StyleBox(\"f\", \"Arg\")\)(\[Ellipsis]) \[AssignDelayed] \[Ellipsis]."
Drop::usage:= "Drop(\({\"list\".StyleBox(\"Arg\"), \",\", \"n\".StyleBox(\"Arg\")}\)) gives \(\"list\".StyleBox(\"Arg\")\) with the first \(\"n\".StyleBox(\"Arg\")\) elements dropped.\nDrop(\({\"list\".StyleBox(\"Arg\"), \",\", {\"-\", \"n\".StyleBox(\"Arg\")}}\)) gives \(\"list\".StyleBox(\"Arg\")\) with the last \(\"n\".StyleBox(\"Arg\")\) elements dropped.\nDrop(\({\"list\".StyleBox(\"Arg\"), \",\", {\"m\".StyleBox(\"Arg\"), \"..\", \"n\".StyleBox(\"Arg\")}}\)) gives \(\"list\".StyleBox(\"Arg\")\) with the elements \(\"m\".StyleBox(\"Arg\")\) through \(\"n\".StyleBox(\"Arg\")\) dropped.\nDrop(\({\"list\".StyleBox(\"Arg\"), \",\", {{\"m\".StyleBox(\"Arg\"), \"..\", \"n\".StyleBox(\"Arg\")}, \"..\", \"s\".StyleBox(\"Arg\")}}\)) gives \(\"list\".StyleBox(\"Arg\")\) with the elements \(\"m\".StyleBox(\"Arg\")\) through \(\"n\".StyleBox(\"Arg\")\) in steps of \(\"s\".StyleBox(\"Arg\")\) dropped.\nDrop(\({\"list\".StyleBox(\"Arg\"), \",\", {\"seq\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"seq\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}\)) gives a nested list in which elements specified by \({\"seq\", SubscriptBox(\"i\")}.StyleBox(\"Arg\")\) have been dropped at level \(\"i\".StyleBox(\"Arg\")\) in \(\"list\".StyleBox(\"Arg\")\)."
Dynamic::usage:= "Dynamic(\(StyleBox(\"expr\", \"Arg\")\)) represents an object that displays the dynamically updated current value of \(StyleBox(\"expr\", \"Arg\")\).\nDynamic(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\)) continually evaluates \(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"val\", \"Arg\")\)) during interactive changing or edition of \(StyleBox(\"val\", \"Arg\")\)."
DynamicBox::usage:= "DynamicBox(\(StyleBox(\"expr\", \"Arg\")\)) is a low-level construct that represents content which updates dynamically in the front end."
DynamicLocal::usage:= "DynamicLocal({\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \[Ellipsis]}, \(StyleBox(\"expr\", \"Arg\")\)) represents an object that localizes the symbols \(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \[Ellipsis] in any evaluation of Dynamic objects in \(StyleBox(\"expr\", \"Arg\")\). Symbol definitions inside DynamicLocal are preserved across \(StyleBox(\"pMath\", \"TI\")\) sessions.\nDynamicLocal({\(StyleBox(\"x\", \"Arg\")\) \[Assign] \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"0\")\), \(StyleBox(\"y\", \"Arg\")\) \[Assign] \(StyleBox(\"y\", \"Arg\")\)\(SubscriptBox(\"0\")\), \[Ellipsis]}, \(StyleBox(\"expr\", \"Arg\")\)) defines initial values for \(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \[Ellipsis]."
DynamicLocalBox::usage:= "DynamicLocalBox(\[Ellipsis]) is a low-level construct which is used to implement the DynamicLocal functionality."
DynamicSetting::usage:= "DynamicSetting(\(StyleBox(\"expr\", \"Arg\")\)) displays as \(StyleBox(\"expr\", \"Arg\")\) but is interpreted as the dynamically updated current value of Setting(\(StyleBox(\"expr\", \"Arg\")\)) on input."
E::usage:= "E is the exponential constant \[ScriptE] (base of the natural logarithm) with numerical value \[TildeTilde] 2.71828."
Echo::usage:= "Echo(\(StyleBox(\"expr\", \"Arg\")\)) prints and returns \(StyleBox(\"expr\", \"Arg\")\).\nEcho(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"label\", \"Arg\")\)) prints \(StyleBox(\"expr\", \"Arg\")\) labelled with \(StyleBox(\"label\", \"Arg\")\) and returns \(StyleBox(\"expr\", \"Arg\")\).\nEcho(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"label\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\)) prints \({\"f\", \"(\", \"expr\", \")\"}\) and returns \(StyleBox(\"expr\", \"Arg\")\)."
EchoFunction::usage:= "EchoFunction(\(StyleBox(\"f\", \"Arg\")\))(\(StyleBox(\"expr\", \"Arg\")\)) prints \({\"f\", \"(\", \"expr\", \")\"}\) and returns \(StyleBox(\"expr\", \"Arg\")\).\nEchoFunction(\(StyleBox(\"label\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\)) prints \({\"f\", \"(\", \"expr\", \")\"}\) labelled with \(StyleBox(\"label\", \"Arg\")\) and returns \(StyleBox(\"expr\", \"Arg\")\)."
Editable::usage:= "Editable is an option for displayed objects which specifies whether their content can be edited interactively by the user."
Element::usage:= "Element(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\)) displays as \(StyleBox(\"a\", \"Arg\")\) \[Element] \(StyleBox(\"b\", \"Arg\")\)."
Emit::usage:= "Emit(\(StyleBox(\"e\", \"Arg\")\)) specifies that \(StyleBox(\"e\", \"Arg\")\) should be collected by the nearest enclosing Gather.\nEmit(\(StyleBox(\"e\", \"Arg\")\), \(StyleBox(\"tag\", \"Arg\")\)) specifies that \(StyleBox(\"e\", \"Arg\")\) should be collected by the nearest enclosing Gather whose pattern matches \(StyleBox(\"tag\", \"Arg\")\)."
End::usage:= "End() returns the current namespace and reverts to a previous one."
EndOfFile::usage:= "EndOfFile is returned by Read and related functions when it reaches the end of file."
EndOfLine::usage:= "EndOfLine represents the end of a line in a string in StringMatch and related function."
EndOfString::usage:= "EndOfString represents the end of a string in StringMatch and related function."
EndPackage::usage:= "EndPackage() restores $Namespace and $NamespacePath to their values before the preceding BeginPackage, and prepends the current namespace to the list $NamespacePath."
Environment::usage:= "Environment(\"\(StyleBox(\"var\", \"Arg\")\) \") gives the value of an operating system environment variable.\nEnvironment() gives a list of all operating system environment variables in the form \({\"{\", {{{\"key\", SubscriptBox(\"1\")}, \"\\[Rule]\", {\"value\", SubscriptBox(\"1\")}}, \",\", {{\"key\", SubscriptBox(\"2\")}, \"\\[Rule]\", {\"value\", SubscriptBox(\"2\")}}, \",\", \"\\[Ellipsis]\"}, \"}\"}\)"
Equal::usage:= "\(StyleBox(\"lhs\", \"Arg\")\) = \(StyleBox(\"rhs\", \"Arg\")\) returns True if \(StyleBox(\"lhs\", \"Arg\")\) and \(StyleBox(\"rhs\", \"Arg\")\) are equal."
Erf::usage:= "Erf(\(\"z\".StyleBox(\"Arg\")\)) gives the error function \({\"erf\", \"(\", StyleBox(\"z\", \"Arg\"), \")\"}\)."
Erfc::usage:= "Erfc(\(\"z\".StyleBox(\"Arg\")\)) gives the complementary error function \({\"erfc\", \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
Erfi::usage:= "Erfi(\(\"z\".StyleBox(\"Arg\")\)) gives the imaginary error function \({\"-\", {\"i\", \" \", {\"erf\", \"(\", {\"i\", \" \", \"z\".StyleBox(\"Arg\")}, \")\"}}}\)."
EulerGamma::usage:= "EulerGamma is Euler's constant \(\"\\[Gamma]\"\) with numerical value \[TildeTilde] 0.577216."
Evaluatable::usage:= "Evaluatable is an option for Section which specifies whether a section can be used as input to be evaluated by \(StyleBox(\"pMath\", \"TI\")\)."
Evaluate::usage:= "Evaluate(\(StyleBox(\"expr\", \"Arg\")\)) causes \(StyleBox(\"expr\", \"Arg\")\) to evaluate even if it occurs as the argument of a function whose attributes specify that it should be held unevaluated."
EvaluateDelayed::usage:= "EvaluateDelayed(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"t\", \"Arg\")\)) causes \(StyleBox(\"expr\", \"Arg\")\) to be evaluated in \(StyleBox(\"t\", \"Arg\")\) seconds."
EvaluationDocument::usage:= "EvaluationDocument() returns the document that triggered the current evaluation."
EvaluationSequence::usage:= "\(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"1\")\) ; \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"2\")\) ; \[Ellipsis] evaluates the \(StyleBox({\"expr\", SubscriptBox(\"i\")}, \"Arg\")\) in order and gives the last one as the result."
Except::usage:= "Except(\(StyleBox(\"c\", \"Arg\")\)) is a pattern which represents any expression except one that matches \(StyleBox(\"c\", \"Arg\")\).\nExcept(\(StyleBox(\"c\", \"Arg\")\), \(StyleBox(\"p\", \"Arg\")\)) represents any expression that matches \(StyleBox(\"p\", \"Arg\")\) but not \(StyleBox(\"c\", \"Arg\")\)."
Exp::usage:= "Exp(\(StyleBox(\"z\", \"Arg\")\)) is the exponential function."
ExpIntegralEi::usage:= "ExpIntegralEi(\(StyleBox(\"z\", \"Arg\")\)) gives the exponential integral function \({\"Ei\", \"(\", {StyleBox(\"z\", \"Arg\")}, \")\"}\)."
Expand::usage:= "Expand(\(StyleBox(\"expr\", \"Arg\")\)) expands out products and positive integer powers in \(StyleBox(\"expr\", \"Arg\")\)."
ExpandAll::usage:= "ExpandAll(\(StyleBox(\"expr\", \"Arg\")\)) expands out products and integer powers in any part of \(StyleBox(\"expr\", \"Arg\")\)."
Expression::usage:= "Expression is a symbol that represents \(StyleBox(\"pMath\", \"TI\")\) expressions in Read and related functions."
ExtendedGCD::usage:= "ExtendedGCD(\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) calculates the extended greatest common divisor of integers \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
Extract::usage:= "Extract(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"list\", \"Arg\")\)) extracts the part of \(StyleBox(\"expr\", \"Arg\")\) at the position specified by \(StyleBox(\"list\", \"Arg\")\).\nExtract(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"h\", \"Arg\")\)) wraps the extracted part with the head \(StyleBox(\"h\", \"Arg\")\)."
Factorial2::usage:= "\(StyleBox(\"n\", \"Arg\")\)!! gives the double factorial of \(StyleBox(\"n\", \"Arg\")\)."
Factorial::usage:= "\(StyleBox(\"n\", \"Arg\")\)! gives the factorial of \(StyleBox(\"n\", \"Arg\")\)."
False::usage:= "False is the symbol for the boolean value false."
File::usage:= "File represents an ordinary file as a result of FileType."
FileByteCount::usage:= "FileByteCount(\"\(StyleBox(\"file\", \"Arg\")\)\") gives the number of bytes in a file."
FileNames::usage:= "FileNames() lists all files in the current working directory.\nFileNames(\(StyleBox(\"form\", \"Arg\")\)) lists all files in the current directory whose names match the string pattern \(StyleBox(\"form\", \"Arg\")\).\nFileNames({\(StyleBox(\"form\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"form\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) lists files whose names match any of the \(StyleBox({\"form\", SubscriptBox(\"i\")}, \"Arg\")\).\nFileNames({\(StyleBox(\"dir\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"dir\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"forms\", \"Arg\")\)) lists files with names matching \(StyleBox(\"forms\", \"Arg\")\) in any of the \(StyleBox({\"dir\", SubscriptBox(\"i\")}, \"Arg\")\)."
FileType::usage:= "FileType(\"\(StyleBox(\"file\", \"Arg\")\)\") gives the type of a file: File, Directory, Special or None."
FillBox::usage:= "FillBox(\(StyleBox(\"content\", \"Arg\")\)) is a box that fills up the whole line by repeating \(StyleBox(\"content\", \"Arg\")\)."
FilterRules::usage:= "FilterRules(\(StyleBox(\"rules\", \"Arg\")\), \(StyleBox(\"pat\", \"Arg\")\)) filters the list \(StyleBox(\"rules\", \"Arg\")\) by selecting those rules whose left-hand sides match \(StyleBox(\"pat\", \"Arg\")\).\nFilterRules(\(StyleBox(\"rules\", \"Arg\")\), {\(StyleBox(\"pat\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"pat\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) selects rules with left-hand sides matching any of the \(StyleBox(\"pat\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nFilterRules(\(StyleBox(\"rules\", \"Arg\")\), \(StyleBox(\"patrules\", \"Arg\")\)) takes the left-hand sides of rules in \(StyleBox(\"patrules\", \"Arg\")\) as patterns for selection."
Finally::usage:= "Finally(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"end\", \"Arg\")\)) evaluates \(StyleBox(\"expr\", \"Arg\")\) and then \(StyleBox(\"end\", \"Arg\")\), even if an exception occurs during the evaluation of \(StyleBox(\"expr\", \"Arg\")\)."
Find::usage:= "Find(\(StyleBox(\"stream\", \"Arg\")\), \(StyleBox(\"form\", \"Arg\")\)) finds the first line in \(StyleBox(\"stream\", \"Arg\")\) that matches \(StyleBox(\"form\", \"Arg\")\)."
FindList::usage:= "FindList(\(StyleBox(\"file\", \"Arg\")\), \(StyleBox(\"form\", \"Arg\")\)) gives a list of all lines in \(StyleBox(\"file\", \"Arg\")\) that match \(StyleBox(\"form\", \"Arg\")\).\nFindList(\(StyleBox(\"file\", \"Arg\")\), \(StyleBox(\"form\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) returns the first \(StyleBox(\"n\", \"Arg\")\) occurrences."
First::usage:= "First(\(StyleBox(\"expr\", \"Arg\")\)) gives the first element in \(StyleBox(\"expr\", \"Arg\")\)."
FixedPoint::usage:= "FixedPoint(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) to \(StyleBox(\"expr\", \"Arg\")\) repeatedly until the result no longer changes, and returns that result.\nFixedPoint(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) does no more than \(StyleBox(\"n\", \"Arg\")\) steps."
FixedPointList::usage:= "FixedPointList(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) to \(StyleBox(\"expr\", \"Arg\")\) repeatedly until the result no longer changes, returning a list of all the results.\nFixedPointList(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) does no more than \(StyleBox(\"n\", \"Arg\")\) steps."
Flatten::usage:= "Flatten(\(StyleBox(\"list\", \"Arg\")\)) flattens out nested lists.\nFlatten(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) flattens to level \(StyleBox(\"n\", \"Arg\")\).\nFlatten(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"h\", \"Arg\")\)) flattens subexpressions with head \(StyleBox(\"h\", \"Arg\")\)."
Floor::usage:= "Floor(\(StyleBox(\"x\", \"Arg\")\)) gives the largest integer less than or equal to \(StyleBox(\"x\", \"Arg\")\).\nFloor(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"a\", \"Arg\")\)) gives the largest multiple of \(StyleBox(\"a\", \"Arg\")\) less than or equal to \(StyleBox(\"x\", \"Arg\")\)."
Fold::usage:= "Fold(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"x\", \"Arg\")\)) gives the last element of FoldList(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"x\", \"Arg\")\))."
FoldList::usage:= "FoldList({\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \[Ellipsis]}, \(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"x\", \"Arg\")\)) gives {\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"a\", \"Arg\")\)), \(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"a\", \"Arg\")\)), \(StyleBox(\"b\", \"Arg\")\)), \[Ellipsis]}."
FontColor::usage:= "FontColor is an option for Section, Style and related constructs which specifies the default color in which to render text."
FontFamily::usage:= "FontFamily is an option for Section, Style and related constructs which specifies the font family in which text should be rendered."
FontFeatures::usage:= "FontFeatures is an option for Section, Style and related constructs which specifies OpenType font features to apply to text."
FontSize::usage:= "FontSize is an option for Section, Style and related constructs which specifies the default font size in which to render text."
FontSlant::usage:= "FontSlant is an option for Section, Style and related constructs which specifies how slanted characters in text should be."
FontWeight::usage:= "FontWeight is an option for Style, Section and related constructs which specifies how heavy characters in a font should be."
For::usage:= "For(\(StyleBox(\"start\", \"Arg\")\), \(StyleBox(\"test\", \"Arg\")\), \(StyleBox(\"incr\", \"Arg\")\), \(StyleBox(\"body\", \"Arg\")\)) executes \(StyleBox(\"start\", \"Arg\")\), then repeatedly evaluates \(StyleBox(\"body\", \"Arg\")\) and \(StyleBox(\"incr\", \"Arg\")\) until \(StyleBox(\"test\", \"Arg\")\) fails to give True."
Format::usage:= "Format(\(StyleBox(\"expr\", \"Arg\")\)) defines print forms for expressions."
FormatRules::usage:= "FormatRules(\(StyleBox(\"f\", \"Arg\")\)) gives a list of formating rules for the symbol \(StyleBox(\"f\", \"Arg\")\) and expressions of the form \({StyleBox(\"f\", \"Arg\"), \"(\", \"\\[Ellipsis]\", \")\"}\)."
FractionalPart::usage:= "FractionalPart(\(StyleBox(\"x\", \"Arg\")\)) gives the fractional part of \(StyleBox(\"x\", \"Arg\")\)."
FractionBox::usage:= "FractionBox(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)) is a low-level construct that represents \(FractionBox(StyleBox(\"x\", \"Arg\"), StyleBox(\"y\", \"Arg\"))\) in document expressions."
Frame::usage:= "Frame is an option for Graphics that specifies whether to add a frame."
FrameBox::usage:= "FrameBox(\(StyleBox(\"boxes\", \"Arg\")\)) is a low-level construct which represents \(StyleBox(\"boxes\", \"Arg\")\) with a frame drawn around it in document expressions."
Framed::usage:= "Framed(\(StyleBox(\"expr\", \"Arg\")\)) displays as \(StyleBox(\"expr\", \"Arg\")\) inside a frame."
FrameTicks::usage:= "FrameTicks is an option for Graphics that specifies tick marks for the edges of a frame."
FresnelC::usage:= "FresnelC(\(\"z\".StyleBox(\"Arg\")\)) gives the Fresnel integral \({\"C\", \"(\", StyleBox(\"z\", \"Arg\"), \")\"}\)."
FresnelS::usage:= "FresnelS(\(\"z\".StyleBox(\"Arg\")\)) gives the Fresnel integral \({\"S\", \"(\", StyleBox(\"z\", \"Arg\"), \")\"}\)."
FromCharacterCode::usage:= "FromCharacterCode(\(StyleBox(\"n\", \"Arg\")\)) returns a string consisting the character whose integer code is \(StyleBox(\"n\", \"Arg\")\).\nFromCharacterCode({\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) returns a string of characters with integer codes \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nFromCharacterCode({{\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"11\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"12\")\), \[Ellipsis]}, {\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"21\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"22\")\), \[Ellipsis]}, \[Ellipsis]}) returns a list of strings.\nFromCharacterCode(\[Ellipsis], \"\(StyleBox(\"encoding\", \"Arg\")\)\") uses the specified encoding."
FrontEndObject::usage:= "FrontEndObject(\[Ellipsis]) represents any user interface object in \(StyleBox(\"pMath\", \"TI\")\) code."
FrontEndTokenExecute::usage:= "FrontEndTokenExecute(\"\(StyleBox(\"cmd\", \"Arg\")\) \") executes the specified front end command token, typically corresponding to a front end menu item."
FullForm::usage:= "FullForm(\(StyleBox(\"expr\", \"Arg\")\)) prints as the full form of \(StyleBox(\"expr\", \"Arg\")\), without any special syntax."
Function::usage:= "Function(\(StyleBox(\"body\", \"Arg\")\)) or \(StyleBox(\"body\", \"Arg\")\) & is a pure function. The formal parameters are # (or #1), #2, etc.\nFunction({\(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"body\", \"Arg\")\)) is a pure function with a list of named formal parameters.\nFunction(\(StyleBox(\"params\", \"Arg\")\), \(StyleBox(\"body\", \"Arg\")\), \(StyleBox(\"attr\", \"Arg\")\)) is a pure function with attributes \(StyleBox(\"attr\", \"Arg\")\)."
Gamma::usage:= "Gamma(\(StyleBox(\"z\", \"Arg\")\)) is the Euler gamma function \({\"\\[CapitalGamma]\", \"(\", StyleBox(\"z\", \"Arg\"), \")\"}\)."
Gather::usage:= "Gather(\(StyleBox(\"expr\", \"Arg\")\)) returns the value of \(StyleBox(\"expr\", \"Arg\")\) together with a list of all expressions to which Emit has been applied during its evaluation.\nGather(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"patt\", \"Arg\")\)) gathers only expressions emitted with tags that match \(StyleBox(\"patt\", \"Arg\")\)."
GCD::usage:= "GCD(\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) returns the greatest common divisor of the integers \(StyleBox({\"n\", SubscriptBox(\"i\")}, \"Arg\")\)."
General::usage:= "General is a symbol to which general system messages are attached."
GeneratedSectionStyles::usage:= "GeneratedSectionStyles is an option for Section which defines the actual style names of kernel generated sections."
Get::usage:= "\({\"<<\", StyleBox(\"name\", \"Arg\")}\) opens a file, evaluates each expression in it, and returns the last one. When \(StyleBox(\"name\", \"Arg\")\) is a namespace which has already been included, nothing happens."
GoldenRatio::usage:= "GoldenRatio is the golden ratio \({\"\\[Phi]\", \"=\", FractionBox({SqrtBox(\"5\"), \"+\", \"1\"}, \"2\")}\), which is \[TildeEqual] 1.618."
Goto::usage:= "Goto(\(StyleBox(\"tag\", \"Arg\")\)) searches Label(\(StyleBox(\"tag\", \"Arg\")\)) and transfers control to that point."
Graphics::usage:= "Graphics(\(StyleBox(\"primitives\", \"Arg\")\), \(StyleBox(\"options\", \"Arg\")\)) represents a graphical image."
GraphicsBox::usage:= "GraphicsBox(\[Ellipsis]) is a low-level construct that represents a graphical image."
Gray::usage:= "Gray represents the color gray in graphics and style specifications."
GrayLevel::usage:= "GrayLevel(\(StyleBox(\"level\", \"Arg\")\)) is a directive which specifies a gray-level intensity to use for graphics and text."
Greater::usage:= "\({\"x\", \">\", \"y\"}\) yields True if \(\"x\"\) is determined to be greater than \(\"y\"\).\n\({{\"x\", SubscriptBox(\"1\")}, \">\", {\"x\", SubscriptBox(\"2\")}, \">\", {\"x\", SubscriptBox(\"3\")}}\) yields True if the \({\"x\", SubscriptBox(\"i\")}\) form a strictly decreasing sequence."
GreaterEqual::usage:= "\({\"x\", \">=\", \"y\"}\) or \({\"x\", \"\\[GreaterEqual]\", \"y\"}\) yields True if \(\"x\"\) is determined to be greater than or equal to \(\"y\"\).\n\({{\"x\", SubscriptBox(\"1\")}, \"\\[GreaterEqual]\", {\"x\", SubscriptBox(\"2\")}, \"\\[GreaterEqual]\", {\"x\", SubscriptBox(\"3\")}}\) yields True if the \({\"x\", SubscriptBox(\"i\")}\) form a non-increasing sequence."
GreaterEqualLess::usage:= "GreaterEqualLess(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[GreaterEqualLess] \(StyleBox(\"y\", \"Arg\")\) \[GreaterEqualLess] \[Ellipsis]."
GreaterFullEqual::usage:= "GreaterFullEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[GreaterFullEqual] \(StyleBox(\"y\", \"Arg\")\) \[GreaterFullEqual] \[Ellipsis]."
GreaterGreater::usage:= "GreaterGreater(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[GreaterGreater] \(StyleBox(\"y\", \"Arg\")\) \[GreaterGreater] \[Ellipsis]."
GreaterLess::usage:= "GreaterLess(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[GreaterLess] \(StyleBox(\"y\", \"Arg\")\) \[GreaterLess] \[Ellipsis]."
GreaterTilde::usage:= "GreaterTilde(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[GreaterTilde] \(StyleBox(\"y\", \"Arg\")\) \[GreaterTilde] \[Ellipsis]."
Green::usage:= "Green represents the color green in graphics and style specifications."
Grid::usage:= "Grid({{\(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"11\")\), \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"12\")\), \[Ellipsis]}, {\(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"21\")\), \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"22\")\), \[Ellipsis]}, \[Ellipsis]}) is an object that formats with the \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(StyleBox(\"ij\", \"Arg\"))\) arranged in a two-dimensional grid."
GridBox::usage:= "GridBox({{\(StyleBox(\"box\", \"Arg\")\)\(SubscriptBox(\"11\")\), \(StyleBox(\"box\", \"Arg\")\)\(SubscriptBox(\"12\")\), \[Ellipsis]}, {\(StyleBox(\"box\", \"Arg\")\)\(SubscriptBox(\"21\")\), \(StyleBox(\"box\", \"Arg\")\)\(SubscriptBox(\"22\")\), \[Ellipsis]}, \[Ellipsis]}) is a low-level box construct that represents a two-dimensional grid of boxes in document expressions."
GridBoxColumnSpacing::usage:= "GridBoxColumnSpacing is an option for GridBox which specifies the spacing between adjacent columns in points."
GridBoxRowSpacing::usage:= "GridBoxRowSpacing is an option for GridBox which specifies the spacing between adjacent rows in points."
HankelH1::usage:= "HankelH1(\(\"n\".StyleBox(\"Arg\")\), \(\"z\".StyleBox(\"Arg\")\)) gives the Hankel function of the first kind \({{\"H\", SubsuperscriptBox(\"n\".StyleBox(\"Arg\"), {\"(\", \"1\", \")\"})}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
HankelH2::usage:= "HankelH2(\(\"n\".StyleBox(\"Arg\")\), \(\"z\".StyleBox(\"Arg\")\)) gives the Hankel function of the second kind \({{\"H\", SubsuperscriptBox(\"n\".StyleBox(\"Arg\"), {\"(\", \"2\", \")\"})}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
Hash::usage:= "Hash(\(StyleBox(\"expr\", \"Arg\")\)) gives a hash number for an expression. Hash numbers are a first clue whether two objects are identical."
Head::usage:= "Head(\(StyleBox(\"expr\", \"Arg\")\)) returns the head of \(StyleBox(\"expr\", \"Arg\")\)."
Heads::usage:= "Heads is an option for functions which use level specifications that specifies whether heads of expressions should be included."
HermiteH::usage:= "HermiteH(\(\"n\".StyleBox(\"Arg\")\), \(\"z\".StyleBox(\"Arg\")\)) gives the Hermite polynomial \({{\"H\", SubscriptBox(\"n\".StyleBox(\"Arg\"))}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
Hold::usage:= "Hold(\(StyleBox(\"expr\", \"Arg\")\)) maintains \(StyleBox(\"expr\", \"Arg\")\) in unevaluated form."
HoldAll::usage:= "HoldAll is an attribute which specifies that all arguments to a function are to be maintained in unevaluated form."
HoldAllComplete::usage:= "HoldAllComplete is an attribute which specifies that all arguments to a function are not to be modified or looked at in any way in the process of evaluation."
HoldComplete::usage:= "HoldComplete(\(StyleBox(\"expr\", \"Arg\")\)) shields \(StyleBox(\"expr\", \"Arg\")\) completely from the standard \(StyleBox(\"pMath\", \"TI\")\) evaluation process, even preventing uprules associated with \(StyleBox(\"expr\", \"Arg\")\) from being used."
HoldFirst::usage:= "HoldFirst is an attribute which specifies that the first argument to a function is to be maintained in unevaluated form."
HoldForm::usage:= "HoldForm(\(StyleBox(\"expr\", \"Arg\")\)) displays as the expression \(StyleBox(\"expr\", \"Arg\")\) , with \(StyleBox(\"expr\", \"Arg\")\) maintained in unevaluated form."
HoldPattern::usage:= "HoldPattern(\(StyleBox(\"expr\", \"Arg\")\)) is equivalent to \(StyleBox(\"expr\", \"Arg\")\) for pattern matching, but maintains \(StyleBox(\"expr\", \"Arg\")\) in unevaluated form."
HoldRest::usage:= "HoldRest is an attribute which specifies that all but the first argument to a function are to be maintained in unevaluated form."
Hue::usage:= "Hue(\(StyleBox(\"h\", \"Arg\")\)) represents a color with hue \(StyleBox({\"h\", \".\"}, \"Arg\")\)in graphics and style specifications.\nHue(\(StyleBox(\"h\", \"Arg\")\), \(StyleBox(\"s\", \"Arg\")\), \(StyleBox(\"v\", \"Arg\")\)) uses saturation \(StyleBox(\"s\", \"Arg\")\) and brightness value \(StyleBox(\"v\", \"Arg\")\)."
HumpDownHump::usage:= "HumpDownHump(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[HumpDownHump] \(StyleBox(\"y\", \"Arg\")\) \[HumpDownHump] \[Ellipsis]."
HumpEqual::usage:= "HumpEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[HumpEqual] \(StyleBox(\"y\", \"Arg\")\) \[HumpEqual] \[Ellipsis]."
Hypergeometric0F1::usage:= "Hypergeometric0F1(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"z\", \"Arg\")\)) gives the confluent hypergeometric function \({{SubscriptBox(\"0\"), \"F\", SubscriptBox(\"1\")}, \"(\", {\";\", StyleBox(\"a\", \"Arg\"), \";\", StyleBox(\"z\", \"Arg\")}, \")\"}\)."
Hypergeometric0F1Regularized::usage:= "Hypergeometric0F1Regularized(\(StyleBox(\"b\", \"Arg\")\), \(StyleBox(\"z\", \"Arg\")\)) gives the regularized confluent hypergeometric function \({{{SubscriptBox(\"0\"), \"F\", SubscriptBox(\"1\")}, \"(\", {\";\", StyleBox(\"a\", \"Arg\"), \";\", StyleBox(\"z\", \"Arg\")}, \")\"}, \"/\", {\"\\[CapitalGamma]\", \"(\", StyleBox(\"a\", \"Arg\"), \")\"}}\)."
Hypergeometric1F1::usage:= "Hypergeometric1F1(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \(StyleBox(\"z\", \"Arg\")\)) gives the Kummer confluent hypergeometric function \({{SubscriptBox(\"1\"), \"F\", SubscriptBox(\"1\")}, \"(\", {StyleBox(\"a\", \"Arg\"), \";\", StyleBox(\"b\", \"Arg\"), \";\", StyleBox(\"z\", \"Arg\")}, \")\"}\)."
Hypergeometric1F1Regularized::usage:= "Hypergeometric1F1Regularized(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \(StyleBox(\"z\", \"Arg\")\)) gives the regularized Kummer confluent hypergeometric function \({{{SubscriptBox(\"1\"), \"F\", SubscriptBox(\"1\")}, \"(\", {StyleBox(\"a\", \"Arg\"), \";\", StyleBox(\"b\", \"Arg\"), \";\", StyleBox(\"z\", \"Arg\")}, \")\"}, \"/\", {\"\\[CapitalGamma]\", \"(\", StyleBox(\"b\", \"Arg\"), \")\"}}\)."
Hypergeometric2F1::usage:= "Hypergeometric2F1(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \(StyleBox(\"c\", \"Arg\")\), \(StyleBox(\"z\", \"Arg\")\)) gives the hypergeometric function \({{SubscriptBox(\"2\"), \"F\", SubscriptBox(\"1\")}, \"(\", {StyleBox(\"a\", \"Arg\"), \",\", {StyleBox(\"b\", \"Arg\"), \";\", StyleBox(\"c\", \"Arg\"), \";\", StyleBox(\"z\", \"Arg\")}}, \")\"}\)."
Hypergeometric2F1Regularized::usage:= "Hypergeometric2F1Regularized(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \(StyleBox(\"c\", \"Arg\")\), \(StyleBox(\"z\", \"Arg\")\)) gives the regularized hypergeometric function \({{{SubscriptBox(\"2\"), \"F\", SubscriptBox(\"1\")}, \"(\", {StyleBox(\"a\", \"Arg\"), \",\", {StyleBox(\"b\", \"Arg\"), \";\", StyleBox(\"c\", \"Arg\"), \";\", StyleBox(\"z\", \"Arg\")}}, \")\"}, \"/\", {\"\\[CapitalGamma]\", \"(\", StyleBox(\"c\", \"Arg\"), \")\"}}\)."
HypergeometricPFQ::usage:= "HypergeometricPFQ({\(StyleBox(\"a\", \"Arg\")\)\(SubscriptBox(\"1\")\), \[Ellipsis], \(StyleBox(\"a\", \"Arg\")\)\(SubscriptBox(\"p\")\)}, {\(StyleBox(\"b\", \"Arg\")\)\(SubscriptBox(\"1\")\), \[Ellipsis], \(StyleBox(\"b\", \"Arg\")\)\(SubscriptBox(\"q\")\)}, \(StyleBox(\"z\", \"Arg\")\)) gives the generalized hypergeometric function \({{SubscriptBox(\"p\"), \"F\", SubscriptBox(\"q\")}, \"(\", {{StyleBox(\"a\", \"Arg\"), SubscriptBox(\"1\")}, \",\", \"\\[Ellipsis]\", \",\", {{StyleBox(\"a\", \"Arg\"), SubscriptBox(\"p\")}, \";\", {StyleBox(\"b\", \"Arg\"), SubscriptBox(\"1\")}}, \",\", \"\\[Ellipsis]\", \",\", {{StyleBox(\"b\", \"Arg\"), SubscriptBox(\"q\")}, \";\", StyleBox(\"z\", \"Arg\")}}, \")\"}\)."
HypergeometricPFQRegularized::usage:= "HypergeometricPFQRegularized({\(StyleBox(\"a\", \"Arg\")\)\(SubscriptBox(\"1\")\), \[Ellipsis], \(StyleBox(\"a\", \"Arg\")\)\(SubscriptBox(\"p\")\)}, {\(StyleBox(\"b\", \"Arg\")\)\(SubscriptBox(\"1\")\), \[Ellipsis], \(StyleBox(\"b\", \"Arg\")\)\(SubscriptBox(\"q\")\)}, \(StyleBox(\"z\", \"Arg\")\)) gives the regularized generalized hypergeometric function \({{{SubscriptBox(\"p\"), \"F\", SubscriptBox(\"q\")}, \"(\", {{StyleBox(\"a\", \"Arg\"), SubscriptBox(\"1\")}, \",\", \"\\[Ellipsis]\", \",\", {{StyleBox(\"a\", \"Arg\"), SubscriptBox(\"p\")}, \";\", {StyleBox(\"b\", \"Arg\"), SubscriptBox(\"1\")}}, \",\", \"\\[Ellipsis]\", \",\", {{StyleBox(\"b\", \"Arg\"), SubscriptBox(\"q\")}, \";\", StyleBox(\"z\", \"Arg\")}}, \")\"}, \"/\", {\"(\", {{\"\\[CapitalGamma]\", \"(\", {StyleBox(\"b\", \"Arg\"), SubscriptBox(\"1\")}, \")\"}, \"\\[Dot]\", \"\\[Ellipsis]\", \"\\[Dot]\", {\"\\[CapitalGamma]\", \"(\", {StyleBox(\"b\", \"Arg\"), SubscriptBox(\"q\")}, \")\"}}, \")\"}}\)."
I::usage:= "I represents the imaginary unit \(SqrtBox({\"-\", \"1\"})\)."
Identical::usage:= "\(StyleBox(\"lhs\", \"Arg\")\) === \(StyleBox(\"rhs\", \"Arg\")\) yields True if \(StyleBox(\"lhs\", \"Arg\")\) and \(StyleBox(\"rhs\", \"Arg\")\) are identical, and yields False otherwise."
Identity::usage:= "Identity(\(StyleBox(\"expr\", \"Arg\")\)) gives \(StyleBox(\"expr\", \"Arg\")\) (the identity operation)."
IdentityMatrix::usage:= "IdentityMatrix(\(StyleBox(\"n\", \"Arg\")\)) gives the \(StyleBox(\"n\", \"Arg\")\)\[Times]\(StyleBox(\"n\", \"Arg\")\) identity matrix."
If::usage:= "If(\(StyleBox(\"condition\", \"Arg\")\), \(StyleBox(\"t\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\)) gives \(StyleBox(\"t\", \"Arg\")\) if \(StyleBox(\"condition\", \"Arg\")\) evaluates to True and \(StyleBox(\"f\", \"Arg\")\) if it evaluates to False.\nIf(\(StyleBox(\"condition\", \"Arg\")\), \(StyleBox(\"t\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"u\", \"Arg\")\)) gives \(StyleBox(\"u\", \"Arg\")\) if \(StyleBox(\"condition\", \"Arg\")\) evaluates neither to True nor to False."
IgnoreCase::usage:= "IgnoreCase is an option for string manipulation and searching functions which specifies whether low- and upper-case letters should be treated as equivalent."
Im::usage:= "Im(\(StyleBox(\"z\", \"Arg\")\)) gives the imaginary part of the complex number \(StyleBox(\"z\", \"Arg\")\)."
ImageSize::usage:= "ImageSize is an option for graphics which specifies the size of an image."
Increment::usage:= "++\(StyleBox(\"x\", \"Arg\")\) increases the value of \(StyleBox(\"x\", \"Arg\")\) by 1 and returns the new value.\n\(StyleBox(\"x\", \"Arg\")\)+= \(StyleBox(\"dx\", \"Arg\")\) increases the value of \(StyleBox(\"x\", \"Arg\")\) by \(StyleBox(\"dx\", \"Arg\")\)."
Inequation::usage:= "Inequation represents a sequence of relational statements."
Infinity::usage:= "Infinity or \[Infinity] is a symbol that represents a positive infinite quantity."
Inherited::usage:= "Inherited is an option value for various box options which specifies that the actual value should be determined by the owner box."
Inner::usage:= "Inner(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"list\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"list\", \"Arg\")\)\(SubscriptBox(\"2\")\), \(StyleBox(\"g\", \"Arg\")\)) is a generalization of Dot in which \(StyleBox(\"f\", \"Arg\")\) play the role of multiplication and \(StyleBox(\"g\", \"Arg\")\) of addition. It effectively contracts the last index of the first tensor \(StyleBox(\"list\", \"Arg\")\)\(SubscriptBox(\"1\")\) with the first index of the second tensor \(StyleBox(\"list\", \"Arg\")\)\(SubscriptBox(\"2\")\).\nInner(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"list\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"list\", \"Arg\")\)\(SubscriptBox(\"2\")\), \(StyleBox(\"g\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) contracts index \(StyleBox(\"n\", \"Arg\")\) of the first tensor with the first index of the second tensor."
InputField::usage:= "InputField() represents a blank editable input field.\nInputField(\(StyleBox(\"x\", \"Arg\")\)) represents an input field with current setting \(StyleBox(\"x\", \"Arg\")\).\nInputField(Dynamic(\(StyleBox(\"x\", \"Arg\")\))) updates the value of \(StyleBox(\"x\", \"Arg\")\) when new content is entered.\nInputField(\(StyleBox(\"x\", \"Arg\")\), String) represents an input field for plain text.\nInputField(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"type\", \"Arg\")\)) represents an input field for a special type of content."
InputFieldBox::usage:= "InputFieldBox(\(StyleBox(\"expr\", \"Arg\")\)) is a low-level construct that represents an field where the user can enter text."
InputForm::usage:= "InputForm(\(StyleBox(\"expr\", \"Arg\")\)) displays as \(StyleBox(\"expr\", \"Arg\")\) in a form that is valid input for \(StyleBox(\"pMath\", \"Arg\")\)."
Integer::usage:= "Integer is the head used for integers."
IntegerPart::usage:= "IntegerPart(\(StyleBox(\"x\", \"Arg\")\)) gives the integer part of \(StyleBox(\"x\", \"Arg\")\)."
Interpretation::usage:= "Interpretation(\(StyleBox(\"e\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\)) represents an object that displays as \(StyleBox(\"e\", \"Arg\")\), but is interpreted as \(StyleBox(\"expr\", \"Arg\")\) when used as input."
InterpretationBox::usage:= "InterpretationBox(\(StyleBox(\"box\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\)) is a low-level box construct that displays as \(StyleBox(\"box\", \"Arg\")\) but is interpreted on input as \(StyleBox(\"expr\", \"Arg\")\)."
Interrupt::usage:= "Interrupt() interrupts the evaluation, asking the user how to proceed."
Intersection::usage:= "Intersection(\(StyleBox(\"list\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"list\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) gives a sorted list of elements common to all \(StyleBox(\"list\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
Interval::usage:= "Interval(\(StyleBox(\"min\", \"Arg\")\) .. \(StyleBox(\"max\", \"Arg\")\)) represents the range of values between \(StyleBox(\"min\", \"Arg\")\) and \(StyleBox(\"max\", \"Arg\")\).\nInterval(\(StyleBox(\"min\", \"Arg\")\)\(SubscriptBox(\"1\")\) .. \(StyleBox(\"max\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"min\", \"Arg\")\)\(SubscriptBox(\"2\")\) .. \(StyleBox(\"max\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) represents the union of the ranges \(StyleBox(\"min\", \"Arg\")\)\(SubscriptBox(\"1\")\) to \(StyleBox(\"max\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"min\", \"Arg\")\)\(SubscriptBox(\"2\")\) to \(StyleBox(\"max\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]."
IsArray::usage:= "IsArray(\(StyleBox(\"expr\", \"Arg\")\)) gives True if \(StyleBox(\"expr\", \"Arg\")\) is a rectangular array (a tensor) and False otherwise.\nIsArray(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"patt\", \"Arg\")\)) requires \(StyleBox(\"expr\", \"Arg\")\) to be a rectangular array with a depth that matches \(StyleBox(\"patt\", \"Arg\")\).\nIsArray(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"patt\", \"Arg\")\), \(StyleBox(\"test\", \"Arg\")\)) requires also that \(StyleBox(\"test\", \"Arg\")\) yields True when applied to each of the array elements in \(StyleBox(\"expr\", \"Arg\")\)."
IsAtom::usage:= "IsAtom(\(StyleBox(\"x\", \"Arg\")\)) yields True if \(StyleBox(\"x\", \"Arg\")\) is an atomic object, i.e. no expression, and False otherwise."
IsComplex::usage:= "IsComplex(\(StyleBox(\"x\", \"Arg\")\)) yields True if \(StyleBox(\"x\", \"Arg\")\) is a complex number and False if not."
IsEven::usage:= "IsEven(\(StyleBox(\"x\", \"Arg\")\)) yields True if \(StyleBox(\"x\", \"Arg\")\) is an even integer number and yields False otherwise."
IsExactNumber::usage:= "IsExactNumber(\(StyleBox(\"x\", \"Arg\")\)) yields True if \(StyleBox(\"x\", \"Arg\")\) is an exact real or complex number and False otherwise."
IsFloat::usage:= "IsFloat(\(StyleBox(\"x\", \"Arg\")\)) yields True if \(StyleBox(\"x\", \"Arg\")\) is a floating point number."
IsFreeOf::usage:= "IsFreeOf(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"form\", \"Arg\")\)) yields True if no subexpression in \(StyleBox(\"expr\", \"Arg\")\) matches \(StyleBox(\"form\", \"Arg\")\) and yields False otherwise.\nIsFreeOf(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"form\", \"Arg\")\), \(StyleBox(\"levelspec\", \"Arg\")\)) searches subexpressions in levels specified by \(StyleBox(\"levelspec\", \"Arg\")\)."
IsHeld::usage:= "IsHeld(\(StyleBox(\"f\", \"Arg\")\))(\(StyleBox(\"expr\", \"Arg\")\)) returns \(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"expr\", \"Arg\")\)) with \(StyleBox(\"expr\", \"Arg\")\) being unevaluated regardless of whether \(StyleBox(\"f\", \"Arg\")\) has attributes like HoldFirst."
IsImaginary::usage:= "IsImaginary(\(StyleBox(\"x\", \"Arg\")\)) yields True if \(StyleBox(\"x\", \"Arg\")\) is an imaginary number and False if not."
IsInexactNumber::usage:= "IsInexactNumber(\(StyleBox(\"x\", \"Arg\")\)) gives True if \(StyleBox(\"x\", \"Arg\")\) is an inexact real or complex number and False otherwise."
IsInteger::usage:= "IsInteger(\(StyleBox(\"x\", \"Arg\")\)) yields True if \(StyleBox(\"x\", \"Arg\")\) is an integer and False otherwise."
IsMachineNumber::usage:= "IsMachineNumber(\(StyleBox(\"x\", \"Arg\")\)) yields True if \(StyleBox(\"x\", \"Arg\")\) is a machine-precision real or complex number and yields False otherwise."
IsMatrix::usage:= "IsMatrix(\(StyleBox(\"expr\", \"Arg\")\)) gives True if \(StyleBox(\"expr\", \"Arg\")\) is a list of lists of the same length and False otherwise.\nIsMatrix(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"test\", \"Arg\")\)) also requires that \(StyleBox(\"test\", \"Arg\")\) yields True when applied to each of the matrix elements in \(StyleBox(\"expr\", \"Arg\")\)."
IsNegative::usage:= "IsNegative(\(StyleBox(\"x\", \"Arg\")\)) gives True if \(StyleBox(\"x\", \"Arg\")\) is a negative number."
IsNonNegative::usage:= "IsNonNegative(\(StyleBox(\"x\", \"Arg\")\)) gives True if \(StyleBox(\"x\", \"Arg\")\) is a non-negative number."
IsNonPositive::usage:= "IsNonPositive(\(StyleBox(\"x\", \"Arg\")\)) gives True if \(StyleBox(\"x\", \"Arg\")\) is a non-positive number."
IsNumber::usage:= "IsNumber(\(StyleBox(\"x\", \"Arg\")\)) yields True if \(StyleBox(\"x\", \"Arg\")\) is a real or complex number and yields False otherwise."
IsNumeric::usage:= "IsNumeric(\(StyleBox(\"x\", \"Arg\")\)) yields True if \(StyleBox(\"x\", \"Arg\")\) is a numeric quantity and False otherwise."
IsOdd::usage:= "IsOdd(\(StyleBox(\"x\", \"Arg\")\)) yields True if \(StyleBox(\"x\", \"Arg\")\) is an odd integer number and yields False otherwise."
IsOption::usage:= "IsOption(\(StyleBox(\"e\", \"Arg\")\)) returns True if \(StyleBox(\"e\", \"Arg\")\) is an option or list of options, and False otherwise."
IsOrdered::usage:= "IsOrdered(\(StyleBox(\"h\", \"Arg\")\)(\(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis])) gives True if the \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) are in canonical order and False otherwise."
IsPositive::usage:= "IsPositive(\(StyleBox(\"x\", \"Arg\")\)) gives True if \(StyleBox(\"x\", \"Arg\")\) is a positive number."
IsPrime::usage:= "IsPrime(\(StyleBox(\"n\", \"Arg\")\)) gives True if \(StyleBox(\"n\", \"Arg\")\) is determined to be a prime number and False otherwise."
IsQuotient::usage:= "IsQuotient(\(StyleBox(\"x\", \"Arg\")\)) yields True if \(StyleBox(\"x\", \"Arg\")\) is a non-integer quotient and False otherwise."
IsRational::usage:= "IsRational(\(StyleBox(\"x\", \"Arg\")\)) yields True if \(StyleBox(\"x\", \"Arg\")\) is a rational number and False otherwise."
IsReal::usage:= "IsReal(\(StyleBox(\"x\", \"Arg\")\)) yields True if \(StyleBox(\"x\", \"Arg\")\) is a real number and False if not."
IsString::usage:= "IsString(\(StyleBox(\"s\", \"Arg\")\)) yields True if \(StyleBox(\"s\", \"Arg\")\) is a string and False otherwise."
IsSymbol::usage:= "IsSymbol(\(StyleBox(\"s\", \"Arg\")\)) yields True if \(StyleBox(\"s\", \"Arg\")\) is a symbol and False otherwise."
IsValidArgumentCount::usage:= "IsValidArgumentCount(\(StyleBox(\"head\", \"Arg\")\), \(StyleBox(\"len\", \"Arg\")\), \(StyleBox(\"min\", \"Arg\")\), \(StyleBox(\"max\", \"Arg\")\)) checks whether the number \(StyleBox(\"len\", \"Arg\")\) of arguments of a function \(StyleBox(\"head\", \"Arg\")\) is between \(StyleBox(\"min\", \"Arg\")\) and \(StyleBox(\"max\", \"Arg\")\). If not, an appropriate message is generated."
IsVector::usage:= "IsVector(\(StyleBox(\"expr\", \"Arg\")\)) gives True if \(StyleBox(\"expr\", \"Arg\")\) is a list with all of its elements being non-lists, and gives False otherwise.\nIsVector(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"test\", \"Arg\")\)) also requires \(StyleBox(\"test\", \"Arg\")\) to yield True when applied to each element of \(StyleBox(\"expr\", \"Arg\")\)."
Italic::usage:= "Italic represents an italic font slant."
JacobiSymbol::usage:= "JacobiSymbol(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\)) returns the Jacobi symbol \({\"(\", FractionBox(\"a\", \"b\"), \")\"}\)."
Join::usage:= "Join(\(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) concatenates the lists, expressions or strings \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
KroneckerSymbol::usage:= "KroneckerSymbol(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\)) returns the Kronecker symbol \({\"(\", FractionBox(\"a\", \"b\"), \")\"}\)."
Label::usage:= "Label(\(StyleBox(\"tag\", \"Arg\")\)) represents a point in an evaluation sequence to which control can be transfered using Goto."
LanguageCategory::usage:= "LanguageCategory is an option for Section which specifies the section's content language category. For example \"NaturalLanguage\" or \"pMath\"."
Last::usage:= "Last(\(StyleBox(\"expr\", \"Arg\")\)) returns the last element in \(StyleBox(\"expr\", \"Arg\")\)."
LCM::usage:= "LCM(\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) returns the least common multiplier of the integers \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
LeafCount::usage:= "LeafCount(\(StyleBox(\"expr\", \"Arg\")\)) gives the total number of indivisible subexpressions in \(StyleBox(\"expr\", \"Arg\")\)."
LeftArrow::usage:= "LeftArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[LeftArrow]\", \"y\".StyleBox(\"Arg\"), \"\[LeftArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
LeftRightArrow::usage:= "LeftRightArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[LeftRightArrow]\", \"y\".StyleBox(\"Arg\"), \"\[LeftRightArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
LeftTriangle::usage:= "LeftTriangle(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[LeftTriangle] \(StyleBox(\"y\", \"Arg\")\) \[LeftTriangle] \[Ellipsis]."
LeftTriangleEqual::usage:= "LeftTriangleEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[LeftTriangleEqual] \(StyleBox(\"y\", \"Arg\")\) \[LeftTriangleEqual] \[Ellipsis]."
Length::usage:= "Length(\(StyleBox(\"expr\", \"Arg\")\)) gives the number of elements in the expression \(StyleBox(\"expr\", \"Arg\")\) or the number of characters if \(StyleBox(\"expr\", \"Arg\")\) is a string."
LengthWhile::usage:= "LengthWhile(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"crit\", \"Arg\")\)) gives the largest number \(StyleBox(\"n\", \"Arg\")\) such that for all elements \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis], \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(StyleBox(\"n\", \"Arg\"))\) of \(StyleBox(\"list\", \"Arg\")\)  the term \(StyleBox(\"crit\", \"Arg\")\)(\(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)) is True."
Less::usage:= "\({\"x\", \"<\", \"y\"}\) yields True if \(\"x\"\) is determined to be less than \(\"y\"\).\n\({{\"x\", SubscriptBox(\"1\")}, \"<\", {\"x\", SubscriptBox(\"2\")}, \"<\", \"\\[Ellipsis]\"}\) yields True if the \({\"x\", SubscriptBox(\"i\")}\) form a strictly increasing sequence."
LessEqual::usage:= "\({\"x\", \"<=\", \"y\"}\) or \({\"x\", \"\\[LessEqual]\", \"y\"}\) yields True if \(\"x\"\) is determined to be less than or equal to \(\"y\"\).\n\({{\"x\", SubscriptBox(\"1\")}, \"\\[LessEqual]\", {\"x\", SubscriptBox(\"2\")}, \"\\[LessEqual]\", \"\\[Ellipsis]\"}\) yields True if the \({\"x\", SubscriptBox(\"i\")}\) form a non-decreasing sequence."
LessEqualGreater::usage:= "LessEqualGreater(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[LessEqualGreater] \(StyleBox(\"y\", \"Arg\")\) \[LessEqualGreater] \[Ellipsis]."
LessFullEqual::usage:= "LessFullEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[LessFullEqual] \(StyleBox(\"y\", \"Arg\")\) \[LessFullEqual] \[Ellipsis]."
LessGreater::usage:= "LessGreater(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[LessGreater] \(StyleBox(\"y\", \"Arg\")\) \[LessGreater] \[Ellipsis]."
LessLess::usage:= "LessLess(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[LessLess] \(StyleBox(\"y\", \"Arg\")\) \[LessLess] \[Ellipsis]."
LessTilde::usage:= "LessTilde(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[LessTilde] \(StyleBox(\"y\", \"Arg\")\) \[LessTilde] \[Ellipsis]."
LetterCharacter::usage:= "LetterCharacter represents a letter character in StringExpression."
Level::usage:= "Level(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"levelspec\", \"Arg\")\)) gives a list of subexpressions of \(StyleBox(\"expr\", \"Arg\")\) on levels specified by \(StyleBox(\"levelspec\", \"Arg\")\).\nLevel(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"levelspec\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) to the sequence of subexpressions."
LightBlue::usage:= "LightBlue represents the color light blue in graphics and style specifications."
LightBrown::usage:= "LightBrown represents the color light brown in graphics and style specifications."
LightCyan::usage:= "LightCyan represents the color light cyan in graphics and style specifications."
LightGray::usage:= "LightGray represents the color light gray in graphics and style specifications."
LightGreen::usage:= "LightGreen represents the color light green in graphics and style specifications."
LightMagenta::usage:= "LightMagenta represents the color light magenta in graphics and style specifications."
LightOrange::usage:= "LightOrange represents the color light orange in graphics and style specifications."
LightPink::usage:= "LightPink represents the color light pink in graphics and style specifications."
LightPurple::usage:= "LightPurple represents the color light purple in graphics and style specifications."
LightRed::usage:= "LightRed represents the color light red in graphics and style specifications."
LightYellow::usage:= "LightYellow represents the color light yellow in graphics and style specifications."
Line::usage:= "Line({\(StyleBox(\"pt\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"pt\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) is a graphics primitive which represents a line through a sequence of points.\nLine({{\(StyleBox(\"pt\", \"Arg\")\)\(SubscriptBox(\"11\")\), \(StyleBox(\"pt\", \"Arg\")\)\(SubscriptBox(\"12\")\), \[Ellipsis]}, {\(StyleBox(\"pt\", \"Arg\")\)\(SubscriptBox(\"21\")\), \(StyleBox(\"pt\", \"Arg\")\)\(SubscriptBox(\"22\")\), \[Ellipsis]}, \[Ellipsis]}) represents a collection of lines."
LinearFractionalTransform::usage:= "LinearFractionalTransform(\(StyleBox(\"m\", \"Arg\")\)) returns a TransformationFunction that represents a linear fractional transformation defined by a homogeneous matrix \(StyleBox(\"m\", \"Arg\")\).\nLinearFractionalTransform({\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \(StyleBox(\"c\", \"Arg\")\), \(StyleBox(\"d\", \"Arg\")\)}) represents a linear fractional transformation which maps \(StyleBox(\"r\", \"Arg\")\) to \({{\"(\", {{\"a\", \"\\[Dot]\", \"r\"}, \"+\", \"b\"}, \")\"}, \"/\", {\"(\", {{\"c\", \"\\[Dot]\", \"r\"}, \"+\", \"d\"}, \")\"}}\)."
LinearSolve::usage:= "LinearSolve(\(StyleBox(\"m\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\)) gives a vector or matrix \(StyleBox(\"x\", \"Arg\")\) such that \({{\"m\", \"\\[Dot]\", \"x\"}, \"=\", \"b\"}\).\nLinearSolve(\(StyleBox(\"m\", \"Arg\")\)) returns a LinearSolveFunction object \(StyleBox(\"f\", \"Arg\")\) that can be used to solve multiple equations by applying \(StyleBox(\"x\", \"Arg\")\) \[Assign] \(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"b\", \"Arg\")\))."
LinearSolveFunction::usage:= "LinearSolveFunction(\[Ellipsis]) is returned by LinearSolve(\(StyleBox(\"m\", \"Arg\")\)) and can be applied to some vector or matrix \(StyleBox(\"b\", \"Arg\")\) to get the solution to \({{\"m\", \"\\[Dot]\", \"x\"}, \"=\", \"b\"}\)."
LineBox::usage:= "LineBox(\[Ellipsis]) is a low-level graphics primitive representing a line or collection of lines."
LineBreakWithin::usage:= "LineBreakWithin is an option for Section and Style which specifies whether automatic line breaks should occur when the right margin of the window or page is reached."
List::usage:= "{\(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]} is a list of elements."
Listable::usage:= "Listable is an attribute that can be assigned to a symbol \(StyleBox(\"f\", \"Arg\")\) to indicate that the function \(StyleBox(\"f\", \"Arg\")\) should automatically be threaded over lists that appear as its arguments."
ListConvolve::usage:= "ListConvolve(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"ker\", \"Arg\")\)) gives the convolution of the kernel \(StyleBox(\"ker\", \"Arg\")\) with list \(StyleBox(\"list\", \"Arg\")\).\nListConvolve(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"ker\", \"Arg\")\), \(StyleBox(\"k\", \"Arg\")\)) gives the cyclic convolution in which the \(StyleBox(\"k\", \"Arg\")\)\(SuperscriptBox(\"th\")\) element of \(StyleBox(\"ker\", \"Arg\")\) is aligned with each element in \(StyleBox(\"list\", \"Arg\")\).\nListConvolve(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"ker\", \"Arg\")\), {\(StyleBox({\"k\", SubscriptBox(\"L\")}, \"Arg\")\), \(StyleBox({\"k\", SubscriptBox(\"R\")}, \"Arg\")\)}) gives the cyclic convolution whose first element contains \({{StyleBox(\"ker\", \"Arg\"), \"[\", StyleBox({\"k\", SubscriptBox(\"L\")}, \"Arg\"), \"]\"}, \" \", {StyleBox(\"list\", \"Arg\"), \"[\", \"1\", \"]\"}}\) and whose last element contains \({{StyleBox(\"ker\", \"Arg\"), \"[\", StyleBox({\"k\", SubscriptBox(\"R\")}, \"Arg\"), \"]\"}, \" \", {StyleBox(\"list\", \"Arg\"), \"[\", {\"-\", \"1\"}, \"]\"}}\).\nListConvolve(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"ker\", \"Arg\")\), \(StyleBox(\"klist\", \"Arg\")\), \(StyleBox(\"p\", \"Arg\")\)) performs the convolution on \(StyleBox(\"list\", \"Arg\")\) padded with repetitions of \(StyleBox(\"p\", \"Arg\")\) at both ends.\nListConvolve(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"ker\", \"Arg\")\), \(StyleBox(\"klist\", \"Arg\")\), {\(StyleBox(\"p\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"p\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) padds with cyclic repetitions of the \(StyleBox(\"p\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nListConvolve(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"ker\", \"Arg\")\), \(StyleBox(\"klist\", \"Arg\")\), \(StyleBox(\"padding\", \"Arg\")\), \(StyleBox(\"g\", \"Arg\")\), \(StyleBox(\"h\", \"Arg\")\)) uses \(StyleBox(\"g\", \"Arg\")\) instead of Times and \(StyleBox(\"h\", \"Arg\")\) instead of Plus."
ListLinePlot::usage:= "ListLinePlot({\(StyleBox(\"y\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"y\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) plots a line through a list of values according to \(\"x\"\) coordinates 1, 2, \[Ellipsis].\nListLinePlot({{\(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"y\", \"Arg\")\)\(SubscriptBox(\"1\")\)}, {\(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"2\")\), \(StyleBox(\"y\", \"Arg\")\)\(SubscriptBox(\"2\")\)}, \[Ellipsis]}) plots a line through the given \(StyleBox(\"x\", \"Arg\")\) and \(StyleBox(\"y\", \"Arg\")\) positions.\nListLinePlot({\(StyleBox(\"list\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"list\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) plots multiple lines."
Literal::usage:= "Literal(\(StyleBox(\"expr\", \"Arg\")\)) represents \(StyleBox(\"expr\", \"Arg\")\) in pattern matching, requiring that is matched exactly as it appears, with no substitutions for SingleMatch() or other transformations."
LoadLibrary::usage:= "LoadLibrary(\"\(StyleBox(\"filename\", \"Arg\")\)\") loads a dynamic link library which adds functionality written in C to \(StyleBox(\"pMath\", \"TI\")\)."
Local::usage:= "Local({\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \[Ellipsis]}, \(StyleBox(\"expr\", \"Arg\")\)) specifies that occurrences of the symbols \(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \[Ellipsis] in expr should be treated as local.\nLocal({\(StyleBox(\"x\", \"Arg\")\) \[Assign] \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"0\")\), \(StyleBox(\"y\", \"Arg\")\) \[Assign] \(StyleBox(\"y\", \"Arg\")\)\(SubscriptBox(\"0\")\), \[Ellipsis]}, \(StyleBox(\"expr\", \"Arg\")\)) defines initial values for \(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \[Ellipsis]."
Log::usage:= "Log(\(StyleBox(\"x\", \"Arg\")\)) returns the natural logarithm of \(StyleBox(\"x\", \"Arg\")\).\nLog(\(StyleBox(\"b\", \"Arg\")\), \(StyleBox(\"x\", \"Arg\")\)) returns the logarithm to base \(StyleBox(\"b\", \"Arg\")\)."
LogGamma::usage:= "LogGamma(\(StyleBox(\"z\", \"Arg\")\)) gives the logarithm of the gamma function \({\"log\", \" \", {\"\\[CapitalGamma]\", \"(\", \"z\", \")\"}}\)."
LogIntegral::usage:= "LogIntegral(\(\"z\".StyleBox(\"Arg\")\)) gives the logarithmic integral function \({\"Li\", \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
Longest::usage:= "Longest(\(StyleBox(\"p\", \"Arg\")\)) is a pattern object which matches the longest sequence consistent with the pattern \(StyleBox(\"p\", \"Arg\")\)"
LongForm::usage:= "LongForm(\(StyleBox(\"expr\", \"Arg\")\)) displays as \(StyleBox(\"expr\", \"Arg\")\) with all symbols being shown along with their namespace."
LowerLeftArrow::usage:= "LowerLeftArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[LowerLeftArrow]\", \"y\".StyleBox(\"Arg\"), \"\[LowerLeftArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
LowerRightArrow::usage:= "LowerRightArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[LowerRightArrow]\", \"y\".StyleBox(\"Arg\"), \"\[LowerRightArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
LUDecomposition::usage:= "LUDecomposition(\(StyleBox(\"m\", \"Arg\")\)) generates a representation of the LU decomposition of a square matrix \(StyleBox(\"m\", \"Arg\")\)."
MachinePrecision::usage:= "MachinePrecision is a symbol used to indicate machine-number precision."
Magenta::usage:= "Magenta represents the color magenta in graphics and style specifications."
MakeBoxes::usage:= "MakeBoxes(\(StyleBox(\"expr\", \"Arg\")\)) is a low-level function used in \(StyleBox(\"pMath\", \"TI\")\) sessions to convert \(StyleBox(\"expr\", \"Arg\")\) to StandardForm boxes."
MakeExpression::usage:= "MakeExpression(\(StyleBox(\"boxes\", \"Arg\")\)) is an low-level function which parses \(StyleBox(\"pMath\", \"TI\")\) code represented in two-dimensional boxed form that does not contain any whitespace or comments."
Map::usage:= "Map(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\)) or \(StyleBox(\"f\", \"Arg\")\)/@ \(StyleBox(\"expr\", \"Arg\")\) applies \(StyleBox(\"f\", \"Arg\")\) to each element on the first level in \(StyleBox(\"expr\", \"Arg\")\).\nMap(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"levelspec\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) to parts of \(StyleBox(\"expr\", \"Arg\")\) specified by \(StyleBox(\"levelspec\", \"Arg\")\)."
MapIndexed::usage:= "MapIndexed(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) to each element on the first level in \(StyleBox(\"expr\", \"Arg\")\), using the element's part specification as a second argument to \(StyleBox(\"f\", \"Arg\")\).\nMapIndexed(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"levelspec\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) to parts of \(StyleBox(\"expr\", \"Arg\")\) specified by \(StyleBox(\"levelspec\", \"Arg\")\)."
MapThread::usage:= "MapThread({{\(StyleBox(\"a\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"a\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, {\(StyleBox(\"b\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"b\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \[Ellipsis]}, \(StyleBox(\"f\", \"Arg\")\)) gives {\(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"a\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"b\", \"Arg\")\)\(SubscriptBox(\"1\")\), \[Ellipsis]), \(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"a\", \"Arg\")\)\(SubscriptBox(\"2\")\), \(StyleBox(\"b\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]), \[Ellipsis]}.\nMapThread({\(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) to the parts of \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) at level \(StyleBox(\"n\", \"Arg\")\)."
Match::usage:= "Match(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"pattern\", \"Arg\")\)) yields True if \(StyleBox(\"expr\", \"Arg\")\) matches \(StyleBox({\"pattern\", \".\"}, \"Arg\")\)"
MatrixForm::usage:= "MatrixForm(\(StyleBox(\"list\", \"Arg\")\)) displays \(StyleBox(\"list\", \"Arg\")\) as a matrix or column vector."
Max::usage:= "Max(\(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) gives the numerically largest of the \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nMax({\(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, {\(StyleBox(\"y\", \"Arg\")\)\(SubscriptBox(\"1\")\), \[Ellipsis]}, \[Ellipsis]) gives the largest element in any of the lists."
MaxRecursion::usage:= "MaxRecursion is an option for Plot and related functions that specifies how many recursive subdivisions may be made."
Mean::usage:= "Mean(\(StyleBox(\"list\", \"Arg\")\)) gives the arithmetic mean of the elements in \(StyleBox(\"list\", \"Arg\")\)."
MemoryUsage::usage:= "MemoryUsage() returns a list of the currently used memory byte count and maximum used memory byte count so far."
Message::usage:= "Message(\(StyleBox(/\\/(\"symbol\", \"::\", \"tag\"), \"Arg\")\)) prints the message \(StyleBox(\"symbol\", \"Arg\")\)::\(StyleBox(\"tag\", \"Arg\")\) unless it has been switched off.\nMessage(\(StyleBox(/\\/(\"symbol\", \"::\", \"tag\"), \"Arg\")\), \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) prints the message, inserting the values of the \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) as needed."
MessageName::usage:= "\(StyleBox(/\\/(\"symbol\", \"::\", \"tag\"), \"Arg\")\) is a name for a message."
$MessageGroups::usage:= "$MessageGroups is the list of rules which gives named message groups used in functions like On or Try."
Messages::usage:= "Messages(\(StyleBox(\"symbol\", \"Arg\")\)) gives all the messages assigned to a particular symbol."
Method::usage:= "Method is an option for various algorithm-intensive functions that specifies what internal methods they should use."
Min::usage:= "Min(\(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) gives the numerically smallest of the \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nMin({\(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, {\(StyleBox(\"y\", \"Arg\")\)\(SubscriptBox(\"1\")\), \[Ellipsis]}, \[Ellipsis]) gives the smallest element in any of the lists."
MinMax::usage:= "MinMax(\(StyleBox(\"list\", \"Arg\")\) ) gives the list {Min(\(StyleBox(\"list\", \"Arg\")\) ), Max(\(StyleBox(\"list\", \"Arg\")\))}.\nMinMax(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"err\", \"Arg\")\)) gives {\({{\"Min\", \"(\", StyleBox(\"list\", \"Arg\"), \")\"}, \"-\", StyleBox(\"err\", \"Arg\")}\), \({{\"Max\", \"(\", StyleBox(\"list\", \"Arg\"), \")\"}, \"+\", StyleBox(\"err\", \"Arg\")}\) }.\nMinMax(\(StyleBox(\"list\", \"Arg\")\), {\(StyleBox(\"minerr\", \"Arg\")\), \(StyleBox(\"maxerr\", \"Arg\")\)}) gives {\({{\"Min\", \"(\", StyleBox(\"list\", \"Arg\"), \")\"}, \"-\", StyleBox(\"minerr\", \"Arg\")}\), \({{\"Max\", \"(\", StyleBox(\"list\", \"Arg\"), \")\"}, \"+\", StyleBox(\"maxerr\", \"Arg\")}\)}."
MinusPlus::usage:= "MinusPlus(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)) displays as \({\"x\", \"\\[MinusPlus]\", \"y\"}\).\nMinusPlus(\(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) displays as \({{{\"x\", SubscriptBox(\"1\")}, \"\\[MinusPlus]\", {\"x\", SubscriptBox(\"2\")}}, \"\\[MinusPlus]\", \"\\[Ellipsis]\"}\)."
Mod::usage:= "Mod(\(StyleBox(\"m\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) gives the remainder on division of \(StyleBox(\"m\", \"Arg\")\) by \(StyleBox(\"n\", \"Arg\")\).\nMod(\(StyleBox(\"m\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"d\", \"Arg\")\)) uses an offset \(StyleBox(\"d\", \"Arg\")\)."
Most::usage:= "Most(\(StyleBox(\"expr\", \"Arg\")\)) returns \(StyleBox(\"expr\", \"Arg\")\) with the last element removed."
N::usage:= "N(\(StyleBox(\"expr\", \"Arg\")\)) gives the numerical value of \(StyleBox(\"expr\", \"Arg\")\).\nN(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"p\", \"Arg\")\)) attempts to give a result with \(StyleBox(\"p\", \"Arg\")\)-digit precision."
Names::usage:= "Names(\"\(StyleBox(\"string\", \"Arg\")\)\") gives a list of the names of symbols which match the string.\nNames(\(StyleBox(\"form\", \"Arg\")\)) gives a list of names matching the arbitrary string pattern \(StyleBox(\"form\", \"Arg\")\)."
Namespace::usage:= "Namespace() returns the current namespace.\nNamespace(\(StyleBox(\"symbol\", \"Arg\")\)) returns the namespace in which a \(StyleBox(\"symbol\", \"Arg\")\) appears."
Nest::usage:= "Nest(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) returns the result of \(StyleBox(\"f\", \"Arg\")\) applied \(StyleBox(\"n\", \"Arg\")\) times to \(StyleBox(\"expr\", \"Arg\")\)."
NestList::usage:= "NestList(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) gives a list of results of applying \(StyleBox(\"f\", \"Arg\")\) to \(StyleBox(\"expr\", \"Arg\")\) 0 through \(StyleBox(\"n\", \"Arg\")\) times."
NestWhile::usage:= "NestWhile(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"test\", \"Arg\")\)) starts with \(StyleBox(\"expr\", \"Arg\")\), then repeatedly applies \(StyleBox(\"f\", \"Arg\")\) until applying \(StyleBox(\"test\", \"Arg\")\) no longer yields True.\nNestWhile(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"test\", \"Arg\")\), \(StyleBox(\"m\", \"Arg\")\)) supplies he most recent \(StyleBox(\"m\", \"Arg\")\) results as arguments for \(StyleBox(\"test\", \"Arg\")\) at each step.\nNestWhile(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"test\", \"Arg\")\), All) supplies all results so far as arguments for \(StyleBox(\"test\", \"Arg\")\) at each step.\nNestWhile(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"test\", \"Arg\")\), \(StyleBox(\"m\", \"Arg\")\), \(StyleBox(\"max\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) at most \(StyleBox(\"max\", \"Arg\")\) times.\nNestWhile(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"test\", \"Arg\")\), \(StyleBox(\"m\", \"Arg\")\), \(StyleBox(\"max\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) an extra \(StyleBox(\"n\", \"Arg\")\) times.\nNestWhile(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"test\", \"Arg\")\), \(StyleBox(\"m\", \"Arg\")\), \(StyleBox(\"max\", \"Arg\")\), \(StyleBox({\"-\", \" \", \"n\"}, \"Arg\")\)) returns the result found when \(StyleBox(\"f\", \"Arg\")\) had been applied \(StyleBox(\"n\", \"Arg\")\) fewer times."
NestWhileList::usage:= "NestWhileList(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"test\", \"Arg\")\)) generates a list of all intermediate results of NestWhile(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"test\", \"Arg\")\)). It takes exactly the same arguments."
NewTask::usage:= "NewTask(\(StyleBox(\"body\", \"Arg\")\)) starts a new asynchronous task for evaluating \(StyleBox(\"body\", \"Arg\")\). A task object is returned which can be used to wait for and get the evaluations result with Wait."
NextPrime::usage:= "NextPrime(\(StyleBox(\"n\", \"Arg\")\)) returns the first prime that is greater than \(StyleBox(\"n\", \"Arg\")\)."
NHoldAll::usage:= "NHoldAll is an attribute which specifies that none of the arguments to a function should be affected by N."
NHoldFirst::usage:= "NHoldFirst is an attribute which specifies that the first argument to a function should not be affected by N."
NHoldRest::usage:= "NHoldRest is an attribute which specifies that none but the first argument to a function should be affected by N."
None::usage:= "None is a setting for certain options."
Norm::usage:= "Norm(\(StyleBox(\"expr\", \"Arg\")\)) gives the euclidean norm of a number, vector or matrix.\nNorm(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"p\", \"Arg\")\)) gives the \(StyleBox(\"p\", \"Arg\")\)-norm"
Normalize::usage:= "Normalize(\(StyleBox(\"v\", \"Arg\")\)) returns the normalized form of a vector \(StyleBox(\"v\", \"Arg\")\).\nNormalize(\(StyleBox(\"z\", \"Arg\")\)) returns the normalized form of a complex number \(StyleBox(\"z\", \"Arg\")\).\nNormalize(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\)) normalizes with respect to a norm function \(StyleBox(\"f\", \"Arg\")\)."
Not::usage:= "!\(StyleBox(\"expr\", \"Arg\")\) is the logical NOT function. It gives True if \(StyleBox(\"expr\", \"Arg\")\) is False, and False if is True."
NotCongruent::usage:= "NotCongruent(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotCongruent] \(StyleBox(\"y\", \"Arg\")\) \[NotCongruent] \[Ellipsis]."
NotCupCap::usage:= "NotCupCap(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotCupCap] \(StyleBox(\"y\", \"Arg\")\) \[NotCupCap] \[Ellipsis]."
NotElement::usage:= "NotElement(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\)) displays as \(StyleBox(\"a\", \"Arg\")\) \[NotElement] \(StyleBox(\"b\", \"Arg\")\)."
NotGreater::usage:= "NotGreater(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotGreater] \(StyleBox(\"y\", \"Arg\")\) \[NotGreater] \[Ellipsis]."
NotGreaterEqual::usage:= "NotGreaterEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotGreaterEqual] \(StyleBox(\"y\", \"Arg\")\) \[NotGreaterEqual] \[Ellipsis]."
NotGreaterLess::usage:= "NotGreaterLess(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotGreaterLess] \(StyleBox(\"y\", \"Arg\")\) \[NotGreaterLess] \[Ellipsis]."
NotGreaterTilde::usage:= "NotGreaterTilde(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotGreaterTilde] \(StyleBox(\"y\", \"Arg\")\) \[NotGreaterTilde] \[Ellipsis]."
Nothing::usage:= "Nothing is an element of a list that will automatically be removed."
NotLeftTriangle::usage:= "NotLeftTriangle(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotLeftTriangle] \(StyleBox(\"y\", \"Arg\")\) \[NotLeftTriangle] \[Ellipsis]."
NotLeftTriangleEqual::usage:= "NotLeftTriangleEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotLeftTriangleEqual] \(StyleBox(\"y\", \"Arg\")\) \[NotLeftTriangleEqual] \[Ellipsis]."
NotLess::usage:= "NotLess(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotLess] \(StyleBox(\"y\", \"Arg\")\) \[NotLess] \[Ellipsis]."
NotLessEqual::usage:= "NotLessEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotLessEqual] \(StyleBox(\"y\", \"Arg\")\) \[NotLessEqual] \[Ellipsis]."
NotLessGreater::usage:= "NotLessGreater(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotLessGreater] \(StyleBox(\"y\", \"Arg\")\) \[NotLessGreater] \[Ellipsis]."
NotLessTilde::usage:= "NotLessTilde(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotLessTilde] \(StyleBox(\"y\", \"Arg\")\) \[NotLessTilde] \[Ellipsis]."
NotPrecedes::usage:= "NotPrecedes(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotPrecedes] \(StyleBox(\"y\", \"Arg\")\) \[NotPrecedes] \[Ellipsis]."
NotPrecedesEqual::usage:= "NotPrecedesEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotPrecedesEqual] \(StyleBox(\"y\", \"Arg\")\) \[NotPrecedesEqual] \[Ellipsis]."
NotReverseElement::usage:= "NotReverseElement(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\)) displays as \(StyleBox(\"a\", \"Arg\")\) \[NotReverseElement] \(StyleBox(\"b\", \"Arg\")\)."
NotRightTriangle::usage:= "NotRightTriangle(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotRightTriangle] \(StyleBox(\"y\", \"Arg\")\) \[NotRightTriangle] \[Ellipsis]."
NotRightTriangleEqual::usage:= "NotRightTriangleEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotRightTriangleEqual] \(StyleBox(\"y\", \"Arg\")\) \[NotRightTriangleEqual] \[Ellipsis]."
NotSubset::usage:= "NotSubset(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \[Ellipsis]) displays as \(StyleBox(\"a\", \"Arg\")\) \[NotSubset] \(StyleBox(\"b\", \"Arg\")\) \[NotSubset] \[Ellipsis]."
NotSubsetEqual::usage:= "NotSubsetEqual(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \[Ellipsis]) displays as \(StyleBox(\"a\", \"Arg\")\) \[NotSubsetEqual] \(StyleBox(\"b\", \"Arg\")\) \[NotSubsetEqual] \[Ellipsis]."
NotSucceeds::usage:= "NotSucceeds(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotSucceeds] \(StyleBox(\"y\", \"Arg\")\) \[NotSucceeds] \[Ellipsis]."
NotSucceedsEqual::usage:= "NotSucceedsEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotSucceedsEqual] \(StyleBox(\"y\", \"Arg\")\) \[NotSucceedsEqual] \[Ellipsis]."
NotSuperset::usage:= "NotSuperset(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \[Ellipsis]) displays as \(StyleBox(\"a\", \"Arg\")\) \[Superset] \(StyleBox(\"b\", \"Arg\")\) \[Superset] \[Ellipsis]."
NotSupersetEqual::usage:= "NotSupersetEqual(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \[Ellipsis]) displays as \(StyleBox(\"a\", \"Arg\")\) \[NotSupersetEqual] \(StyleBox(\"b\", \"Arg\")\) \[NotSupersetEqual] \[Ellipsis]."
NotTildeEqual::usage:= "NotTildeEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotTildeEqual] \(StyleBox(\"y\", \"Arg\")\) \[NotTildeEqual] \[Ellipsis]."
NotTildeFullEqual::usage:= "NotTildeFullEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotTildeFullEqual] \(StyleBox(\"y\", \"Arg\")\) \[NotTildeFullEqual] \[Ellipsis]."
NotTildeTilde::usage:= "NotTildeTilde(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[NotTildeTilde] \(StyleBox(\"y\", \"Arg\")\) \[NotTildeTilde] \[Ellipsis]."
NRules::usage:= "NRules(\(StyleBox(\"f\", \"Arg\")\)) gives a list of transformation rules corresponding to all numerical values (values for N(\(StyleBox(\"f\", \"Arg\")\)(x, \[Ellipsis]), \[Ellipsis]), etc.) defined for the symbol \(StyleBox(\"f\", \"Arg\")\)."
Number::usage:= "Number represents an exact integer or an approximate real number in Read, Find and related functions."
NumberSting::usage:= "NumberSting represents characters of a number in StringExpression."
NumericFunction::usage:= "NumericFunction is an attribute that can be assigned to a symbol \(StyleBox(\"f\", \"Arg\")\) to indicate that \(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"arg\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"arg\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) should be considered a numeric quantity whenever all the \(StyleBox(\"arg\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) are numeric quantities."
Off::usage:= "Off(\(StyleBox(/\\/(\"symbol\", \"::\", \"tag\"), \"Arg\")\)) switches off a message, so that is no longer printed.\nOff(\(StyleBox(\"s\", \"Arg\")\)) switches off tracing messages associated with the symbol \(StyleBox(\"s\", \"Arg\")\).\nOff(\(StyleBox(\"m\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"m\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) switches off several messages."
On::usage:= "On(\(StyleBox(/\\/(\"symbol\", \"::\", \"tag\"), \"Arg\")\)) switches on a message, so that can be printed.\nOn(\(StyleBox(\"s\", \"Arg\")\)) switches on tracing for the symbol \(StyleBox(\"s\", \"Arg\")\).\nOn(\(StyleBox(\"m\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"m\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) switches on tracing for several messages."
OneIdentity::usage:= "OneIdentity is an attribute that can be assigned to a symbol \(StyleBox(\"f\", \"Arg\")\) to indicate that \(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"x\", \"Arg\")\)), \(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"x\", \"Arg\")\))), etc. are all equivalent to \(StyleBox(\"x\", \"Arg\")\) for the purpose of pattern matching."
OpenAppend::usage:= "OpenAppend(\"\(StyleBox(\"file\", \"Arg\")\)\") opens a file to append output to it and returns a file stream object."
OpenRead::usage:= "OpenRead(\"\(StyleBox(\"file\", \"Arg\")\)\") opens a file to read data from, and returns a file stream object.\nOpenRead(\(StyleBox(\"stream\", \"Arg\")\)) reinterprets a readable binary stream object as a text stream, so e.g. OpenRead(\"\(StyleBox(\"file\", \"Arg\")\)\") is the same as OpenRead(OpenRead(\"\(StyleBox(\"file\", \"Arg\")\)\", BinaryFormat \[Rule] True))."
OpenWrite::usage:= "OpenWrite(\"\(StyleBox(\"file\", \"Arg\")\)\") opens a file to write data to, and returns a file stream object.\nOpenWrite(\(StyleBox(\"stream\", \"Arg\")\)) reinterprets a writable binary stream object as a text stream, so e.g. OpenWrite(\"\(StyleBox(\"file\", \"Arg\")\)\") is the same as OpenWrite(OpenWrite(\"\(StyleBox(\"file\", \"Arg\")\)\", BinaryFormat \[Rule] True))."
Operate::usage:= "Operate(\(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)), \(StyleBox(\"p\", \"Arg\")\)) gives \(StyleBox(\"p\", \"Arg\")\)(\(StyleBox(\"f\", \"Arg\")\))(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\))\nOperate(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"p\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) applies \(StyleBox(\"p\", \"Arg\")\) at level \(StyleBox(\"n\", \"Arg\")\) in the head of \(StyleBox(\"expr\", \"Arg\")\)."
Optional::usage:= "?\(StyleBox(\"x\", \"Arg\")\):\(StyleBox(\"v\", \"Arg\")\) is a pattern object with the name \(StyleBox(\"x\", \"Arg\")\) that matches any expression or can be omitted, in which case \(StyleBox(\"x\", \"Arg\")\) takes the value \(StyleBox(\"v\", \"Arg\")\).\n?\(StyleBox(\"x\", \"Arg\")\) takes an appropriate default value from Default definitions for the enclosing expressions head."
Options::usage:= "Options(\(StyleBox(\"symbol\", \"Arg\")\)) returns the list of default options assigned to a symbol.\nOptions(\(StyleBox(\"expr\", \"Arg\")\)) returns the options explicitly specified in a particular expression.\nOptions(\(StyleBox(\"object\", \"Arg\")\)) returns options associated with a special object such as file streams or document objects\nOptions(\(StyleBox(\"obj\", \"Arg\")\), \(StyleBox(\"name\", \"Arg\")\)) returns the settings for the option \(StyleBox(\"name\", \"Arg\")\).\nOptions(\(StyleBox(\"obj\", \"Arg\")\), {\(StyleBox(\"name\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"name\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) returns a list of settings for the options \(StyleBox(\"name\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
OptionsPattern::usage:= "OptionsPattern() is a pattern object that represents a collection of options given as rules, where the values of the options can be accessed using OptionValue.\nOptionsPattern(\(StyleBox(\"f\", \"Arg\")\)) takes default option values from Options(\(StyleBox(\"f\", \"Arg\")\))."
OptionValue::usage:= "OptionValue(\(StyleBox(\"name\", \"Arg\")\)) returns the value of \(StyleBox(\"name\", \"Arg\")\) in options matched by OptionsPattern.\nOptionValue(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"name\", \"Arg\")\)) returns the value of \(StyleBox(\"name\", \"Arg\")\) in options associated with head \(StyleBox(\"f\", \"Arg\")\).\nOptionValue(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"opts\", \"Arg\")\), \(StyleBox(\"name\", \"Arg\")\)) extracts option values from the explicit list of rules \(StyleBox(\"opts\", \"Arg\")\)."
Or::usage:= "\(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"1\")\) || \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"2\")\) || \[Ellipsis] is the logical OR function. It evaluates its arguments in order, giving True immediately if any of them is True, and False if all of them are False."
Orange::usage:= "Orange represents the color orange in graphics and style specifications."
Ordering::usage:= "Ordering(\(StyleBox(\"list\", \"Arg\")\)) gives indices in \(StyleBox(\"list\", \"Arg\")\)  at which each element appears after Sort(\(StyleBox(\"list\", \"Arg\")\)). So \(StyleBox(\"list\", \"Arg\")\)[Ordering(\(StyleBox(\"list\", \"Arg\")\))] gives Sort(\(StyleBox(\"list\", \"Arg\")\)).\nOrdering(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) gives only the first \(StyleBox(\"n\", \"Arg\")\) elements.\nOrdering(\(StyleBox(\"list\", \"Arg\")\), -\(StyleBox(\"n\", \"Arg\")\)) gives only the last \(StyleBox(\"n\", \"Arg\")\) elements.\nOrdering(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"p\", \"Arg\")\)) uses Sort(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"p\", \"Arg\")\))."
OutputForm::usage:= "OutputForm(\(StyleBox(\"expr\", \"Arg\")\)) displays \(StyleBox(\"expr\", \"Arg\")\) with only boxes that can be displayed using keyboard characters."
Overflow::usage:= "Overflow() represents a number too large to be represented explicitly on your computer system."
Overlaps::usage:= "Overlaps is an option for StringCases and StringPosition that specifies how to treat overlapping substrings."
Overscript::usage:= "Overscript(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)) displays as \(OverscriptBox(StyleBox(\"x\", \"Arg\"), StyleBox(\"y\", \"Arg\"))\)."
OverscriptBox::usage:= "OverscriptBox(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)) is the low-level box representation for \(OverscriptBox(StyleBox(\"x\", \"Arg\"), StyleBox(\"y\", \"Arg\"))\) in document expressions."
OwnRules::usage:= "OwnRules(\(StyleBox(\"x\", \"Arg\")\)) gives the rules corresponding to any ownvalue for the symbol \(StyleBox(\"x\", \"Arg\")\)."
PadLeft::usage:= "PadLeft(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) creates a list of length \(StyleBox(\"n\", \"Arg\")\) by padding \(StyleBox(\"list\", \"Arg\")\) with zeros on the left.\nPadLeft(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"x\", \"Arg\")\)) uses \(StyleBox(\"x\", \"Arg\")\) instead of zero for the padding.\nPadLeft(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), {\(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) pads by cyclically repeating the \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nPadLeft(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"padding\", \"Arg\")\), \(StyleBox(\"m\", \"Arg\")\)) leaves a margin of \(StyleBox(\"m\", \"Arg\")\) elements of padding on the right.\nPadLeft(\(StyleBox(\"list\", \"Arg\")\), {\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) creates a nested list with length \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) at level \(StyleBox(\"i\", \"Arg\")\).\nPadLeft(\(StyleBox(\"list\", \"Arg\")\)) pads sublists in \(StyleBox(\"list\", \"Arg\")\) with zeros on their left as needed to make \(StyleBox(\"list\", \"Arg\")\) rectangular."
PadRight::usage:= "PadRight(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) creates a list of length \(StyleBox(\"n\", \"Arg\")\) by padding \(StyleBox(\"list\", \"Arg\")\) with zeros on the right.\nPadRight(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"x\", \"Arg\")\)) uses \(StyleBox(\"x\", \"Arg\")\) instead of zero for the padding.\nPadRight(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), {\(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) pads by cyclically repeating the \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nPadRight(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"padding\", \"Arg\")\), \(StyleBox(\"m\", \"Arg\")\)) leaves a margin of \(StyleBox(\"m\", \"Arg\")\) elements of padding on the left.\nPadRight(\(StyleBox(\"list\", \"Arg\")\), {\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) creates a nested list with length \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) at level \(StyleBox(\"i\", \"Arg\")\).\nPadRight(\(StyleBox(\"list\", \"Arg\")\)) pads sublists in \(StyleBox(\"list\", \"Arg\")\) with zeros on their right as needed to make \(StyleBox(\"list\", \"Arg\")\) rectangular."
PageWidth::usage:= "PageWidth is an option for OpenAppend and OpenWrite that specifies the maximum line length of the stream for output with Write."
ParallelMap::usage:= "ParallelMap(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) in parallel to each element on the first level in \(StyleBox(\"expr\", \"Arg\")\).\nParallelMap(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"levelspec\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) in parallel to parts of \(StyleBox(\"expr\", \"Arg\")\) specified by \(StyleBox(\"levelspec\", \"Arg\")\)."
ParallelMapIndexed::usage:= "ParallelMapIndexed(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) in parallel to each element on the first level in \(StyleBox(\"expr\", \"Arg\")\), using the element's part specification as a second argument to \(StyleBox(\"f\", \"Arg\")\).\nParallelMapIndexed(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"levelspec\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) to parts of \(StyleBox(\"expr\", \"Arg\")\) specified by \(StyleBox(\"levelspec\", \"Arg\")\)."
ParallelScan::usage:= "ParallelScan(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\)) evaluates in parallel \(StyleBox(\"f\", \"Arg\")\) applied to each element of \(StyleBox(\"expr\", \"Arg\")\).\nParallelScan(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"levelspec\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) in parallel to parts of \(StyleBox(\"expr\", \"Arg\")\) specified by \(StyleBox(\"levelspec\", \"Arg\")\)."
ParallelTry::usage:= "ParallelTry({\(StyleBox(\"arg\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"arg\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"f\", \"Arg\")\)) evaluates \(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"arg\", \"Arg\")\)\(SubscriptBox(\"i\")\)) in parallel, returning the first result received.\nParallelTry({\(StyleBox(\"arg\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"arg\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"k\", \"Arg\")\)) returns a list of the first \(StyleBox(\"k\", \"Arg\")\) results."
ParentDirectory::usage:= "ParentDirectory() returns the name of the current directory's parent directory.\nParentDirectory(\"\(StyleBox(\"dir\", \"Arg\")\)\") gives the parent directory of \(StyleBox(\"dir\", \"Arg\")\)."
ParenthesizeBoxes::usage:= "ParenthesizeBoxes(\(StyleBox(\"boxes\", \"Arg\")\), \(StyleBox(\"prec\", \"Arg\")\), \(StyleBox(\"group\", \"Arg\")\)) is a low-level function, that surrounds \(StyleBox(\"boxes\", \"Arg\")\) with parenthesis if the requested operator precedence \(StyleBox(\"prec\", \"Arg\")\) and operator group \(StyleBox(\"group\", \"Arg\")\) demand that."
ParserArguments::usage:= "ParserArguments is an option for ToExpression which specifies addition arguments {\(StyleBox(\"arg\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"arg\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]} to replace `\(StyleBox(\"i\", \"Arg\")\)` in the code with \(StyleBox(\"arg\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
ParseSymbols::usage:= "ParseSymbols is an option for ToExpression which specifies whether new symbols may be generated during parsing."
Part::usage:= "\(StyleBox(\"expr\", \"Arg\")\)[\(StyleBox(\"i\", \"Arg\")\)] or Part(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\)) gives the \(StyleBox(\"i\", \"Arg\")\)\(SuperscriptBox(\"th\")\) part of \(StyleBox(\"expr\", \"Arg\")\).\n\(StyleBox(\"expr\", \"Arg\")\)[-\(StyleBox(\"i\", \"Arg\")\)] counts from the end.\n\(StyleBox(\"expr\", \"Arg\")\)[\(StyleBox(\"i\", \"Arg\")\), \(StyleBox(\"j\", \"Arg\")\), \[Ellipsis]] or Part(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\), \(StyleBox(\"j\", \"Arg\")\), \[Ellipsis]) is equivalent to \(StyleBox(\"expr\", \"Arg\")\)[\(StyleBox(\"i\", \"Arg\")\)][\(StyleBox(\"j\", \"Arg\")\)]\[Ellipsis].\n\(StyleBox(\"expr\", \"Arg\")\)[{\(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}] gives a list of the parts \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis] of \(StyleBox(\"expr\", \"Arg\")\).\n\(StyleBox(\"expr\", \"Arg\")\)[\(StyleBox(\"m\", \"Arg\")\) .. \(StyleBox(\"n\", \"Arg\")\)] gives parts \(StyleBox(\"m\", \"Arg\")\) through \(StyleBox(\"n\", \"Arg\")\).\n\(StyleBox(\"expr\", \"Arg\")\)[\(StyleBox(\"m\", \"Arg\")\) .. \(StyleBox(\"n\", \"Arg\")\) .. \(StyleBox(\"s\", \"Arg\")\)] gives parts \(StyleBox(\"m\", \"Arg\")\) through \(StyleBox(\"n\", \"Arg\")\) in steps of \(StyleBox(\"s\", \"Arg\")\)."
Partition::usage:= "Partition(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) partitions \(StyleBox(\"list\", \"Arg\")\) into non-overlapping sublists of length \(StyleBox(\"n\", \"Arg\")\).\nPartition(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"d\", \"Arg\")\)) generates sublists with offset \(StyleBox(\"d\", \"Arg\")\).\nPartition(\(StyleBox(\"list\", \"Arg\")\), {\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) partitions a nested list into blocks of size \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\) \[Times] \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\) \[Times] \[Ellipsis].\nPartition(\(StyleBox(\"list\", \"Arg\")\), {\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, {\(StyleBox(\"d\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"d\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) uses offset \(StyleBox(\"d\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) at level \(StyleBox(\"i\", \"Arg\")\) in \(StyleBox(\"list\", \"Arg\")\).\nPartition(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"d\", \"Arg\")\), {\(StyleBox(\"k\", \"Arg\")\)\(SubscriptBox(StyleBox(\"L\", \"Arg\"))\), \(StyleBox(\"k\", \"Arg\")\)\(SubscriptBox(StyleBox(\"R\", \"Arg\"))\)}) specifies that the first element of \(StyleBox(\"list\", \"Arg\")\) should appear at position \(StyleBox(\"k\", \"Arg\")\)\(SubscriptBox(StyleBox(\"L\", \"Arg\"))\) in the first sublist, and the last element of \(StyleBox(\"list\", \"Arg\")\) should appear at or after position \(StyleBox(\"k\", \"Arg\")\)\(SubscriptBox(StyleBox(\"R\", \"Arg\"))\) in the last sublist. If additional elements are needed, Partition fills them in by treating \(StyleBox(\"list\", \"Arg\")\) as cyclic.\nPartition(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"d\", \"Arg\")\), {\(StyleBox(\"k\", \"Arg\")\)\(SubscriptBox(StyleBox(\"L\", \"Arg\"))\), \(StyleBox(\"k\", \"Arg\")\)\(SubscriptBox(StyleBox(\"R\", \"Arg\"))\)}, \(StyleBox(\"x\", \"Arg\")\)) pads if necessary by repeating the element \(StyleBox(\"x\", \"Arg\")\).\nPartition(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"d\", \"Arg\")\), {\(StyleBox(\"k\", \"Arg\")\)\(SubscriptBox(StyleBox(\"L\", \"Arg\"))\), \(StyleBox(\"k\", \"Arg\")\)\(SubscriptBox(StyleBox(\"R\", \"Arg\"))\)}, {\(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) pads if necessary by cyclically repeating the elements \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nPartition(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"d\", \"Arg\")\), {\(StyleBox(\"k\", \"Arg\")\)\(SubscriptBox(StyleBox(\"L\", \"Arg\"))\), \(StyleBox(\"k\", \"Arg\")\)\(SubscriptBox(StyleBox(\"R\", \"Arg\"))\)}, {}) uses no padding, and so can yield sublists of different lengths.\nPartition(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"nlist\", \"Arg\")\), \(StyleBox(\"dlist\", \"Arg\")\), {\(StyleBox(\"klist\", \"Arg\")\)\(SubscriptBox(StyleBox(\"L\", \"Arg\"))\), \(StyleBox(\"klist\", \"Arg\")\)\(SubscriptBox(StyleBox(\"R\", \"Arg\"))\)}, \(StyleBox(\"padlist\", \"Arg\")\)) specifies alignments and padding in a nested list."
Path::usage:= "Path is an option for Get and related functions which specifies a list of directories to search in to find a file."
Pattern::usage:= "\(StyleBox(\"s\", \"Arg\")\):\(StyleBox(\"pat\", \"Arg\")\) represents the pattern object \(StyleBox(\"pat\", \"Arg\")\), assigned the name \(StyleBox(\"s\", \"Arg\")\)."
PatternSequence::usage:= "PatternSequence(\(StyleBox(\"p\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"p\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) is a pattern object which represents a sequence of arguments matching \(StyleBox(\"p\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"p\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]."
Pause::usage:= "Pause(\(StyleBox(\"n\", \"Arg\")\)) pauses for at least \(StyleBox(\"n\", \"Arg\")\) seconds."
Pi::usage:= "Pi is Archimedes' Constant \[Pi] with numerical value \[TildeTilde] 3.14159."
Piecewise::usage:= "Piecewise({{\(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"cond\", \"Arg\")\)\(SubscriptBox(\"1\")\)}, {\(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"2\")\), \(StyleBox(\"cond\", \"Arg\")\)\(SubscriptBox(\"2\")\)}, \[Ellipsis]}) represents a piecewise function with values \(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) in the regions defined by the conditions \(StyleBox(\"cond\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nPiecewise({{\(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"cond\", \"Arg\")\)\(SubscriptBox(\"1\")\)}, \[Ellipsis]}, \(StyleBox(\"val\", \"Arg\")\)) uses default value \(StyleBox(\"val\", \"Arg\")\) if none of the \(StyleBox(\"cond\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) apply.The default for \(StyleBox(\"val\", \"Arg\")\) is the symbol Undefined."
Pink::usage:= "Pink represents the color pink in graphics and style specifications."
Placeholder::usage:= "Placeholder() displays as \[Placeholder], a TAB-reachable placeholder.\nPlaceholder(\(StyleBox(\"expr\", \"Arg\")\)) displays as \(TagBox(FrameBox(StyleBox(\"expr\", \"Arg\")), \"Placeholder\")\)."
Plain::usage:= "Plain represents a font that is neither bold nor italic."
Plot::usage:= "Plot(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"x\", \"Arg\")\) \[Rule] \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) generates a plot of \(StyleBox(\"f\", \"Arg\")\) as a function of \(StyleBox(\"x\", \"Arg\")\) from \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) to \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\).\nPlot({\(StyleBox(\"f\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"f\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"x\", \"Arg\")\) \[Rule] \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) plots several functions \(StyleBox(\"f\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
PlotPoints::usage:= "PlotStyle is an option for plotting and related functions which specifies how many initial sample points to use."
PlotRange::usage:= "PlotRange is an option for graphics functions which specifies the range of coordinates to include in a plot."
PlotStyle::usage:= "PlotStyle is an option for plotting and related functions which controls styles for the objects to be drawn."
Plus::usage:= "\(StyleBox(\"x\", \"Arg\")\) + \(StyleBox(\"y\", \"Arg\")\) + \(StyleBox(\"z\", \"Arg\")\) is a sum of terms."
PlusMinus::usage:= "PlusMinus(\(StyleBox(\"x\", \"Arg\")\)) displays as \[PlusMinus]\(StyleBox(\"x\", \"Arg\")\).\nPlusMinus(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \[Ellipsis]) displays as \(StyleBox(\"x\", \"Arg\")\) \[PlusMinus] \(StyleBox(\"y\", \"Arg\")\) \[PlusMinus] \[Ellipsis]."
Point::usage:= "Point(\(StyleBox(\"coords\", \"Arg\")\)) is a graphics primitive which represents a point.\nPoint({\(StyleBox(\"coords\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"coords\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) represents a collection of points."
PointBox::usage:= "PointBox(\[Ellipsis]) is a low-level graphics primitive representing a point or collection of points."
PolyGamma::usage:= "PolyGamma(\(StyleBox(\"z\", \"Arg\")\)) is the digamma function \(\"\\[Psi]\"\)(\(StyleBox(\"z\", \"Arg\")\)).\nPolyGamma(\(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"z\", \"Arg\")\)) is the \(StyleBox(\"n\", \"Arg\")\)\(SuperscriptBox(\"th\")\) derivative of the digamma function \({\"\\[Psi]\", SuperscriptBox({\"(\", StyleBox(\"n\", \"Arg\"), \")\"})}\)(\(StyleBox(\"z\", \"Arg\")\))."
Position::usage:= "Position(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"pattern\", \"Arg\")\)) returns a list of the positions at which objects matching \(StyleBox(\"pattern\", \"Arg\")\) appear in \(StyleBox(\"expr\", \"Arg\")\).\nPosition(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"pattern\", \"Arg\")\), \(StyleBox(\"levelspec\", \"Arg\")\)) gives only objects that appear on levels specified by \(StyleBox(\"levelspec\", \"Arg\")\).\nPosition(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"pattern\", \"Arg\")\), \(StyleBox(\"levelspec\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) gives the positions of the first \(StyleBox(\"n\", \"Arg\")\) objects found."
PostDecrement::usage:= "\({StyleBox(\"x\", \"Arg\"), \"--\"}\) decreases the value of \(StyleBox(\"x\", \"Arg\")\) by 1 and returns the old value.\nPostDecrement(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)) decreases \(StyleBox(\"x\", \"Arg\")\) by \(StyleBox(\"y\", \"Arg\")\) and returns the old value."
PostIncrement::usage:= "\({StyleBox(\"x\", \"Arg\"), \"++\"}\) increases the value of \(StyleBox(\"x\", \"Arg\")\) by 1 and returns the old value.\nPostIncrement(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)) increases \(StyleBox(\"x\", \"Arg\")\) by \(StyleBox(\"y\", \"Arg\")\) and returns the old value."
Power::usage:= "\(StyleBox(\"x\", \"Arg\")\) ^ \(StyleBox(\"y\", \"Arg\")\) gives \(StyleBox(\"x\", \"Arg\")\) to the power \(StyleBox(\"y\", \"Arg\")\)."
PowerMod::usage:= "PowerMod(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \(StyleBox(\"m\", \"Arg\")\)) gives \({{StyleBox(\"a\", \"Arg\"), SuperscriptBox(StyleBox(\"b\", \"Arg\"))}, \" \", \"mod\", \" \", StyleBox(\"m\", \"Arg\")}\).\nPowerMod(\(StyleBox(\"a\", \"Arg\")\), \({\"-\", \"1\"}\), \(StyleBox(\"m\", \"Arg\")\)) gives the modular inverse of \(StyleBox(\"a\", \"Arg\")\) modulo \(StyleBox(\"m\", \"Arg\")\)."
Precedes::usage:= "Precedes(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[Precedes] \(StyleBox(\"y\", \"Arg\")\) \[Precedes] \[Ellipsis]."
PrecedesEqual::usage:= "PrecedesEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[PrecedesEqual] \(StyleBox(\"y\", \"Arg\")\) \[PrecedesEqual] \[Ellipsis]."
PrecedesTilde::usage:= "PrecedesTilde(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[PrecedesTilde] \(StyleBox(\"y\", \"Arg\")\) \[PrecedesTilde] \[Ellipsis]."
Precision::usage:= "Precision(\(StyleBox(\"x\", \"Arg\")\)) returns the effective number of digits of precision in the number \(StyleBox(\"x\", \"Arg\")\)."
Prepend::usage:= "Prepend(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"elem\", \"Arg\")\)) returns \(StyleBox(\"list\", \"Arg\")\) with \(StyleBox(\"elem\", \"Arg\")\) prepended."
Print::usage:= "Print(\(StyleBox(\"expr\", \"Arg\")\)) prints \(StyleBox(\"expr\", \"Arg\")\) as output."
Product::usage:= "Product(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) is the product \({UnderoverscriptBox(\"\\[Product]\", {StyleBox(\"i\", \"Arg\"), \"=\", \"1\"}, {StyleBox(\"i\", \"Arg\"), SubscriptBox(StyleBox(\"max\", \"Arg\"))}), \" \", StyleBox(\"f\", \"Arg\")}\).\nProduct(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) starts with \(StyleBox(\"i\", \"Arg\")\) = \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\).\nProduct(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\) .. \(StyleBox(\"di\", \"Arg\")\)) uses steps \(StyleBox(\"di\", \"Arg\")\).\nProduct(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] {\(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) uses successive values \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis].\nProduct(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\) , \(StyleBox(\"j\", \"Arg\")\) \[Rule] \(StyleBox(\"j\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"j\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\) , \[Ellipsis]) evaluates the multiple product \({UnderoverscriptBox(\"\\[Product]\", {\"i\", \"=\", {\"i\", SubscriptBox(\"min\")}}, {\"i\", SubscriptBox(\"max\")}), \" \", {UnderoverscriptBox(\"\\[Product]\", {\"j\", \"=\", {\"j\", SubscriptBox(\"min\")}}, {\"j\", SubscriptBox(\"max\")}), {\"\\[Ellipsis]\", \"f\"}}}\)."
ProgressIndicator::usage:= "ProgressIndicator(\(StyleBox(\"x\", \"Arg\")\)) represents a progress indicator with setting \(StyleBox(\"x\", \"Arg\")\) in the range 0 to 1.\nProgressIndicator(Dynamic(\(StyleBox(\"x\", \"Arg\")\))) take the setting to be the dynamically updated current value of \(StyleBox(\"x\", \"Arg\")\).\nProgressIndicator(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) represents a progress indicator with range \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) to \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)"
ProgressIndicatorBox::usage:= "ProgressIndicatorBox(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"range\", \"Arg\")\)) is a low-level construct that represents a progress indicator with setting \(StyleBox(\"x\", \"Arg\")\) in a given range."
Protect::usage:= "Protect(\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) sets the attribute Protected for the symbols \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
Protected::usage:= "Protected is an attribute which prevents any values or definitions associated with a symbol from being modified."
PureArgument::usage:= "# represents the first argument supplied to a pure function.\n#\(StyleBox(\"n\", \"Arg\")\) represents the \(StyleBox(\"n\", \"Arg\")\)\(SuperscriptBox(\"th\")\) argument."
Purple::usage:= "Purple represents the color purple in graphics and style specifications."
QRDecomposition::usage:= "QRDecomposition(\(StyleBox(\"m\", \"Arg\")\)) computes the QR-decomposition \(StyleBox(\"q\", \"Arg\")\) \[Dot] \(StyleBox(\"r\", \"Arg\")\) of a matrix \(StyleBox(\"m\", \"Arg\")\) and returns the list {\(StyleBox(\"q\", \"Arg\")\), \(StyleBox(\"r\", \"Arg\")\)}."
Quantile::usage:= "Quantile(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"q\", \"Arg\")\)) gives the \(StyleBox(\"q\", \"Arg\")\)-quantile, 0 \[LessEqual] \(StyleBox(\"q\", \"Arg\")\) \[LessEqual] 1, of a \(StyleBox(\"list\", \"Arg\")\).\nQuantile(\(StyleBox(\"list\", \"Arg\")\), {\(StyleBox(\"q\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"q\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) gives a list of quantiles \(StyleBox(\"q\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"q\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis].\nQuantile(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"q\", \"Arg\")\), {{\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\)}, {\(StyleBox(\"c\", \"Arg\")\), \(StyleBox(\"d\", \"Arg\")\)}}) uses range parameters {\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\)} and interpolation parameters {\(StyleBox(\"c\", \"Arg\")\), \(StyleBox(\"d\", \"Arg\")\)}."
Quit::usage:= "Quit() terminates the \(StyleBox(\"pMath\", \"TI\")\) console session."
Quotient::usage:= "Quotient(\(StyleBox(\"m\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) gives the integer quotient of \(StyleBox(\"m\", \"Arg\")\) and \(StyleBox(\"n\", \"Arg\")\).\nQuotient(\(StyleBox(\"m\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"d\", \"Arg\")\)) uses an offset \(StyleBox(\"d\", \"Arg\")\)."
RadicalBox::usage:= "RadicalBox(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) is a low-level box construct that represents the displayed object \(RadicalBox(StyleBox(\"x\", \"Arg\"), StyleBox(\"n\", \"Arg\"))\) in document expressions."
RadioButton::usage:= "RadioButton(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"val\", \"Arg\")\)) represents a radio button whose setting \(StyleBox(\"x\", \"Arg\")\) is set to \(StyleBox(\"val\", \"Arg\")\) when the button is clicked.\nRadioButton(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"val\", \"Arg\")\)) displays as \(RadioButtonBox(True)\) when \(StyleBox(\"x\", \"Arg\")\) is \(StyleBox(\"val\", \"Arg\")\) and \(RadioButtonBox(False)\) otherwise.\nRadioButton(Dynamic(\(StyleBox(\"x\", \"Arg\")\)), \(StyleBox(\"val\", \"Arg\")\)) takes the setting to be the dynamically updated current value of \(StyleBox(\"x\", \"Arg\")\)."
RadioButtonBar::usage:= "RadioButtonBar(\(StyleBox(\"x\", \"Arg\")\), {\(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) represents a radio button bar with setting \(StyleBox(\"x\", \"Arg\")\) and with labeled radio buttons for values \(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nRadioButtonBar(Dynamic(x), {\(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) updates \(StyleBox(\"x\", \"Arg\")\) dynamically when any of the buttons is clicked.\nRadioButtonBar(\(StyleBox(\"x\", \"Arg\")\), {\(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"1\")\) \[Rule] \(StyleBox(\"lbl\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"2\")\) \[Rule] \(StyleBox(\"lbl\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) uses labels \(StyleBox(\"lbl\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) for the radio button corresponding to \(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
RadioButtonBox::usage:= "RadioButton(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"val\", \"Arg\")\)) represents a radio button whose setting \(StyleBox(\"x\", \"Arg\")\) is set to \(StyleBox(\"val\", \"Arg\")\) when the button is clicked.\nRadioButton(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"val\", \"Arg\")\)) displays as \(RadioButtonBox(True)\) when \(StyleBox(\"x\", \"Arg\")\) is \(StyleBox(\"val\", \"Arg\")\) and as \(RadioButtonBox(False)\) otherwise.\nRadioButton(Dynamic(\(StyleBox(\"x\", \"Arg\")\)), \(StyleBox(\"val\", \"Arg\")\)) takes the setting to be the dynamically updated current value of \(StyleBox(\"x\", \"Arg\")\)."
RandomInteger::usage:= "RandomInteger() pseudo-randomly gives 0 or 1.\nRandomInteger(\(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) gives a pseudo-random integer in the range {0, \[Ellipsis], \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)}.\nRandomInteger(\(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) gives a pseudo-random integer in the range {\(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\), \[Ellipsis], \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)}.\nRandomInteger(\(StyleBox(\"range\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) gives a list of \(StyleBox(/\\/(\"n\", \" \"), \"Arg\")\) pseudo-random integers.\nRandomInteger(\(StyleBox(\"range\", \"Arg\")\), {\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) gives an \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\) \[Times] \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\) \[Times] \[Ellipsis] array of pseudo-random integers."
RandomReal::usage:= "RandomReal() gives pseudorandom real number in the range 0 to 1.\nRandomReal(\(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) gives a pseudo-random real number in the range 0 to \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\).\nRandomReal(\(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) gives a pseudo-random real number in the range \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) to \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\).\nRandomReal(\(StyleBox(\"range\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) gives a list of \(StyleBox(/\\/(\"n\", \" \"), \"Arg\")\) pseudo-random real numbers.\nRandomReal(\(StyleBox(\"range\", \"Arg\")\), {\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) gives an \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\) \[Times] \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\) \[Times] \[Ellipsis] array of pseudo-random real numbers."
Range::usage:= "\(StyleBox(\"a\", \"Arg\")\) .. \(StyleBox(\"b\", \"Arg\")\) represents a range of values between \(StyleBox(\"a\", \"Arg\")\) and \(StyleBox(\"b\", \"Arg\")\).\n\(StyleBox(\"a\", \"Arg\")\) .. \(StyleBox(\"b\", \"Arg\")\) .. c represents the sequence \(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"a\", \"Arg\")\) + \(StyleBox(\"c\", \"Arg\")\), \(StyleBox(\"a\", \"Arg\")\) + 2\(StyleBox(\"c\", \"Arg\")\), \[Ellipsis], \(StyleBox(\"b\", \"Arg\")\)."
Rational::usage:= "Rational is the head for non-integer rational numbers."
RawBoxes::usage:= "RawBoxes(\(StyleBox(\"boxes\", \"Arg\")\)) is a low-level construct which is formated as \(StyleBox(\"boxes\", \"Arg\")\) without further interpretation."
Re::usage:= "Re(\(StyleBox(\"z\", \"Arg\")\)) gives the real part of the complex number \(StyleBox(\"z\", \"Arg\")\)."
Read::usage:= "Read(\(StyleBox(\"stream\", \"Arg\")\)) reads one expression from an input stream and returns the expression.\nRead(\(StyleBox(\"stream\", \"Arg\")\), \(StyleBox(\"type\", \"Arg\")\)) reads one object of the specified type.\nRead(\(StyleBox(\"stream\", \"Arg\")\), {\(StyleBox(\"type\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"type\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) reads a sequence of objects of the specified types."
ReadList::usage:= "ReadList(\(StyleBox(\"file\", \"Arg\")\)) reads the remaining expressions from an input stream or file and returns a list of them.\nReadList(\(StyleBox(\"file\", \"Arg\")\), \(StyleBox(\"type\", \"Arg\")\)) reads objects of the specified type from an input stream or file, until the end of the file is reached. A list of the objects is returned.\nReadList(\(StyleBox(\"file\", \"Arg\")\), {\(StyleBox(\"type\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"type\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) reads objects with a sequence of types, until the end of file is reached.\nReadList(\(StyleBox(\"file\", \"Arg\")\), \(StyleBox(\"types\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) reads only the first \(StyleBox(\"n\", \"Arg\")\) objects of the specified types."
ReadProtected::usage:= "ReadProtected is an attribute which prevents definitions associated with a symbol from being seen immediately."
Real::usage:= "Real is the head used for floating-point numbers."
RecordLists::usage:= "RecordLists is an option for ReadList which specifies whether objects from separate records should be returned in separate sublists."
Red::usage:= "Red represents the color red in graphics and style specifications."
ReflectionMatrix::usage:= "ReflectionMatrix(\(StyleBox(\"n\", \"Arg\")\)) returns a matrix that represents reflection of points at a plane through the origin with normal vector \(StyleBox(\"n\", \"Arg\")\)."
ReflectionTransform::usage:= "ReflectionTransform(\(StyleBox(\"v\", \"Arg\")\)) returns a TransformationFunction which represents a reflection at a plane through the origin, normal to the vector \(StyleBox(\"v\", \"Arg\")\).\nReflectionTransform(\(StyleBox(\"v\", \"Arg\")\), \(StyleBox(\"p\", \"Arg\")\)) uses a plane through \(StyleBox(\"p\", \"Arg\")\)."
Refresh::usage:= "Refresh(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"options\", \"Arg\")\)) represents an object whose value in a Dynamic construct should be refreshed at times specified by the \(StyleBox(\"options\", \"Arg\")\).\nRefresh(\(StyleBox(\"expr\", \"Arg\")\), None) disables automatic refreshes of \(StyleBox(\"expr\", \"Arg\")\)."
ReGather::usage:= "ReGather() returns and resets all emitted values so far inside the enclosing Gather\nReGather(\(StyleBox(\"patt\", \"Arg\")\)) also sets the pattern for filtering subsequent Emit calls."
RegularExpression::usage:= "RegularExpression(\"\(StyleBox(\"regex\", \"Arg\")\)\") represents the regular expression specified by the string \"\(StyleBox(\"regex\", \"Arg\")\)\"."
ReIm::usage:= "ReIm(\(StyleBox(\"z\", \"Arg\")\)) gives the list {Re(\(StyleBox(\"z\", \"Arg\")\)), Im(\(StyleBox(\"z\", \"Arg\")\))} of the complex number \(StyleBox(\"z\", \"Arg\")\)."
ReleaseHold::usage:= "ReleaseHold(\(StyleBox(\"expr\", \"Arg\")\)) removes Hold, HoldForm, HoldPattern and HoldComplete from \(StyleBox(\"expr\", \"Arg\")\)."
Remove::usage:= "Remove(\(StyleBox(\"symbol\", \"Arg\")\)\(SubscriptBox(\"1\")\), \[Ellipsis]) removes symbols completely so that their names are no longer recognized by \(StyleBox(\"pMath\", \"TI\")\)."
RenameDirectory::usage:= "RenameDirectory(\(StyleBox(\"dir\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"dir\", \"Arg\")\)\(SubscriptBox(\"2\")\)) renames the directory \(StyleBox(\"dir\", \"Arg\")\)\(SubscriptBox(\"1\")\) to \(StyleBox(\"dir\", \"Arg\")\)\(SubscriptBox(\"2\")\)."
RenameFile::usage:= "RenameFile(\(StyleBox(\"file\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"file\", \"Arg\")\)\(SubscriptBox(\"2\")\)) renames \(StyleBox(\"file\", \"Arg\")\)\(SubscriptBox(\"1\")\) to \(StyleBox(\"file\", \"Arg\")\)\(SubscriptBox(\"2\")\)."
Repeated::usage:= "\(StyleBox(\"p\", \"Arg\")\)** or Repeated(\(StyleBox(\"p\", \"Arg\")\), 1 .. ) is a pattern object which represents ,a sequence of one or more expressions, each matching \(StyleBox(\"p\", \"Arg\")\).\n\(StyleBox(\"p\", \"Arg\")\)*** or Repeated(\(StyleBox(\"p\", \"Arg\")\), 0 ..) represents zero or more objects matching \(StyleBox(\"p\", \"Arg\")\).\nRepeated(\(StyleBox(\"p\", \"Arg\")\), \(StyleBox(\"min\", \"Arg\")\) .. \(StyleBox(\"max\", \"Arg\")\)) represents between \(StyleBox(\"min\", \"Arg\")\) and \(StyleBox(\"max\", \"Arg\")\) objects matching \(StyleBox(\"p\", \"Arg\")\).\nRepeated(\(StyleBox(\"p\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) represents a sequence of exactly \(StyleBox(\"n\", \"Arg\")\) expressions matching \(StyleBox(\"p\", \"Arg\")\)."
Replace::usage:= "Replace(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"rules\", \"Arg\")\)) applies a rule or list of rules to the entire expression \(StyleBox(\"expr\", \"Arg\")\).\nReplace(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"rules\", \"Arg\")\), \(StyleBox(\"levelspec\", \"Arg\")\)) applies rules to parts of \(StyleBox(\"expr\", \"Arg\")\) specified by \(StyleBox(\"levelspec\", \"Arg\")\)."
ReplaceList::usage:= "ReplaceList(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"rules\", \"Arg\")\)) applies a rule or list of rules to the entire expression \(StyleBox(\"expr\", \"Arg\")\) in all possible ways and returns a list of the results obtained.\nReplaceList(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"rules\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) gives at most \(StyleBox(\"n\", \"Arg\")\) results."
ReplacePart::usage:= "ReplacePart(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] \(StyleBox(\"new\", \"Arg\")\)) yields an expression in which the \(StyleBox(\"i\", \"Arg\")\)\(SuperscriptBox(\"th\")\) part of \(StyleBox(\"expr\", \"Arg\")\) is replaced by \(StyleBox(\"new\", \"Arg\")\).\nReplacePart(\(StyleBox(\"expr\", \"Arg\")\), {\(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"1\")\) \[Rule] \(StyleBox(\"new\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"2\")\) \[Rule] \(StyleBox(\"new\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) replaces parts at positions \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"n\", \"Arg\"))\) by \(StyleBox(\"new\", \"Arg\")\)\(SubscriptBox(StyleBox(\"n\", \"Arg\"))\).\nReplacePart(\(StyleBox(\"expr\", \"Arg\")\), {{\(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"j\", \"Arg\")\)\(SubscriptBox(\"1\")\), \[Ellipsis]} \[Rule] \(StyleBox(\"new\", \"Arg\")\)\(SubscriptBox(\"1\")\), \[Ellipsis]}) replaces parts at positions {\(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"n\", \"Arg\"))\), \(StyleBox(\"j\", \"Arg\")\)\(SubscriptBox(StyleBox(\"n\", \"Arg\"))\), \[Ellipsis]} by \(StyleBox(\"new\", \"Arg\")\)\(SubscriptBox(StyleBox(\"n\", \"Arg\"))\).\nReplacePart(\(StyleBox(\"expr\", \"Arg\")\), {\(StyleBox(\"patt\", \"Arg\")\)\(SubscriptBox(\"1\")\) \[Rule] \(StyleBox(\"new\", \"Arg\")\)\(SubscriptBox(\"1\")\), \[Ellipsis]}) replaces parts at positions that match \(StyleBox(\"patt\", \"Arg\")\)\(SubscriptBox(StyleBox(\"n\", \"Arg\"))\) by \(StyleBox(\"new\", \"Arg\")\)\(SubscriptBox(StyleBox(\"n\", \"Arg\"))\)."
ReplaceRepeated::usage:= "ReplaceRepeated(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"rules\", \"Arg\")\)) repeatedly performs replacements until \(StyleBox(\"expr\", \"Arg\")\) no longer changes."
Rescale::usage:= "Rescale(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"min\", \"Arg\")\) .. \(StyleBox(\"max\", \"Arg\")\)) rescales \(StyleBox(\"x\", \"Arg\")\) to the range 0 .. 1 instead of \(StyleBox(\"min\", \"Arg\")\) .. \(StyleBox(\"max\", \"Arg\")\).\nRescale(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"min\", \"Arg\")\) .. \(StyleBox(\"max\", \"Arg\")\), \(StyleBox(\"xmin\", \"Arg\")\) .. \(StyleBox(\"xmax\", \"Arg\")\)) rescales \(StyleBox(\"x\", \"Arg\")\) to range \(StyleBox(\"xmin\", \"Arg\")\) .. \(StyleBox(\"xmax\", \"Arg\")\).\nRescale(\(StyleBox(\"list\", \"Arg\")\)) rescales each \(StyleBox(\"list\", \"Arg\")\) element to the range 0 .. 1 instead of Min(\(StyleBox(\"list\", \"Arg\")\)) .. Max(\(StyleBox(\"list\", \"Arg\")\))."
ResetDirectory::usage:= "ResetDirectory() resets the current directory to its previous value."
Rest::usage:= "Rest(\(StyleBox(\"expr\", \"Arg\")\)) returns \(StyleBox(\"expr\", \"Arg\")\) with the first element removed."
Return::usage:= "Return(\(StyleBox(\"expr\", \"Arg\")\)) returns the value \(StyleBox(\"expr\", \"Arg\")\) from a function or from Dialog.\nReturn() returns the value /\\/."
ReturnCreatesNewSection::usage:= "ReturnCreatesNewSection is an option for Section which specifies whether pressing the return key creates a new section instead of merely inserting a line break in the current section."
Reverse::usage:= "Reverse(\(StyleBox(\"expr\", \"Arg\")\)) reverses the order of elements in \(StyleBox(\"expr\", \"Arg\")\).\nReverse(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"levelspec\", \"Arg\")\)) reverses elements at levels specified by \(StyleBox(\"levelspec\", \"Arg\")\) in \(StyleBox(\"expr\", \"Arg\")\).\nReverse(\(StyleBox(\"expr\", \"Arg\")\), {\(StyleBox(\"levelspec\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"levelspec\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) reverses elements at levels specified by any of the \(StyleBox(\"levelspec\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) in \(StyleBox(\"expr\", \"Arg\")\)."
ReverseElement::usage:= "ReverseElement(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\)) displays as \(StyleBox(\"a\", \"Arg\")\) \[ReverseElement] \(StyleBox(\"b\", \"Arg\")\)."
RGBColor::usage:= "RGBColor(\(StyleBox(\"red\", \"Arg\")\), \(StyleBox(\"green\", \"Arg\")\), \(StyleBox(\"blue\", \"Arg\")\)) represents a color in graphics and style specifications."
Riffle::usage:= "Riffle({\(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"x\", \"Arg\")\)) gives {\(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"2\")\), \(StyleBox(\"x\", \"Arg\")\), \[Ellipsis]}.\nRiffle({\(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, {\(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) yields {\(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"2\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}.\nRiffle(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) gives a list in which every \(StyleBox(\"n\", \"Arg\")\)\(SuperscriptBox(\"th\")\) element is \(StyleBox(\"x\", \"Arg\")\).\nRiffle(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\) .. \(StyleBox(\"n\", \"Arg\")\)) generates a list in which \(StyleBox(\"x\", \"Arg\")\) appears at positions \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) , \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) + \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) + 2\(StyleBox(\"n\", \"Arg\")\), \[Ellipsis], \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)."
RightTriangle::usage:= "RightTriangle(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[RightTriangle] \(StyleBox(\"y\", \"Arg\")\) \[RightTriangle] \[Ellipsis]."
RightTriangleEqual::usage:= "RightTriangleEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[RightTriangleEqual] \(StyleBox(\"y\", \"Arg\")\) \[RightTriangleEqual] \[Ellipsis]."
Rotate::usage:= "Rotate(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"\\[Alpha]\", \"Arg\")\)) displays as \(StyleBox(\"expr\", \"Arg\")\) rotated by the angle \(StyleBox(\"\\[Alpha]\", \"Arg\")\) in anti-clockwise direction."
RotationBox::usage:= "RotationBox(\(StyleBox(\"boxes\", \"Arg\")\), BoxRotation \[Rule] \(StyleBox(\"angle\", \"Arg\")\)) is a low-level construct which represents a rotated box."
RotationMatrix::usage:= "RotationMatrix(\(StyleBox(\"\\[Theta]\", \"Arg\")\)) returns a 2D rotation matrix for rotating 2D vectors counterclockwise by \(StyleBox(\"\\[Theta]\", \"Arg\")\) radians.\nRotationMatrix(\(StyleBox(\"\\[Theta]\", \"Arg\")\), \(StyleBox(\"v\", \"Arg\")\)) gives a 3D rotation matrix that rotates vectors counterclockwise around the 3D vector \(StyleBox(\"v\", \"Arg\")\)."
RotationTransform::usage:= "RotationTransform(\(StyleBox(\"\\[Theta]\", \"Arg\")\)) returns a TransformationFunction which represents a counterclockwise 2D rotation by \(StyleBox(\"\\[Theta]\", \"Arg\")\) radians about the origin.\nRotationTransform(\(StyleBox(\"\\[Theta]\", \"Arg\")\), \(StyleBox(\"p\", \"Arg\")\)) gives a 2D rotation about the 2D point \(StyleBox(\"p\", \"Arg\")\).\nRotationTransform(\(StyleBox(\"\\[Theta]\", \"Arg\")\), \(StyleBox(\"v\", \"Arg\")\)) gives a 3D rotation around the direction of the 3D vector \(StyleBox(\"v\", \"Arg\")\).\nRotationTransform(\(StyleBox(\"\\[Theta]\", \"Arg\")\), \(StyleBox(\"v\", \"Arg\")\), \(StyleBox(\"p\", \"Arg\")\)) gives a 3D rotation around the axis \(StyleBox(\"v\", \"Arg\")\) anchored at point \(StyleBox(\"p\", \"Arg\")\)."
Round::usage:= "Round(\(StyleBox(\"x\", \"Arg\")\)) gives the integer closet to \(StyleBox(\"x\", \"Arg\")\).\nRound(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"a\", \"Arg\")\)) rounds to the nearest multiple of \(StyleBox(\"a\", \"Arg\")\)."
Row::usage:= "Row({\(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) displays as the \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) arranged in a row, potentially expanding multiple lines.\nRow(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"s\", \"Arg\")\)) inserts \(StyleBox(\"s\", \"Arg\")\) as a separator between successive elements."
RowSpacing::usage:= "RowSpacing is an option for Grid which specifies the spacing between adjacent rows in points."
Rule::usage:= "\({StyleBox(\"lhs\", \"Arg\"), \"->\", StyleBox(\"rhs\", \"Arg\")}\) or \({StyleBox(\"lhs\", \"Arg\"), \"\\[Rule]\", StyleBox(\"rhs\", \"Arg\")}\) represents a rule which transforms \(StyleBox(\"lhs\", \"Arg\")\) to \(StyleBox(\"rhs\", \"Arg\")\)."
RuleDelayed::usage:= "\({StyleBox(\"lhs\", \"Arg\"), \":>\", StyleBox(\"rhs\", \"Arg\")}\) or \({StyleBox(\"lhs\", \"Arg\"), \"\\[RuleDelayed]\", StyleBox(\"rhs\", \"Arg\")}\) represents a rule which transforms \(StyleBox(\"lhs\", \"Arg\")\) to \(StyleBox(\"rhs\", \"Arg\")\), evaluating \(StyleBox(\"rhs\", \"Arg\")\) only after the rule is used."
SameTest::usage:= "SameTest is an option whose setting gives a pairwise comparison function to determine whether expressions should be considered the same."
ScalingMatrix::usage:= "ScalingMatrix({\(StyleBox({\"s\", SubscriptBox(\"x\")}, \"Arg\")\), \(StyleBox({\"s\", SubscriptBox(\"y\")}, \"Arg\")\), \[Ellipsis]}) returns the matrix that scales by a factor \(StyleBox({\"s\", SubscriptBox(\"i\")}, \"Arg\")\) along each coordinate axis.\nScalingMatrix(\(StyleBox(\"s\", \"Arg\")\), \(StyleBox(\"v\", \"Arg\")\)) gives the matrix that scales by \(StyleBox(\"s\", \"Arg\")\) along the vector \(StyleBox(\"v\", \"Arg\")\)."
ScalingTransform::usage:= "ScalingTransform({\(StyleBox({\"s\", SubscriptBox(\"x\")}, \"Arg\")\), \(StyleBox({\"s\", SubscriptBox(\"y\")}, \"Arg\")\), \[Ellipsis]}) returns a TransformationFunction that scales by a factor \(StyleBox({\"s\", SubscriptBox(\"i\")}, \"Arg\")\) along each coordinate axis.\nScalingTransform({\(StyleBox({\"s\", SubscriptBox(\"x\")}, \"Arg\")\), \(StyleBox({\"s\", SubscriptBox(\"y\")}, \"Arg\")\), \[Ellipsis]}) gives scaling centered at point \(StyleBox(\"p\", \"Arg\")\).\nScalingTransform(\(StyleBox(\"s\", \"Arg\")\), \(StyleBox(\"v\", \"Arg\")\)) gives by a factor \(StyleBox(\"s\", \"Arg\")\) along the direction of \(StyleBox(\"v\", \"Arg\")\).\nScalingTransform(\(StyleBox(\"s\", \"Arg\")\), \(StyleBox(\"v\", \"Arg\")\), \(StyleBox(\"p\", \"Arg\")\)) gives by a factor \(StyleBox(\"s\", \"Arg\")\) along \(StyleBox(\"v\", \"Arg\")\), centered at point \(StyleBox(\"p\", \"Arg\")\)."
Scan::usage:= "Scan(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\)) evaluates \(StyleBox(\"f\", \"Arg\")\) applied to each element of \(StyleBox(\"expr\", \"Arg\")\) in turn.\nScan(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"levelspec\", \"Arg\")\)) applies \(StyleBox(\"f\", \"Arg\")\) to parts of \(StyleBox(\"expr\", \"Arg\")\) specified by \(StyleBox(\"levelspec\", \"Arg\")\)."
ScriptSizeMultipliers::usage:= "ScriptSizeMultipliers is an option for Style which specifies how much smaller to render each successive level of subscripts, etc."
Sec::usage:= "Sec(\(StyleBox(\"z\", \"Arg\")\)) gives the secant of \(StyleBox(\"z\", \"Arg\")\)."
Sech::usage:= "Sech(\(StyleBox(\"z\", \"Arg\")\)) gives the hyperbolic secant of \(StyleBox(\"z\", \"Arg\")\)."
Section::usage:= "Section(\(StyleBox(\"content\", \"Arg\")\)) is the low-level representation of a section inside a \(StyleBox(\"pMath\", \"TI\")\) document.\nSection(\(StyleBox(\"content\", \"Arg\")\), \"\(StyleBox(\"style\", \"Arg\")\)\") represents a section in the specified style."
SectionEditDuplicate::usage:= "SectionEditDuplicate is an option for Section which specifies whether the current section should be duplicated (with a new style) before any edits are done."
SectionEditDuplicateMakesCopy::usage:= "SectionEditDuplicateMakesCopy is an option for Section which specifies whether a copy of the section should be inserted before duplicating it for editing, when SectionEditDuplicate is True."
SectionFrame::usage:= "SectionFrame is an option for Section which specifies whether a frame should draw around a section."
SectionFrameColor::usage:= "SectionFrameColor is an option for Section which specifies the color of the frame around a section."
SectionFrameMargins::usage:= "SectionFrameMargins is an option for Section which specifies the margins in points to leave inside a frame that is drawn around a section."
SectionGenerated::usage:= "SectionGenerated is an option for Section which specifies whether the section should be removed when output is produced there during an evaluation."
SectionGroup::usage:= "SectionGroup({\(StyleBox(\"section\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"section\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, All) represents an open group of sections in a \(StyleBox(\"pMath\", \"TI\")\) document.\nSectionGroup({\(StyleBox(\"section\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"section\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"i\", \"Arg\")\)) represents a group of sections in which only the \(StyleBox(\"i\", \"Arg\")\)\(SuperscriptBox(\"th\")\) one is open."
SectionGroupPrecedence::usage:= "SectionGroupPrecedence is an option for Section which controls automatic section grouping."
SectionLabel::usage:= "SectionLabel is an option for Section which specifies a label for the section."
SectionLabelAutoDelete::usage:= "SectionLabelAutoDelete is an option for Section which determines whether a section label should be automatically removed when the section's content is edited."
SectionMargins::usage:= "SectionMargins is an option for Section which specifies the margins in points to leave around a section."
SectionPrint::usage:= "SectionPrint(\"\(StyleBox(\"style\", \"Arg\")\)\", \(StyleBox(\"expr\", \"Arg\")\)) prints \(StyleBox(\"expr\", \"Arg\")\) in a new section with a given style."
Select::usage:= "Select(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"crit\", \"Arg\")\)) picks out all elements \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) of \(StyleBox(\"list\", \"Arg\")\) for which \(StyleBox(\"crit\", \"Arg\")\)(\(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)) is True.\nSelect(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"crit\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) picks out the first \(StyleBox(\"n\", \"Arg\")\) elements for which \(StyleBox(\"crit\", \"Arg\")\)(\(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)) is True."
Selectable::usage:= "Selectable is an option for displayed objects, sections and documents which specifies whether their content can be selected interactively by the user."
SelectedDocument::usage:= "SelectedDocument() returns the currently selected document."
Sequence::usage:= "Sequence(\(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) represents a sequence of arguments to be spliced automatically into any function."
SequenceHold::usage:= "SequenceHold is an attribute which specifies that Sequence objects appearing in the arguments of a function should not automatically be flattened out."
SetAttributes::usage:= "SetAttributes(\(StyleBox(\"symbol\", \"Arg\")\), \(StyleBox(\"attr\", \"Arg\")\)) adds \(StyleBox(\"attr\", \"Arg\")\) to the list of attributes of \(StyleBox(\"symbol\", \"Arg\")\)."
SetDirectory::usage:= "SetDirectory(\"\(StyleBox(\"dir\", \"Arg\")\)\") set the current working directory."
SetOptions::usage:= "SetOptions(\(StyleBox(\"s\", \"Arg\")\), \(StyleBox(\"name\", \"Arg\")\)\(SubscriptBox(\"1\")\) \[Rule] \(StyleBox(\"value\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"name\", \"Arg\")\)\(SubscriptBox(\"2\")\) \[Rule] \(StyleBox(\"value\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) sets the specified default options for a symbol \(StyleBox(\"s\", \"Arg\")\)."
SetPrecision::usage:= "SetPrecision(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"p\", \"Arg\")\)) returns a version of \(StyleBox(\"expr\", \"Arg\")\) in which all numbers have been set to have precision \(StyleBox(\"p\", \"Arg\")\)."
SetStreamPosition::usage:= "SetStreamPosition(\(StyleBox(\"stream\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) sets the current position in a binary stream."
Setter::usage:= "Setter(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"val\", \"Arg\")\)) represents a setter button whose setting \(StyleBox(\"x\", \"Arg\")\) is set to \(StyleBox(\"val\", \"Arg\")\) when the button is clicked. The button is labeled with \(StyleBox(\"val\", \"Arg\")\) and appears pressed if the value of \(StyleBox(\"x\", \"Arg\")\) is \(StyleBox(\"val\", \"Arg\")\), and unpressed otherwise.\nSetter(Dynamic(\(StyleBox(\"x\", \"Arg\")\)), \(StyleBox(\"val\", \"Arg\")\)) takes the setting to be the dynamically updated current value of \(StyleBox(\"x\", \"Arg\")\) being reset when the button is clicked.\nSetter(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"val\", \"Arg\")\), \(StyleBox(\"label\", \"Arg\")\)) labels the setter button with \(StyleBox(\"label\", \"Arg\")\)."
SetterBar::usage:= "SetterBar(\(StyleBox(\"x\", \"Arg\")\), {\(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) represents a setter bar with setting \(StyleBox(\"x\", \"Arg\")\) and with setter buttons for values \(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nSetterBar(Dynamic(\(StyleBox(\"x\", \"Arg\")\)), {\(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) takes the setting to be the dynamically updated current value of \(StyleBox(\"x\", \"Arg\")\) being reset every time a setter button is clicked.\nSetterBar(\(StyleBox(\"x\", \"Arg\")\), {\(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"1\")\) \[Rule] \(StyleBox(\"label\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(\"2\")\) \[Rule] \(StyleBox(\"label\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) labels the setter button giving value \(StyleBox(\"val\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) with label \(StyleBox(\"label\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
SetterBox::usage:= "SetterBox(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"val\", \"Arg\")\), \(StyleBox(\"boxes\", \"Arg\")\)) is a low-level construct that represents a setter button with label \(StyleBox(\"boxes\", \"Arg\")\) and setting \(StyleBox(\"x\", \"Arg\")\) which is set to \(StyleBox(\"val\", \"Arg\")\) when the button is clicked."
Setting::usage:= "Setting(\(StyleBox(\"expr\", \"Arg\")\)) replaces control objects such as sliders in \(StyleBox(\"expr\", \"Arg\")\) by their settings."
Shallow::usage:= "Shallow(\(StyleBox(\"expr\", \"Arg\")\)) prints as a shallow form of \(StyleBox(\"expr\", \"Arg\")\).\nShallow(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"depth\", \"Arg\")\)) prints with all parts of \(StyleBox(\"expr\", \"Arg\")\) below the specified depth given in skeleton form.\nShallow(\(StyleBox(\"expr\", \"Arg\")\), {\(StyleBox(\"depth\", \"Arg\")\), \(StyleBox(\"length\", \"Arg\")\)}) also gives parts whose lengths are above the specified limit in skeleton form."
ShearingMatrix::usage:= "ShearingMatrix(\(StyleBox(\"\\[Theta]\", \"Arg\")\), \(StyleBox(\"v\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) returns the matrix that shears vectors by \(StyleBox(\"\\[Theta]\", \"Arg\")\) radians along the direction of the vector \(StyleBox(\"v\", \"Arg\")\), and normal to the vector \(StyleBox(\"n\", \"Arg\")\)."
ShearingTransform::usage:= "ShearingTransform(\(StyleBox(\"\\[Theta]\", \"Arg\")\), \(StyleBox(\"v\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) returns a TransformationFunction that represents a shears by \(StyleBox(\"\\[Theta]\", \"Arg\")\) radians along the direction of the vector \(StyleBox(\"v\", \"Arg\")\), and normal to the vector \(StyleBox(\"n\", \"Arg\")\)., and keeping the origin fixed.\nShearingTransform(\(StyleBox(\"\\[Theta]\", \"Arg\")\), \(StyleBox(\"v\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"p\", \"Arg\")\)) gives a shear that keeps \(StyleBox(\"p\", \"Arg\")\) fixed, instead of the origin."
Short::usage:= "Short(\(StyleBox(\"expr\", \"Arg\")\)) prints as a short form of \(StyleBox(\"expr\", \"Arg\")\), less than about one line long.\nShort(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) prints as a form of \(StyleBox(\"expr\", \"Arg\")\) about \(StyleBox(\"n\", \"Arg\")\) lines long."
Shortest::usage:= "Shortest(\(StyleBox(\"p\", \"Arg\")\)) is a pattern object that matches the shortest sequence consistent with the pattern \(StyleBox(\"p\", \"Arg\")\)."
ShowAutoStyles::usage:= "ShowAutoStyles is an option for Section and Style which determines whether styles specific to various syntactic constructs are to be shown."
ShowDefinition::usage:= "??\(StyleBox(\"symbol\", \"Arg\")\) or ShowDefinition(\(StyleBox(\"symbol\", \"Arg\")\)) prints the definitions assigned to a symbol."
ShowSectionBracket::usage:= "ShowSectionBracket is an option for Section which specifies whether its section bracket should be shown."
ShowStringCharacters::usage:= "ShowStringCharacters is an option for Section and Style which specifies whether unescaped quotes and backslashes inside strings should be visible or not."
Sign::usage:= "Sign(\(StyleBox(\"x\", \"Arg\")\)) gives -1, 0 or 1 depending on whether \(StyleBox(\"x\", \"Arg\")\) is negative, zero or positive."
Sin::usage:= "Sin(\(StyleBox(\"z\", \"Arg\")\)) gives the sine of \(StyleBox(\"z\", \"Arg\")\)."
Sinc::usage:= "Sin(\(StyleBox(\"z\", \"Arg\")\)) gives the cardinal sine function \({\"sinc\", \"(\", {StyleBox(\"z\", \"Arg\")}, \")\"}\)."
SingleMatch::usage:= "~ or SingleMatch() is a pattern that matches any object.\n~:\(StyleBox(\"head\", \"Arg\")\) or SingleMatch(\(StyleBox(\"head\", \"Arg\")\)) is a pattern that matches any object with the specified head."
Sinh::usage:= "Sinh(\(StyleBox(\"z\", \"Arg\")\)) gives the hyperbolic sine of \(StyleBox(\"z\", \"Arg\")\)."
SinhIntegral::usage:= "SinhIntegral(\(\"z\".StyleBox(\"Arg\")\)) gives the hyperbolic sine integral function \({\"Shi\", \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
SinIntegral::usage:= "SinIntegral(\(\"z\".StyleBox(\"Arg\")\)) gives the sine integral function \({\"Si\", \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\)."
Skeleton::usage:= "Skeleton(\(StyleBox(\"n\", \"Arg\")\)) represents a sequence of \(StyleBox(\"n\", \"Arg\")\) omitted elements in an expression printed with Show or Shallow. The standard print form for Skeleton is \[LeftGuillemet]\(StyleBox(\"n\", \"Arg\")\)\[RightGuillemet]."
Slider::usage:= "Slider(\(StyleBox(\"x\", \"Arg\")\)) represents a slider with setting \(StyleBox(\"x\", \"Arg\")\) in the range 0 to 1.\nSlider(Dynamic(\(StyleBox(\"x\", \"Arg\")\))) take the setting to be the dynamically updated current value of \(StyleBox(\"x\", \"Arg\")\), with the value of \(StyleBox(\"x\", \"Arg\")\) being reset when the slider is moved.\nSlider(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) represents a slider with range \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) to \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\).\nSlider(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\) .. \(StyleBox(\"dx\", \"Arg\")\)) represents a slider that jumps in steps \(StyleBox(\"dx\", \"Arg\")\).\nSlider(\(StyleBox(\"x\", \"Arg\")\), {\(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) represents a slider in which equally spaced intervals correspond to successive settings \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
SliderBox::usage:= "SliderBox(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"range\", \"Arg\")\)) is a low-level construct that represents a slider with setting \(StyleBox(\"x\", \"Arg\")\) in a given range."
Sort::usage:= "Sort(\(StyleBox(\"list\", \"Arg\")\)) sorts the elements in \(StyleBox(\"list\", \"Arg\")\) in canonical order.\nSort(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"p\", \"Arg\")\)) sorts using the ordering function \(StyleBox(\"p\", \"Arg\")\)."
SortBy::usage:= "SortBy(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"f\", \"Arg\")\)) sorts the elements of \(StyleBox(\"list\", \"Arg\")\) in the order defined by applying \(StyleBox(\"f\", \"Arg\")\) to each of them."
Special::usage:= "Special represents a file system object that is neither a normal file nor a directory."
Split::usage:= "Split(\(StyleBox(\"list\", \"Arg\")\)) splits \(StyleBox(\"list\", \"Arg\")\) into sublists consisting of runs of identical elements.\nSplit(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"test\", \"Arg\")\)) uses \(StyleBox(\"test\", \"Arg\")\)(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\)) to check two elements for equality."
Sqrt::usage:= "Sqrt(\(StyleBox(\"z\", \"Arg\")\)) or \(SqrtBox(StyleBox(\"z\", \"Arg\"))\) gives the square root of \(StyleBox(\"z\", \"Arg\")\)."
SqrtBox::usage:= "SqrtBox(\(StyleBox(\"x\", \"Arg\")\)) is a low-level construct that represents \(SqrtBox(StyleBox(\"x\", \"Arg\"))\) in document expressions."
Stack::usage:= "Stack() shows the current evaluation stack, giving a list properties associated with evaluations that are currently being done."
StandardForm::usage:= "StandardForm(\(StyleBox(\"expr\", \"Arg\")\)) display as the standard \(StyleBox(\"pMath\", \"TI\")\) two-dimensional representation of \(StyleBox(\"expr\", \"Arg\")\)."
StartOfLine::usage:= "StartOfLine represents the start of a line in a string in StringMatch and related function."
StartOfString::usage:= "StartOfString represents the start of a string in StringMatch and related function."
StreamPosition::usage:= "StreamPosition(\(StyleBox(\"stream\", \"Arg\")\)) returns the \(StyleBox(\"stream\", \"Arg\")\)'s current position."
String::usage:= "String is the head of string values."
StringCases::usage:= "StringCases(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"patt\", \"Arg\")\)) gives a list of the substrings in \"\(StyleBox(\"string\", \"Arg\")\)\" that match the string expression \(StyleBox(\"patt\", \"Arg\")\).\nStringCases(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"lhs\", \"Arg\")\) \[Rule] \(StyleBox(\"rhs\", \"Arg\")\)) gives a list of the values of \(StyleBox(\"rhs\", \"Arg\")\) corresponding to substrings that match the string expression lhs.\nStringCases(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"p\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) includes only the first \(StyleBox(\"n\", \"Arg\")\) substrings that match.\nStringCases({\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"p\", \"Arg\")\)) gives the list of results for each of the \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
StringCount::usage:= "StringCount(\"\(StyleBox(\"string\", \"Arg\")\)\", \"\(StyleBox(\"sub\", \"Arg\")\)\") gives the number of occurrences of \"\(StyleBox(\"sub\", \"Arg\")\)\" in \"\(StyleBox(\"string\", \"Arg\")\)\".\nStringCount(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"patt\", \"Arg\")\)) gives the number of substrings in \"\(StyleBox(\"string\", \"Arg\")\)\" that match the pattern \(StyleBox(\"patt\", \"Arg\")\).\nStringCount(\"\(StyleBox(\"string\", \"Arg\")\)\", {\(StyleBox(\"patt\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"patt\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) counts the number of occurrences of any of the \(StyleBox(\"patt\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nStringCount({\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"p\", \"Arg\")\)) gives the list of results for each of the \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
StringDrop::usage:= "StringDrop(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"n\", \"Arg\")\)) returns \"\(StyleBox(\"string\", \"Arg\")\)\" with its first \(StyleBox(\"n\", \"Arg\")\) characters dropped.\nStringDrop(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox({\"-\", \"n\"}, \"Arg\")\)) returns \"\(StyleBox(\"string\", \"Arg\")\)\" with its last \(StyleBox(\"n\", \"Arg\")\) characters dropped.\nStringDrop(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"m\", \"Arg\")\) .. \(StyleBox(\"n\", \"Arg\")\)) returns \"\(StyleBox(\"string\", \"Arg\")\)\" with the characters \(StyleBox(\"m\", \"Arg\")\) through \(StyleBox(\"n\", \"Arg\")\) dropped.\nStringDrop(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"m\", \"Arg\")\) .. \(StyleBox(\"n\", \"Arg\")\) .. \(StyleBox(\"d\", \"Arg\")\)) returns \"\(StyleBox(\"string\", \"Arg\")\)\" with the characters \(StyleBox(\"m\", \"Arg\")\) through \(StyleBox(\"n\", \"Arg\")\) in steps of size \(StyleBox(\"d\", \"Arg\")\) dropped.\nStringDrop({\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"spec\", \"Arg\")\)) returns the list of results for each of the \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
StringExpression::usage:= "\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\) ++ \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\) ++ \[Ellipsis] or StringExpression(\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) represents a sequence of strings and symbolic string objects \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
StringForm::usage:= "StringForm(\"\(StyleBox(\"formatstring\", \"Arg\")\)\", \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) displays as \"\(StyleBox(\"formatstring\", \"Arg\")\)\" with `\(StyleBox(\"i\", \"Arg\")\)` being replaced by \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
StringMatch::usage:= "StringMatch(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"patt\", \"Arg\")\)) tests whether \"\(StyleBox(\"string\", \"Arg\")\)\" matches the string pattern \(StyleBox(\"patt\", \"Arg\")\).\nStringMatch({\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"p\", \"Arg\")\)) gives a list of results for each of the \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
StringPosition::usage:= "StringPosition(\"\(StyleBox(\"string\", \"Arg\")\)\", \"\(StyleBox(\"sub\", \"Arg\")\)\") gives a list of the character ranges at which \"\(StyleBox(\"sub\", \"Arg\")\)\" appears as a substring in \"\(StyleBox(\"string\", \"Arg\")\)\".\nStringPosition(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"patt\", \"Arg\")\)) gives all positions at which substrings matching the string expression \(StyleBox(\"patt\", \"Arg\")\) appear in \"\(StyleBox(\"string\", \"Arg\")\)\".\nStringPosition(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"patt\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) includes only the first \(StyleBox(\"n\", \"Arg\")\) occurrences of \(StyleBox(\"patt\", \"Arg\")\).\nStringPosition({\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"p\", \"Arg\")\)) gives the list of results for each of the \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
StringReplace::usage:= "StringReplace(\"string\", \(StyleBox(\"s\", \"Arg\")\) \[Rule] \(StyleBox(\"sp\", \"Arg\")\)) or StringReplace(\"string\", {\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\) \[Rule] \(StyleBox(\"sp\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\) \[Rule] \(StyleBox(\"sp\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) replaces the string expressions \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) by \(StyleBox(\"sp\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) wherever they appear as substrings in \"string\".\nStringReplace(\"string\", \(StyleBox(\"srules\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) does only the first \(StyleBox(\"n\", \"Arg\")\) replacements.\nStringReplace({\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"srules\", \"Arg\")\)) returns a list of results for each of the \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
StringSplit::usage:= "StringSplit(\"\(StyleBox(\"string\", \"Arg\")\)\") splits \"\(StyleBox(\"string\", \"Arg\")\)\" into a list of substrings separated by whitespace.\nStringSplit(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"patt\", \"Arg\")\)) splits into substrings separated by delimiters matching the string expression \(StyleBox(\"patt\", \"Arg\")\).\nStringSplit(\"\(StyleBox(\"string\", \"Arg\")\)\", {\(StyleBox(\"p\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"p\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) splits at any of the \(StyleBox(\"p\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nStringSplit(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"patt\", \"Arg\")\) \[Rule] \(StyleBox(\"val\", \"Arg\")\)) inserts \(StyleBox(\"val\", \"Arg\")\) at the position of each delimiter.\nStringSplit(\"\(StyleBox(\"string\", \"Arg\")\)\", {\(StyleBox(\"p\", \"Arg\")\)\(SubscriptBox(\"1\")\) \[Rule] \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(\"1\")\), \[Ellipsis]}) inserts \(StyleBox(\"v\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) at the position of each delimiter \(StyleBox(\"p\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nStringSplit(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"patt\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) splits into at most \(StyleBox(\"n\", \"Arg\")\) substrings.\nStringSplit({\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"p\", \"Arg\")\)) returns the list of results for each of the \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
StringTake::usage:= "StringTake(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"n\", \"Arg\")\)) returns the first \(StyleBox(\"n\", \"Arg\")\) characters of \"\(StyleBox(\"string\", \"Arg\")\)\".\nStringTake(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox({\"-\", \"n\"}, \"Arg\")\)) returns the last \(StyleBox(\"n\", \"Arg\")\) characters of \"\(StyleBox(\"string\", \"Arg\")\)\".\nStringTake(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"m\", \"Arg\")\) .. \(StyleBox(\"n\", \"Arg\")\)) returns \\substring of characters \(StyleBox(\"m\", \"Arg\")\) through \(StyleBox(\"n\", \"Arg\")\) of \"\(StyleBox(\"string\", \"Arg\")\)\".\nStringTake(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"m\", \"Arg\")\) .. \(StyleBox(\"n\", \"Arg\")\) .. \(StyleBox(\"d\", \"Arg\")\)) returns the characters \(StyleBox(\"m\", \"Arg\")\) through \(StyleBox(\"n\", \"Arg\")\) in steps of size \(StyleBox(\"d\", \"Arg\")\) of \"\(StyleBox(\"string\", \"Arg\")\)\".\nStringTake({\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"spec\", \"Arg\")\)) returns the list of results for each of the \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
StringToBoxes::usage:= "StringToBoxes(\"\(StyleBox(\"string\", \"Arg\")\)\") is a low-level function that parses \(StyleBox(\"pMath\", \"TI\")\) code to equivalent boxes."
StripOnInput::usage:= "StripOnInput is an option for box constructs that specifies whether they should be replaced by the content when used as input."
Style::usage:= "Style(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"options\", \"Arg\")\)) displays as \(StyleBox(\"expr\", \"Arg\")\) formated using the specified option settings.\nStyle(\(StyleBox(\"expr\", \"Arg\")\), \"\(StyleBox(\"style\", \"Arg\")\)\") uses the option settings for the specified named style in the current document.\nStyle(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"color\", \"Arg\")\)) displays using the specified color.\nStyle(\(StyleBox(\"expr\", \"Arg\")\), Bold) displays with fonts made bold.\nStyle(\(StyleBox(\"expr\", \"Arg\")\), Italic) displays with fonts made italic.\nStyle(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) displays with font size \(StyleBox(\"n\", \"Arg\")\)."
StyleBox::usage:= "StyleBox(\(StyleBox(\"boxes\", \"Arg\")\), \(StyleBox(\"options\", \"Arg\")\)) is a low-level construct which represents styled boxes in document expressions."
SubRules::usage:= "SubRules(\(StyleBox(\"f\", \"Arg\")\)) gives a list of transformation rules corresponding to all definitions \(StyleBox(\"f\", \"Arg\")\)(\[Ellipsis])(\[Ellipsis]) \[AssignDelayed] \[Ellipsis]."
Subscript::usage:= "Subscript(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)) displays as \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(StyleBox(\"y\", \"Arg\"))\).\nSubscript(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"y\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) displays as \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox({{StyleBox(\"y\", \"Arg\"), SubscriptBox(\"1\")}, \",\", {StyleBox(\"y\", \"Arg\"), SubscriptBox(\"2\")}, \",\", \"\\[Ellipsis]\"})\)."
SubscriptBox::usage:= "SubscriptBox(\(StyleBox(\"x\", \"Arg\")\)) is low-level construct that represents a single subscript \[Ellipsis]\(SubscriptBox(StyleBox(\"x\", \"Arg\"))\) in document expressions."
Subset::usage:= "Subset(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \[Ellipsis]) displays as \(StyleBox(\"a\", \"Arg\")\) \[Subset] \(StyleBox(\"b\", \"Arg\")\) \[Subset] \[Ellipsis]."
SubsetEqual::usage:= "SubsetEqual(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \[Ellipsis]) displays as \(StyleBox(\"a\", \"Arg\")\) \[SubsetEqual] \(StyleBox(\"b\", \"Arg\")\) \[SubsetEqual] \[Ellipsis]."
Subsuperscript::usage:= "Subsuperscript(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \(StyleBox(\"z\", \"Arg\")\)) displays as \(StyleBox(\"x\", \"Arg\")\)\(SubsuperscriptBox(StyleBox(\"y\", \"Arg\"), StyleBox(\"z\", \"Arg\"))\)."
SubsuperscriptBox::usage:= "SubsuperscriptBox(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)) is the low-level box representation for stacked sub- and superscripts \[Ellipsis]\(SubsuperscriptBox(StyleBox(\"x\", \"Arg\"), StyleBox(\"y\", \"Arg\"))\)."
Succeeds::usage:= "Succeeds(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[Succeeds] \(StyleBox(\"y\", \"Arg\")\) \[Succeeds] \[Ellipsis]."
SucceedsEqual::usage:= "SucceedsEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[SucceedsEqual] \(StyleBox(\"y\", \"Arg\")\) \[SucceedsEqual] \[Ellipsis]."
SucceedsTilde::usage:= "SucceedsTilde(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[SucceedsTilde] \(StyleBox(\"y\", \"Arg\")\) \[SucceedsTilde] \[Ellipsis]."
Sum::usage:= "Sum(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) is the sum \({UnderoverscriptBox(\"\\[Sum]\", {StyleBox(\"i\", \"Arg\"), \"=\", \"1\"}, {StyleBox(\"i\", \"Arg\"), SubscriptBox(StyleBox(\"max\", \"Arg\"))}), \" \", StyleBox(\"f\", \"Arg\")}\).\nSum(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) starts with \(StyleBox(\"i\", \"Arg\")\) = \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\).\nSum(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\) .. \(StyleBox(\"di\", \"Arg\")\)) uses steps \(StyleBox(\"di\", \"Arg\")\).\nSum(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] {\(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) uses successive values \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis].\nSum(\(StyleBox(\"f\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\) , \(StyleBox(\"j\", \"Arg\")\) \[Rule] \(StyleBox(\"j\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"j\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\) , \[Ellipsis]) evaluates the multiple sum \({UnderoverscriptBox(\"\\[Sum]\", {\"i\", \"=\", {\"i\", SubscriptBox(\"min\")}}, {\"i\", SubscriptBox(\"max\")}), \" \", {UnderoverscriptBox(\"\\[Sum]\", {\"j\", \"=\", {\"j\", SubscriptBox(\"min\")}}, {\"j\", SubscriptBox(\"max\")}), {\"\\[Ellipsis]\", \"f\"}}}\)."
Superscript::usage:= "Superscript(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)) displays as \(StyleBox(\"x\", \"Arg\")\)\(SuperscriptBox(StyleBox(\"y\", \"Arg\"))\)."
SuperscriptBox::usage:= "SuperscriptBox(\(StyleBox(\"x\", \"Arg\")\)) is the low-level box representation for superscripts \[Ellipsis]\(SuperscriptBox(StyleBox(\"x\", \"Arg\"))\)."
Superset::usage:= "Superset(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \[Ellipsis]) displays as \(StyleBox(\"a\", \"Arg\")\) \[Superset] \(StyleBox(\"b\", \"Arg\")\) \[Superset] \[Ellipsis]."
SupersetEqual::usage:= "SupersetEqual(\(StyleBox(\"a\", \"Arg\")\), \(StyleBox(\"b\", \"Arg\")\), \[Ellipsis]) displays as \(StyleBox(\"a\", \"Arg\")\) \[SupersetEqual] \(StyleBox(\"b\", \"Arg\")\) \[SupersetEqual] \[Ellipsis]."
Surd::usage:= "Surd(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) gives the real-valued \(StyleBox(\"n\", \"Arg\")\)\(SuperscriptBox(\"th\")\) root of \(StyleBox(\"x\", \"Arg\")\)."
SurdForm::usage:= "SurdForm is a low-level option for SqrtBox and RadicalBox that specifies appearence and whether the box is to be parsed as complex or real roots."
Switch::usage:= "Switch(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"form\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"value\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"form\", \"Arg\")\)\(SubscriptBox(\"2\")\), \(StyleBox(\"value\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) evaluates \(StyleBox(\"expr\", \"Arg\")\), then compares it with the \(StyleBox(\"form\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\), evaluating and returning the \(StyleBox(\"value\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) corresponding to the first match found."
Symbol::usage:= "Symbol is the head used for symbols."
SymbolName::usage:= "SymbolName(\(StyleBox(\"symbol\", \"Arg\")\)) gives the name of \(StyleBox(\"symbol\", \"Arg\")\) without its namespace part."
Symmetric::usage:= "Symmetric is an option which can be assigned to a symbol \(StyleBox(\"f\", \"Arg\")\) to indicate that the elements \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) in expressions of the form \(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) should automatically be sorted into canonical order. This property is accounted for in pattern matching."
Synchronize::usage:= "Synchronize({\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\)}, \(StyleBox(\"body\", \"Arg\")\)) synchronizes the evaluation of \(StyleBox(\"body\", \"Arg\")\)  with all symbols \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\). Exactly one thread at a time can enter such a synchronization block."
SynchronousUpdating::usage:= "SynchronousUpdating is an option for Dynamic which specifies whether or not to evaluate their contents synchronously."
Syntax::usage:= "Syntax is a symbol that is referred to when syntax error messages are generated."
SyntaxInformation::usage:= "SyntaxInformation(\(StyleBox(\"f\", \"Arg\")\)) gives information used to generate syntax coloring when \(StyleBox(\"f\", \"Arg\")\)(\[Ellipsis]) is entered as input."
SystemException::usage:= "SystemException(\"\(StyleBox(\"description\", \"Arg\")\)\") represents a serious exception such as \"OutOfMemory\"."
Table::usage:= "Table(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox({StyleBox(\"i\", \"Arg\"), SubscriptBox(StyleBox(\"max\", \"Arg\"))}, \"Arg\")\)) generates a list of \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\) copies of \(StyleBox(\"expr\", \"Arg\")\).\nTable(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) gives a list of the values of \(StyleBox(\"expr\", \"Arg\")\) when \(StyleBox(\"i\", \"Arg\")\) runs from 1 to \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\).\nTable(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\)) starts with \(StyleBox(\"i\", \"Arg\")\) = \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\).\nTable(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\) .. \(StyleBox(\"di\", \"Arg\")\)) uses steps \(StyleBox(\"di\", \"Arg\")\).\nTable(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] {\(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) uses successive values \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis].\nTable(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\) \[Rule] \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\) , \(StyleBox(\"j\", \"Arg\")\) \[Rule] \(StyleBox(\"j\", \"Arg\")\)\(SubscriptBox(StyleBox(\"min\", \"Arg\"))\) .. \(StyleBox(\"j\", \"Arg\")\)\(SubscriptBox(StyleBox(\"max\", \"Arg\"))\) , \[Ellipsis]) generates a nested list. The list associated with \(StyleBox(\"i\", \"Arg\")\) is outermost."
TagAssign::usage:= "\(StyleBox(\"f\", \"Arg\")\) /: \(StyleBox(\"lhs\", \"Arg\")\) \[Assign] \(StyleBox(\"rhs\", \"Arg\")\) assigns \(StyleBox(\"rhs\", \"Arg\")\) to be the value of \(StyleBox(\"lhs\", \"Arg\")\), and associates the assignment with the symbol \(StyleBox(\"f\", \"Arg\")\)."
TagAssignDelayed::usage:= "\(StyleBox(\"f\", \"Arg\")\) /: \(StyleBox(\"lhs\", \"Arg\")\) \[AssignDelayed] \(StyleBox(\"rhs\", \"Arg\")\) assigns \(StyleBox(\"rhs\", \"Arg\")\) to be the delayed value of \(StyleBox(\"lhs\", \"Arg\")\), and associates the assignment with the symbol \(StyleBox(\"f\", \"Arg\")\)."
TagBox::usage:= "TagBox(\(StyleBox(\"boxes\", \"Arg\")\), \(StyleBox(\"tag\", \"Arg\")\)) is a low-level box construct which displays as \(StyleBox(\"boxes\", \"Arg\")\) but maintains \(StyleBox(\"tag\", \"Arg\")\) to guide the interpretation of \(StyleBox(\"boxes\", \"Arg\")\) on input."
TagUnassign::usage:= "\(StyleBox(\"f\", \"Arg\")\) /: \(StyleBox(\"lhs\", \"Arg\")\) \[Assign]. removes any rules defined for \(StyleBox(\"lhs\", \"Arg\")\), associated with the symbol \(StyleBox(\"f\", \"Arg\")\)."
Take::usage:= "Take(\({StyleBox(\"list\", \"Arg\"), \",\", StyleBox(\"n\", \"Arg\")}\)) returns the first \(StyleBox(\"n\", \"Arg\")\) elements of \(StyleBox(\"list\", \"Arg\")\).\nTake(\({StyleBox(\"list\", \"Arg\"), \",\", {\"-\", StyleBox(\"n\", \"Arg\")}}\)) returns the last \(StyleBox(\"n\", \"Arg\")\) elements of \(StyleBox(\"list\", \"Arg\")\).\nTake(\({StyleBox(\"list\", \"Arg\"), \",\", {StyleBox(\"m\", \"Arg\"), \"..\", StyleBox(\"n\", \"Arg\")}}\)) returns the elements \(StyleBox(\"m\", \"Arg\")\) through \(StyleBox(\"n\", \"Arg\")\) of \(StyleBox(\"list\", \"Arg\")\).\nTake(\({StyleBox(\"list\", \"Arg\"), \",\", {{StyleBox(\"m\", \"Arg\"), \"..\", StyleBox(\"n\", \"Arg\")}, \"..\", StyleBox(\"s\", \"Arg\")}}\)) returns the elements \(StyleBox(\"m\", \"Arg\")\) through \(StyleBox(\"n\", \"Arg\")\) in steps of \(StyleBox(\"s\", \"Arg\")\) of \(StyleBox(\"list\", \"Arg\")\).\nTake(\({StyleBox(\"list\", \"Arg\"), \",\", {StyleBox(\"seq\", \"Arg\"), SubscriptBox(\"1\")}, \",\", {StyleBox(\"seq\", \"Arg\"), SubscriptBox(\"2\")}, \",\", \"\\[Ellipsis]\"}\)) gives a nested list in which elements specified by \(StyleBox({\"seq\", SubscriptBox(\"i\")}, \"Arg\")\) are taken at level \(StyleBox(\"i\", \"Arg\")\) in \(StyleBox(\"list\", \"Arg\")\)."
TakeDrop::usage:= "TakeDrop(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) gives {\(StyleBox(\"start\", \"Arg\")\), \(StyleBox(\"rest\", \"Arg\")\)} where \(StyleBox(\"start\", \"Arg\")\) contains the first \(StyleBox(\"n\", \"Arg\")\) elements of \(StyleBox(\"list\", \"Arg\")\) and \(StyleBox(\"rest\", \"Arg\")\) all remaining elements.\nTakeDrop(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"seq\", \"Arg\")\)) gives {Take(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"seq\", \"Arg\")\)), Drop(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"seq\", \"Arg\")\))}."
TakeWhile::usage:= "TakeWhile(\(StyleBox(\"list\", \"Arg\")\), \(StyleBox(\"crit\", \"Arg\")\)) returns the first \(StyleBox(\"n\", \"Arg\")\) elements \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) of \(StyleBox(\"list\", \"Arg\")\)  such that \(StyleBox(\"crit\", \"Arg\")\)(\(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)) is True, with \(StyleBox(\"n\", \"Arg\")\) being as large as possible."
Tan::usage:= "Tan(\(StyleBox(\"z\", \"Arg\")\)) gives the tangent of \(StyleBox(\"z\", \"Arg\")\)."
Tanh::usage:= "Tanh(\(StyleBox(\"z\", \"Arg\")\)) gives the hyperbolic tangent of \(StyleBox(\"z\", \"Arg\")\)."
Temporary::usage:= "Temporary is an attribute assigned to symbols which were created as local variables by Local."
TestPattern::usage:= "\(StyleBox(\"p\", \"Arg\")\) ? \(StyleBox(\"test\", \"Arg\")\) is a pattern object that stands for any expression which matches \(StyleBox(\"p\", \"Arg\")\), and on which the application of \(StyleBox(\"test\", \"Arg\")\) yields True."
TextShadow::usage:= "TextShadow is an option for Style and Section which specifies whether text should be drawn with a shadow behind it."
Thread::usage:= "Thread(\(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"args\", \"Arg\")\))) \[HighSixDoubleQuote]threads\[HighNineDoubleQuote] \(StyleBox(\"f\", \"Arg\")\) over any lists that appear in \(StyleBox(\"args\", \"Arg\")\).\nThread(\(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"args\", \"Arg\")\)), \(StyleBox(\"h\", \"Arg\")\)) threads \(StyleBox(\"f\", \"Arg\")\) over any objects with head \(StyleBox(\"h\", \"Arg\")\) that appear in \(StyleBox(\"args\", \"Arg\")\).\nThread(\(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"args\", \"Arg\")\)), \(StyleBox(\"h\", \"Arg\")\), \(StyleBox(\"n\", \"Arg\")\)) threads \(StyleBox(\"f\", \"Arg\")\) over the \(StyleBox(\"n\", \"Arg\")\)\(SuperscriptBox(\"th\")\) object in \(StyleBox(\"args\", \"Arg\")\) if it has head \(StyleBox(\"h\", \"Arg\")\).\nThread(\(StyleBox(\"f\", \"Arg\")\)(\(StyleBox(\"args\", \"Arg\")\)), \(StyleBox(\"h\", \"Arg\")\), \(StyleBox(\"m\", \"Arg\")\) .. \(StyleBox(\"n\", \"Arg\")\)) threads \(StyleBox(\"f\", \"Arg\")\) over objects with head \(StyleBox(\"h\", \"Arg\")\) that appear in between the \(StyleBox(\"m\", \"Arg\")\)\(SuperscriptBox(\"th\")\) and \(StyleBox(\"n\", \"Arg\")\)\(SuperscriptBox(\"th\")\) element in \(StyleBox(\"args\", \"Arg\")\)."
ThreadLocal::usage:= "ThreadLocal is an attribute that can be assigned to a symbol \(StyleBox(\"sym\", \"Arg\")\) to indicate that all subsequent assignments to \(StyleBox(\"sym\", \"Arg\")\) are local to the assigning thread and are invisible to other, parallel threads."
Through::usage:= "Through(\(StyleBox(\"p\", \"Arg\")\)(\(StyleBox(\"f\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"f\", \"Arg\")\)\(SubscriptBox(\"2\")\))(\(StyleBox(\"x\", \"Arg\")\))) gives \(StyleBox(\"p\", \"Arg\")\)(\(StyleBox(\"f\", \"Arg\")\)\(SubscriptBox(\"1\")\)(\(StyleBox(\"x\", \"Arg\")\)), \(StyleBox(\"f\", \"Arg\")\)\(SubscriptBox(\"2\")\)(\(StyleBox(\"x\", \"Arg\")\))).\nThrough(\(StyleBox(\"expr\", \"Arg\")\)) performs the transformation if \(StyleBox(\"h\", \"Arg\")\) occurs in the head of \(StyleBox(\"expr\", \"Arg\")\)."
Throw::usage:= "Throw(\(StyleBox(\"value\", \"Arg\")\)) stops execution and walks up the stack until a \(StyleBox(\"value\", \"Arg\")\) is caught by Catch."
Ticks::usage:= "Ticks is an option for graphics functions which specifies tick marks for axes."
TildeEqual::usage:= "TildeEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[TildeEqual] \(StyleBox(\"y\", \"Arg\")\) \[TildeEqual] \[Ellipsis]."
TildeFullEqual::usage:= "TildeFullEqual(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[TildeFullEqual] \(StyleBox(\"y\", \"Arg\")\) \[TildeFullEqual] \[Ellipsis]."
TildeTilde::usage:= "TildeTilde(\({StyleBox(\"x\", \"Arg\"), \",\", StyleBox(\"y\", \"Arg\"), \",\", \"\\[Ellipsis]\"}\)) displays as \(StyleBox(\"x\", \"Arg\")\) \[TildeTilde] \(StyleBox(\"y\", \"Arg\")\) \[TildeTilde] \[Ellipsis]."
TimeConstrained::usage:= "TimeConstrained(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"t\", \"Arg\")\)) evaluates \(StyleBox(\"expr\", \"Arg\")\), stopping after \(StyleBox(\"t\", \"Arg\")\) seconds.\nTimeConstrained(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"t\", \"Arg\")\), \(StyleBox(\"failexpr\", \"Arg\")\)) returns \(StyleBox(\"failexpr\", \"Arg\")\) if the time constraint is not met."
Times::usage:= "\(StyleBox(\"x\", \"Arg\")\) * \(StyleBox(\"y\", \"Arg\")\) * \(StyleBox(\"z\", \"Arg\")\), \(StyleBox(\"x\", \"Arg\")\) \[Times] \(StyleBox(\"y\", \"Arg\")\) \[Times] \(StyleBox(\"z\", \"Arg\")\) or \(StyleBox(\"x\", \"Arg\")\) \(StyleBox(\"y\", \"Arg\")\) \(StyleBox(\"z\", \"Arg\")\) represents a product of terms."
TimesBy::usage:= "\({StyleBox(\"x\", \"Arg\"), \"*=\", StyleBox(\"y\", \"Arg\")}\) multiplies \(StyleBox(\"x\", \"Arg\")\) by \(StyleBox(\"y\", \"Arg\")\) and returns the new value of \(StyleBox(\"x\", \"Arg\")\)."
TimeZone::usage:= "TimeZone is an option for DateList and related functions which specifies the time zone to use for dates and times."
Timing::usage:= "Timing(\(StyleBox(\"expr\", \"Arg\")\)) evaluates \(StyleBox(\"expr\", \"Arg\")\), and returns a list of the time in seconds used, together with the result obtained."
ToBoxes::usage:= "ToBoxes(\(StyleBox(\"expr\", \"Arg\")\)) generates boxes corresponding to the printed form of \(StyleBox(\"expr\", \"Arg\")\)."
ToCharacterCode::usage:= "ToCharacterCode(\"\(StyleBox(\"string\", \"Arg\")\)\") returns a list of the integer character codes corresponding to the characters in a string.\nToCharacterCode(\"\(StyleBox(\"string\", \"Arg\")\)\", \"\(StyleBox(\"encoding\", \"Arg\")\)\") uses the specified character encoding."
ToExpression::usage:= "ToExpression(\(StyleBox(\"input\", \"Arg\")\)) returns the expression obtained by interpreting strings or boxes as \(StyleBox(\"pMath\", \"TI\")\) input.\nToExpression(\(StyleBox(\"input\", \"Arg\")\), \(StyleBox(\"head\", \"Arg\")\)) wraps the head \(StyleBox(\"h\", \"Arg\")\) around the expression produced before evaluating it."
ToFileName::usage:= "ToFileName(\"\(StyleBox(\"directory\", \"Arg\")\)\", \"\(StyleBox(\"name\", \"Arg\")\)\") assembles a full file name from a directory and a file name.\nToFileName({\(StyleBox(\"dir\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"dir\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"name\", \"Arg\")\)) assembles a full file name from a hierarchy of directory names.\nToFileName({\(StyleBox(\"dir\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"dir\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) assembles a directory name from a hierarchy of directory names."
Tooltip::usage:= "Tooltip(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"label\", \"Arg\")\)) displays \(StyleBox(\"label\", \"Arg\")\) as a tooltip when the mouse pointer is in the area where \(StyleBox(\"expr\", \"Arg\")\) is displayed."
TooltipBox::usage:= "TooltipBox(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"label\", \"Arg\")\)) is a low-level construct which appears as \(StyleBox(\"expr\", \"Arg\")\) with a tooltip \(StyleBox(\"label\", \"Arg\")\)."
ToString::usage:= "ToString(\(StyleBox(\"expr\", \"Arg\")\)) converts \(StyleBox(\"expr\", \"Arg\")\) to a string."
Total::usage:= "Total(\(StyleBox(\"list\", \"Arg\")\)) calculates the total of the elements in \(StyleBox(\"list\", \"Arg\")\)."
TrackedSymbols::usage:= "TrackedSymbols is an option for Dynamic that specifies which symbols should trigger updates when their values are changed."
TransformationBox::usage:= "TransformationBox(\(StyleBox(\"boxes\", \"Arg\")\), BoxTransformation \[Rule] {{\(StyleBox(\"xx\", \"Arg\")\), \(StyleBox(\"xy\", \"Arg\")\)}, {\(StyleBox(\"yx\", \"Arg\")\), \(StyleBox(\"yy\", \"Arg\")\)}}) is a low-level construct which represents a box that is visually transformed using a transformation matrix."
TransformationFunction::usage:= "TransformationFunction(\(StyleBox(\"data\", \"Arg\")\)) represents a transformation function which applies geometric transformations."
TransformationMatrix::usage:= "TransformationMatrix(\(StyleBox(\"tfun\", \"Arg\")\)) returns the homogeneous matrix associated with a TransformationFunction object."
TranslationTransform::usage:= "TranslationTransform(\(StyleBox(\"v\", \"Arg\")\)) returns a TransformationFunction which translates points by a vector \(StyleBox(\"v\", \"Arg\")\)."
Transpose::usage:= "Transpose(\(StyleBox(\"list\", \"Arg\")\)) transposes the first two levels in \(StyleBox(\"list\", \"Arg\")\).\nTranspose(\(StyleBox(\"list\", \"Arg\")\), {\(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) transposes \(StyleBox(\"list\", \"Arg\")\) so that the \(StyleBox(\"k\", \"Arg\")\)\(SuperscriptBox(\"th\")\) level in \(StyleBox(\"list\", \"Arg\")\) is the \(StyleBox(\"n\", \"Arg\")\)\(SubscriptBox(StyleBox(\"k\", \"Arg\"))\)\(SuperscriptBox(\"th\")\) level in the result."
True::usage:= "True is the symbol for the boolean value true."
Try::usage:= "Try(\(StyleBox(\"body\", \"Arg\")\)) evaluates \(StyleBox(\"expr\", \"Arg\")\), and returns the result, unless messages were generated, in which case $Failed is returned immediately.\nTry(\(StyleBox(\"body\", \"Arg\")\), \(StyleBox(\"failexpr\", \"Arg\")\)) evaluates and returns \(StyleBox(\"failexpr\", \"Arg\")\) if a message is generated during the evaluation of \(StyleBox(\"body\", \"Arg\")\).\nTry(\(StyleBox(\"body\", \"Arg\")\), \(StyleBox(\"failexpr\", \"Arg\")\), {\({{\"s\", SubscriptBox(\"1\")}, \"::\", {\"t\", SubscriptBox(\"1\")}}\), s\(SubscriptBox(\"2\")\)::t\(SubscriptBox(\"2\")\), \[Ellipsis]}) stops only at the specified messages."
Unassign::usage:= "\(StyleBox(\"lhs\", \"Arg\")\) \[Assign] . removes any rules defined for \(StyleBox(\"lhs\", \"Arg\")\)."
Uncompress::usage:= "Uncompress(\"\(StyleBox(\"string\", \"Arg\")\)\") recovers an expression from its compressed representation generated by Compress.\nUncompress(\"\(StyleBox(\"string\", \"Arg\")\)\", \(StyleBox(\"head\", \"Arg\")\)) applies \(StyleBox(\"head\", \"Arg\")\)  to the uncompressed expression before returning it."
UncompressStream::usage:= "UncompressStream(\(StyleBox(\"stream\", \"Arg\")\)) returns a new binary stream object reads and uncompresses binary data from \(StyleBox(\"stream\", \"Arg\")\)."
Undefined::usage:= "Undefined is a symbol that represents a quantity whose value cannot be determined."
Underflow::usage:= "Underflow() represents a number too small to be represented explicitly on your computer system."
Underoverscript::usage:= "Underoverscript(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \(StyleBox(\"z\", \"Arg\")\)) display as \(UnderoverscriptBox(StyleBox(\"x\", \"Arg\"), StyleBox(\"y\", \"Arg\"), StyleBox(\"z\", \"Arg\"))\)."
UnderoverscriptBox::usage:= "UnderoverscriptBox(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \(StyleBox(\"z\", \"Arg\")\)) is the low-level box representation for \(UnderoverscriptBox(StyleBox(\"x\", \"Arg\"), StyleBox(\"y\", \"Arg\"), StyleBox(\"z\", \"Arg\"))\) in document expressions."
Underscript::usage:= "Underscript(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)) displays as \(UnderscriptBox(StyleBox(\"x\", \"Arg\"), StyleBox(\"y\", \"Arg\"))\)."
UnderscriptBox::usage:= "UnderscriptBox(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)) is the low-level box representation for \(UnderscriptBox(StyleBox(\"x\", \"Arg\"), StyleBox(\"y\", \"Arg\"))\) in document expressions."
Unequal::usage:= "\(StyleBox(\"lhs\", \"Arg\")\) != \(StyleBox(\"rhs\", \"Arg\")\) or \(StyleBox(\"lhs\", \"Arg\")\) \[NotEqual] \(StyleBox(\"rhs\", \"Arg\")\) returns False if \(StyleBox(\"lhs\", \"Arg\")\) and \(StyleBox(\"rhs\", \"Arg\")\) are equal."
Unevaluated::usage:= "Unevaluated(\(StyleBox(\"expr\", \"Arg\")\)) represents the unevaluated form of \(StyleBox(\"expr\", \"Arg\")\) when it appears as the argument to a function."
Unidentical::usage:= "\(StyleBox(\"lhs\", \"Arg\")\) =!= \(StyleBox(\"rhs\", \"Arg\")\) yields False if \(StyleBox(\"lhs\", \"Arg\")\) and \(StyleBox(\"rhs\", \"Arg\")\) are identical, and yields True otherwise."
Union::usage:= "Union(\(StyleBox(\"list\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"list\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) gives a sorted list of all the distinct elements that appear in any of the \(StyleBox(\"list\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nUnion(\(StyleBox(\"list\", \"Arg\")\)) gives a sorted version of a \(StyleBox(\"list\", \"Arg\")\),in which all duplicated elements have been dropped."
UnitVector::usage:= "UnitVector(\(StyleBox(\"k\", \"Arg\")\)) returns the 2-dimensional unit vector in direction \(StyleBox(\"k\", \"Arg\")\).\nUnitVector(\(StyleBox(\"n\", \"Arg\")\), \(StyleBox(\"k\", \"Arg\")\)) returns the \(StyleBox(\"n\", \"Arg\")\)-dimensional unit vector in direction \(StyleBox(\"k\", \"Arg\")\)."
Unprotect::usage:= "Unprotect(\(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) removes the attribute Protected for the symbols \(StyleBox(\"s\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\)."
UpArrow::usage:= "UpArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[UpArrow]\", \"y\".StyleBox(\"Arg\"), \"\[UpArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
Update::usage:= "Update(\(StyleBox(\"symbol\", \"Arg\")\)) tells \(StyleBox(\"pMath\", \"TI\")\) that hidden changes have been made which could affect values associated with a symbol."
UpdateInterval::usage:= "UpdateInterval is an option for Refresh which specifies at what time interval to do updates."
UpDownArrow::usage:= "UpDownArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[UpDownArrow]\", \"y\".StyleBox(\"Arg\"), \"\[UpDownArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
UpperLeftArrow::usage:= "UpperLeftArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[UpperLeftArrow]\", \"y\".StyleBox(\"Arg\"), \"\[UpperLeftArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
UpperRightArrow::usage:= "UpperRightArrow(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[UpperRightArrow]\", \"y\".StyleBox(\"Arg\"), \"\[UpperRightArrow]\", \"\[Ellipsis]\"}\) in StandardForm."
UpRules::usage:= "UpRules(\(StyleBox(\"f\", \"Arg\")\)) gives a list of transformation rules corresponding to all definitions \(StyleBox(\"h\", \"Arg\")\)(\[Ellipsis], \(StyleBox(\"f\", \"Arg\")\), \[Ellipsis]) \[AssignDelayed] \[Ellipsis] or \(StyleBox(\"h\", \"Arg\")\)(\[Ellipsis], \(StyleBox(\"f\", \"Arg\")\)(\[Ellipsis]), \[Ellipsis]) \[AssignDelayed] \[Ellipsis]."
UpTo::usage::= "UpTo(\(StyleBox(\"n\", \"Arg\")\)) is a specification which represents up to \(StyleBox(\"n\", \"Arg\")\) elements in functions like Take or Partition. If at least \(StyleBox(\"n\", \"Arg\")\) elements are available, \(StyleBox(\"n\", \"Arg\")\) will be used. Otherwise, only the available number of elements will be used."
Visible::usage:= "Visible is an option for Document and CreateDocument which specifies whether the window is visible."
Wait::usage:= "Wait(\(StyleBox(\"task\", \"Arg\")\)) waits for an asynchronous task to complete and returns its result."
Which::usage:= "Which(\(StyleBox(\"test\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"value\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"test\", \"Arg\")\)\(SubscriptBox(\"2\")\), \(StyleBox(\"value\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) evaluates the \(StyleBox(\"test\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) in turn and returns the \(StyleBox(\"value\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) corresponding to the first one that gives True."
While::usage:= "While(\(StyleBox(\"test\", \"Arg\")\), \(StyleBox(\"body\", \"Arg\")\)) evaluates \(StyleBox(\"test\", \"Arg\")\), then \(StyleBox(\"body\", \"Arg\")\), repeatedly, until \(StyleBox(\"test\", \"Arg\")\) first fails to give True."
White::usage:= "White represents the color white in graphics and style specifications."
Whitespace::usage:= "Whitespace represents a sequence of whitespace characters in StringExpression."
WhitespaceCharacter::usage:= "WhitespaceCharacter represents a single whitespace character in StringExpression."
WindowFrame::usage:= "WindowFrame is an option for Document which specifies the window's frame appearance and behaviour."
WindowTitle::usage:= "WindowTitle is an option for Document which specifies the document window\[HighNineQuote]s title."
With::usage:= "With({\(StyleBox(\"x\", \"Arg\")\) \[Assign] \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"0\")\), \(StyleBox(\"y\", \"Arg\")\) \[Assign] \(StyleBox(\"y\", \"Arg\")\)\(SubscriptBox(\"0\")\), \[Ellipsis]}, \(StyleBox(\"expr\", \"Arg\")\)) replaces occurrences of the symbols \(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\), \[Ellipsis] in \(StyleBox(/\\/(\"expr\", \" \"), \"Arg\")\)by \(StyleBox(\"x\", \"Arg\")\)\(SubscriptBox(\"0\")\), \(StyleBox(\"y\", \"Arg\")\)\(SubscriptBox(\"0\")\), \[Ellipsis] before evaluating \(StyleBox(\"expr\", \"Arg\")\)."
Word::usage:= "Word represents a word in Read, Find and related functions."
WordBoundary::usage:= "WordBoundary represents a boundary between words for purposes of matching in StringExpression."
WordCharacter::usage:= "WordCharacter represents a letter or digit character in StringExpression."
WorkingPrecision::usage:= "WorkingPrecision is an option for various numerical operations which specifies how many digits of precision should be maintained in internal computations."
Write::usage:= "Write(\(StyleBox(\"channel\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) writes expressions \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) in sequence, followed by a newline, to the specified output channel."
WriteString::usage:= "WriteString(\(StyleBox(\"channel\", \"Arg\")\), \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) converts the \(StyleBox(\"expr\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) to strings and then writes them in sequence to the specified output channel."
Xor::usage:= "Xor(\(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) is the logical XOR (exclusive OR) function. It gives True if an odd number of the \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) is True and the rest is False. It gives False if an even number of the \(StyleBox(\"e\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) is True and the rest is False."
Yellow::usage:= "Yellow represents the color yellow in graphics and style specifications."
Zeta::usage:= "Zeta(\(StyleBox(\"s\", \"Arg\")\)) gives the Riemann zeta function \(StyleBox(\"\\[Zeta]\", \"Arg\")\)(\(StyleBox(\"s\", \"Arg\")\))."
Developer`FileInformation::usage:= "FileInformation(\"\(StyleBox(\"file\", \"Arg\")\)\") gives various information about a file as a list of rules."
Developer`FromPackedArray::usage:= "FromPackedArray(\(StyleBox(\"expr\", \"Arg\")\)) unpacks \(StyleBox(\"expr\", \"Arg\")\) so that its internal representation is not a packed array."
Developer`GetDebugInfo::usage:= "GetDebugInfo(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) returns the debug meta information of \(StyleBox(\"expr\", \"Arg\")\)[\(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]]."
Developer`HasBuiltinCode::usage:= "HasBuiltinCode(\(StyleBox(\"symbol\", \"Arg\")\)) gives True if there is any builtin function associated with \(StyleBox(\"symbol\", \"Arg\")\), and False otherwise.\nDeveloper`HasBuiltinCode(\(StyleBox(\"symbol\", \"Arg\")\), \(StyleBox(\"kind\", \"Arg\")\)) tests for code of the specified \(StyleBox(\"kind\", \"Arg\")\) which can be one of DownRules, UpRules, SubRules or NRules, or a subset of these."
Developer`IsPackedArray::usage:= "IsPackedArray(\(StyleBox(\"expr\", \"Arg\")\)) gives True if \(StyleBox(\"expr\", \"Arg\")\) is a packed array, and False otherwise.\nIsPackedArray(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"type\", \"Arg\")\)) gives True if \(StyleBox(\"expr\", \"Arg\")\) is a packed array of elements of the specified \(StyleBox(\"type\", \"Arg\")\), and False otherwise."
Developer`PackedArrayForm::usage:= "PackedArrayForm(\(StyleBox(\"expr\", \"Arg\")\)) displays with packed arrays in \(StyleBox(\"expr\", \"Arg\")\) shown in summary form, without all their elements shown."
Developer`SetDebugInfoAt::usage:= "SetDebugInfoAt(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"info\", \"Arg\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) sets the debug meta information of \(StyleBox(\"expr\", \"Arg\")\)[\(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]] to \(StyleBox(\"info\", \"Arg\")\) if possible."
Developer`$SystemInformation::usage:= "$SystemInformation contains version information about the compiler and included third-party libraries during \(StyleBox(\"pMath\", \"TI\")\) build time."
Developer`ToPackedArray::usage:= "ToPackedArray(\(StyleBox(\"expr\", \"Arg\")\)) converts the internal representation of \(StyleBox(\"expr\", \"Arg\")\) to a packed array if possible.\nToPackedArray(\(StyleBox(\"expr\", \"Arg\")\), \(StyleBox(\"type\", \"Arg\")\)) tries to convert elements to \(StyleBox(\"type\", \"Arg\")\)."
Internal`CopySign::usage:= "CopySign(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)) returns the floating-point number \(StyleBox(\"x\", \"Arg\")\), but with sign of \(StyleBox(\"y\", \"Arg\")\)."
Internal`NextToward::usage:= "NextToward(\(StyleBox(\"x\", \"Arg\")\), \(StyleBox(\"y\", \"Arg\")\)) returns the next floating-point number after \(StyleBox(\"x\", \"Arg\")\) (in the precision of \(StyleBox(\"x\", \"Arg\")\)) in direction towards \(StyleBox(\"y\", \"Arg\")\)."
Internal`SignBit::usage:= "SignBit(\(StyleBox(\"x\", \"Arg\")\)) returns True if the floating-point number \(StyleBox(\"x\", \"Arg\")\) has negative sign and False if not."
