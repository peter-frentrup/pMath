$Aborted::uage:= "$Aborted is a special symbol that is returned when an evaluation is aborted."
$BaseDirectory::usage:= "$BaseDirectory gives the scripts directory of you installation."
$ByteOrdering::usage:= "$ByteOrdering gives the native ordering of bytes in binary data on your computer."
$CharacterEncoding::usage:= "$CharacterEncoding is the default character encoding for opening text files."
$CommandLine::usage:= "$CommandLine is a list of the command line arguments that \(\"pMath\".StyleBox(FontSlant->\"Italic\")\) was started with."
$DialogLevel::usage:= "$DialogLevel gives the current subsession level."
$DirectoryStack::usage:= "$DirectoryStack is the list of current directories used."
$Failed::usage:= "$Failed is a special symbol that is returned when a particular operation did not succed."
$History::usage:= "$History(-\(\"n\".StyleBox(\"Arg\")\)) gives the \(\"n\".StyleBox(\"Arg\")\)-th last evaluation result.\n$History(\(\"n\".StyleBox(\"Arg\")\)) gives the \(\"n\".StyleBox(\"Arg\")\)-th evaluation result."
$HistoryLength::usage:= "$HistoryLength defines the number of results to be remembered by $History."
$InitialDirectory::usage:= "$InitialDirectory gives the initial directory when \(\"pMath\".StyleBox(FontSlant->\"Italic\")\) was started."
$Input::usage:= "$Input gives the current input file name."
$Line::usage:= "$Line is the number of the current evaluation."
$MachineEpsilon::usage:= "$MachineEpsilon is the smallest positive-machine precision number which can be added to 1.0 such that the result is not rouded back to 1.0."
$MachinePrecision::usage:= "$MachinePrecision gives the number of decimal digits of precision used for machine precision numbers."
$MaxExtraPrecision::usage:= "$MaxExtraPrecision specifies the maximum extra number of decimal digits of precision used for iterative approximation."
$MaxMachineNumber::usage:= "$MaxMachineNumber is the largest machine-precision number which is representable on the computer system."
$MessageCount::usage:= "$MessageCount(\(\"symbol::tag\".StyleBox(\"Arg\")\)) gives the number of times the \(\"symbol::tag\".StyleBox(\"Arg\")\) message was genereted during the current evaluation."
$MinMachineNumber::usage:= "$MinMachineNumber is the smallest machine-precision number which is representable on the computer system."
$Namespace::usage:= "$Namespace defines the current namespace."
$NamespacePath::usage:= "$NamespacePath is a list of namespaces, after $Namespace, to search in trying to find a symbol that has been entered."
$NewMessage::usage:= "$NewMessage is a global variable which, if set, is applied to the symbol name and tag of messages that are requested but have not yet been defined."
$NewSymbol::usage:= "$NewSymbol is a global variable which, if set, is applied to the name and namespace of newly created symbols."
$Packages::usage:= "$Packages is a list of all loaded packages."
$PageWidth::usage:= "$PageWidth is a global variable that defines the approximate number of characters per line."
$Path::usage:= "$Path gives the default search path for Get and related functions."
$PathnameSeparator:= "$PathnameSeparator is the character you operating system uses to separate directory names."
$ProcessId::usage:= "$ProcessId gives the ID assigned to the current \(\"pMath\".StyleBox(FontSlant->\"Italic\")\) process by the operating system."
$ProcessorCount::usage:= "$ProcessorCount gives the number of CPUs on your computer."
$ProcessorType::usage:= "$ProcessorType gives a string that specifies your CPU type."
$SystemCharacterEncoding::usage:= "$SystemCharacterEncoding is the default character encoding on your system."
$SystemId::usage:= "$SystemId gives a string that specifies your operating system."
$ThreadId::usage:= "$ThreadId gives the ID assigned to the current thread by the operating system/threading library."
Abort::usage:= "Abort() aborts the current evaluation.\nAbort(\(\"task\".StyleBox(\"Arg\")\)) aborts another task."
Abs::usage:= "Abs(\(\"z\".StyleBox(\"Arg\")\)) gives the absolute value of the real or complex number \(\"z\".StyleBox(\"Arg\")\)."
Accuracy::usage:= "Accuracy(\(\"x\".StyleBox(\"Arg\")\)) gives the effective number of digits to the right of the decimal point in number \(\"x\".StyleBox(\"Arg\")\)."
All::usage:= "All is a setting used for certain options. In Part and related functions, All specifies all parts at a particular level."
Alternatives::usage:= "\({{\"p\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \"|\", {\"p\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \"|\", \"\[Ellipsis]\"}\) is a pattern object which represents any of the patterns \({\"p\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\)."
And::usage:= "\({{\"e\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \"&&\", {\"e\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \"&&\", \"\[Ellipsis]\"}\) is the logical AND function. It evaluates its arguments in order, giving False immediately if any of them is False, and True if all of them are True."
Antialiasing::usage:= "Antialiasing is an option for Section and Style for setting antialiasing of graphics on and off."
Append::usage:= "Apend(\({\"list\".StyleBox(\"Arg\"), \",\", \"elem\".StyleBox(\"Arg\")}\)) returns \(\"list\".StyleBox(\"Arg\")\) with \(\"elem\".StyleBox(\"Arg\")\) appended."
Apply::usage:= "\({\"f\".StyleBox(\"Arg\"), \"@@\", \"list\".StyleBox(\"Arg\")}\) or Apply(\({\"list\".StyleBox(\"Arg\"), \",\", \"f\".StyleBox(\"Arg\")}\)) returns \(\"list\".StyleBox(\"Arg\")\) with head \(\"f\".StyleBox(\"Arg\")\)."
ArcCos::usage:= "ArcCos(\(\"z\".StyleBox(\"Arg\")\)) gives the arc cosine \({{\"cos\",SuperscriptBox({\"-\", \"1\"})}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\) of the complex number \(\"z\".StyleBox(\"Arg\")\)."
ArcCosh::usage:= "ArcCosh(\(StyleBox(\"z\", BaseStyle -> \"Arg\")\)) gives the inverse hyperbolic cosine of \(StyleBox(\"z\", BaseStyle -> \"Arg\")\)."
ArcCot::usage:= "ArcCot(\(\"z\".StyleBox(\"Arg\")\)) gives the arc cotangent \({{\"cot\",SuperscriptBox({\"-\", \"1\"})}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\) of the complex number \(\"z\".StyleBox(\"Arg\")\)."
ArcCoth::usage:= "ArcCoth(\(StyleBox(\"z\", BaseStyle -> \"Arg\")\)) gives the inverse hyperbolic cotangent of \(StyleBox(\"z\", BaseStyle -> \"Arg\")\)."
ArcCsc::usage:= "ArcCsc(\(\"z\".StyleBox(\"Arg\")\)) gives the arc cosecant \({{\"csc\",SuperscriptBox({\"-\", \"1\"})}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\) of the complex number \(\"z\".StyleBox(\"Arg\")\)."
ArcCsch::usage:= "ArcCsch(\(StyleBox(\"z\", BaseStyle -> \"Arg\")\)) gives the inverse hyperbolic cosecant of \(StyleBox(\"z\", BaseStyle -> \"Arg\")\)."
ArcSec::usage:= "ArcSec(\(\"z\".StyleBox(\"Arg\")\)) gives the arc secant \({{\"sec\",SuperscriptBox({\"-\", \"1\"})}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\) of the complex number \(\"z\".StyleBox(\"Arg\")\)."
ArcSech::usage:= "ArcSech(\(StyleBox(\"z\", BaseStyle -> \"Arg\")\)) gives the inverse hyperbolic secant of \(StyleBox(\"z\", BaseStyle -> \"Arg\")\)."
ArcSin::usage:= "ArcSin(\(\"z\".StyleBox(\"Arg\")\)) gives the arc sine \({{\"sin\",SuperscriptBox({\"-\", \"1\"})}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\) of the complex number \(\"z\".StyleBox(\"Arg\")\)."
ArcSinh::usage:= "ArcSinh(\(StyleBox(\"z\", BaseStyle -> \"Arg\")\)) gives the inverse hyperbolic sine of \(StyleBox(\"z\", BaseStyle -> \"Arg\")\)."
ArcTan::usage:= "ArcTan(\(\"z\".StyleBox(\"Arg\")\)) gives the arc tangend \({{\"tan\",SuperscriptBox({\"-\", \"1\"})}, \"(\", \"z\".StyleBox(\"Arg\"), \")\"}\) of the complex number \(\"z\".StyleBox(\"Arg\")\)."
ArcTanh::usage:= "ArcTanh(\(StyleBox(\"z\", BaseStyle -> \"Arg\")\)) gives the inverse hyperbolic tangent of \(StyleBox(\"z\", BaseStyle -> \"Arg\")\)."
Arg::usage:= "Arg(\(\"z\".StyleBox(\"Arg\")\)) gives the argument of the complex number \(\"z\".StyleBox(\"Arg\")\)."
Array::usage:= "Array(\(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) generates a list of Length \(StyleBox(\"n\", BaseStyle -> \"Arg\")\) with elements \({\"1\", \",\", \"2\", \",\", \"\\[Ellipsis]\", \",\", StyleBox(\"n\", BaseStyle -> \"Arg\")}\).\nArray(\(StyleBox(/\\/(\"s\", \"..\", \"e\"), BaseStyle -> \"Arg\")\)) generates a list with elements \({StyleBox(\"s\", BaseStyle -> \"Arg\"), \",\", {StyleBox(\"s\", BaseStyle -> \"Arg\"), \"+\", \"1\"}, \",\", \"\\[Ellipsis]\", \",\", StyleBox(\"e\", BaseStyle -> \"Arg\")}\).\nArray(\(StyleBox(/\\/(\"s\", \"..\", \"e\", \"..\", \"d\"), BaseStyle -> \"Arg\")\)) uses steps of length \(StyleBox(\"d\", BaseStyle -> \"Arg\")\) (default 1).\nArray(\({StyleBox(\"f\", BaseStyle -> \"Arg\"), \",\", StyleBox(\"n\", BaseStyle -> \"Arg\")}\)) generates a list of length \(StyleBox(\"n\", BaseStyle -> \"Arg\")\) with elements \({StyleBox(\"f\", BaseStyle -> \"Arg\"), \"(\", StyleBox(\"i\", BaseStyle -> \"Arg\"), \")\"}\).\nArray(\({StyleBox(\"f\", BaseStyle -> \"Arg\"), \",\", {\"{\", {{StyleBox(\"n\", BaseStyle -> \"Arg\"), SubscriptBox(\"1\")}, \",\", {StyleBox(\"n\", BaseStyle -> \"Arg\"), SubscriptBox(\"2\")}, \",\", \"\\[Ellipsis]\"}, \"}\"}}\)) generates an \({{StyleBox(\"n\", BaseStyle -> \"Arg\"), SubscriptBox(\"1\")}, \"\\[Times]\", {StyleBox(\"n\", BaseStyle -> \"Arg\"), SubscriptBox(\"2\")}, \"\\[Times]\", \"\\[Ellipsis]\"}\) array of lists, with elements \({StyleBox(\"f\", BaseStyle -> \"Arg\"), \"(\", {{StyleBox(\"i\", BaseStyle -> \"Arg\"), SubscriptBox(\"1\")}, \",\", {StyleBox(\"i\", BaseStyle -> \"Arg\"), SubscriptBox(\"2\")}, \",\", \"\\[Ellipsis]\"}, \")\"}\).\nArray(\({StyleBox(\"f\", BaseStyle -> \"Arg\"), \",\", {\"{\", {{StyleBox(\"n\", BaseStyle -> \"Arg\"), SubscriptBox(\"1\")}, \",\", {StyleBox(\"n\", BaseStyle -> \"Arg\"), SubscriptBox(\"2\")}, \",\", \"\\[Ellipsis]\"}, \"}\"}, \",\", {\"{\", {{StyleBox(\"s\", BaseStyle -> \"Arg\"), SubscriptBox(\"1\")}, \",\", {StyleBox(\"s\", BaseStyle -> \"Arg\"), SubscriptBox(\"2\")}, \",\", \"\\[Ellipsis]\"}, \"}\"}}\)) generates a list using the index origins \({StyleBox(\"s\", BaseStyle -> \"Arg\"), StyleBox(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\")), BaseStyle -> \"Arg\")}\) (default 1).\nArray(\({StyleBox(\"f\", BaseStyle -> \"Arg\"), \",\", StyleBox(\"dims\", BaseStyle -> \"Arg\"), \",\", StyleBox(\"orgins\", BaseStyle -> \"Arg\"), \",\", StyleBox(\"h\", BaseStyle -> \"Arg\")}\)) uses head \(StyleBox(\"h\", BaseStyle -> \"Arg\")\), rather than List, for each level of the array."
Assign::usage:= "\({\"lhs\".StyleBox(\"Arg\"), \"\[Assign]\", \"rhs\".StyleBox(\"Arg\")}\) evaluates \(\"rhs\".StyleBox(\"Arg\")\) and assigns the rules to be the value of \(\"lhs\".StyleBox(\"Arg\")\) in subsequent evaluations.\n\({{\"{\", {{\"l\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"l\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}, \"\[Assign]\", {\"{\", {{\"r\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"r\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}}\) evaluates the \({\"r\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\) and assigns the results to be the values of the corresponding \({\"l\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\)."
AssignDelayed::usage:= "\({\"lhs\".StyleBox(\"Arg\"), \"\[AssignDelayed]\", \"rhs\".StyleBox(\"Arg\")}\) assigns \(\"rhs\".StyleBox(\"Arg\")\) to be the delayed value of \(\"lhs\".StyleBox(\"Arg\")\). \(\"rhs\".StyleBox(\"Arg\")\) is maintained in an unevaluated form. When \(\"lhs\".StyleBox(\"Arg\")\) appears, it is replaces by \(\"rhs\".StyleBox(\"Arg\")\), evaluated afresh each time."
Associative::usage:= "Associative is an attribute that can be assigned to a symbol \(\"f\".StyleBox(\"Arg\")\) to indicate that all expressions involving nested functions \(\"f\".StyleBox(\"Arg\")\) should be flattened out. This property is accounted for pattern matching."
Attributes::usage:= "Attributes(\(\"symbol\".StyleBox(\"Arg\")\)) gives the attributes for a symbol."
AutoDelete::usage:= "AutoDelete is an option for boxes that specifies whether a box is automatically deleted when its contents is edited."
Automatic::usage:= "Automatic represents an option or other value that is to be chosen automatically by a built-in function."
AutoNumberFormating::usage:= "AutoNumberFormating is an option for Section that specifies whether numbers should be pretty-printed before output."
AutoSpacing::usage:= "AutoSpacing is an option for Style and Section which specifies whether spaces between successive characters should be adjusted automatically."
Background::usage:= "Background is an option for boxes to specify its background color."
BaseStyle::usage:= "BaseStyle is an option for boxes to specify the base style to use for them."
Begin::usage:= "Begin(\"\(StyleBox(\"namespace\", BaseStyle -> \"Arg\")\) `\") resets the current namespace."
BeginPackage::usage:= "BeginPackage(\"\(StyleBox(\"namespace\", BaseStyle -> \"Arg\")\) `\") makes \(StyleBox(\"namespace\", BaseStyle -> \"Arg\")\)` and System` the only active namespaces.\nBeginPackage(\"\(StyleBox(\"namespace\", BaseStyle -> \"Arg\")\) `\", {\(StyleBox(\"need\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"need\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) additionally calls Get on the \(StyleBox({\"need\", SubscriptBox(\"i\")}, BaseStyle -> \"Arg\")\)."
BernoulliB::usage:= "BernoulliB(\(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) gives the \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)-th Bernoulli number \({\"B\", SubscriptBox(\"n\")}\)."
BinaryFormat::usage:= "BinaryFormat is an option for OpenRead and related functions which specifies that a stream should be opened in binary format, so that no textual interpretation of newlines and other data is done."
BinaryRead::usage:= "BinaryRead(\(\"stream\".StyleBox(\"Arg\")\)) reads one byte of raw data from a binary input stream and returns an integer from 0 to 255.\nBinaryRead(\({\"stream\".StyleBox(\"Arg\"), \",\", \"type\".StyleBox(\"Arg\")}\)) reads an object of the specified type.\nBinaryRead(\({\"stream\".StyleBox(\"Arg\"), \",\", {\"{\", {{\"type\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"type\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}}\)) reads a sequence of objects of the specified types."
BinaryWrite::usage:= "BinaryWrite(\({\"channel\".StyleBox(\"Arg\"), \",\", \"b\".StyleBox(\"Arg\")}\)) writes a byte of data, specified as an integer between 0 and 255.\nBinaryWrite(\({\"channel\".StyleBox(\"Arg\"), \",\", {\"{\", {{\"b\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"b\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}}\)) writes a sequence of bytes.\nBinaryWrite(\(\"channel\".StyleBox(\"Arg\")\), \"\(\"string\".StyleBox(\"Arg\")\)\") writes the raw sequence of characters in \(\"string\".StyleBox(\"Arg\")\), terminated with a 0 byte.\nBinaryWrite(\({\"channel\".StyleBox(\"Arg\"), \",\", \"x\".StyleBox(\"Arg\"), \",\", \"type\".StyleBox(\"Arg\")}\)) writes an object of the specified type.\nBinaryWrite(\({\"channel\".StyleBox(\"Arg\"), \",\", {\"{\", {{\"x\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"x\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}, \",\", \"type\".StyleBox(\"Arg\")}\)) writes a sequence of objects of the specified type.\nBinaryWrite(\({\"channel\".StyleBox(\"Arg\"), \",\", {\"{\", {{\"x\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"x\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}, \",\", {\"{\", {{\"type\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"type\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}}\)) writes a sequence of objects with a sequence of types."
Binomial::usage:= "Binomial(\(StyleBox(\"n\", BaseStyle -> \"Arg\")\), \(StyleBox(\"k\", BaseStyle -> \"Arg\")\)) gives the binomial coefficient \({\"(\", GridBox({{\"n\"}, {\"k\"}}), \")\"}\)."
Bold::usage:= "Bold represents a bold font weight."
Boole::uage:= "Boole(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) yields 1 if \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) is True and 0 if it is False."
BoxData::usage:= "BoxData(\(StyleBox(\"boxes\", BaseStyle -> \"Arg\")\)) represents the content of a non-text-Section."
BoxRotation::usage:= "BoxRotation is an option for RotationBox that specifies the angle by which its content should be rotated."
BoxTransformation::usage:= "BoxTransformation is an option for TransformatBox which specifies the affine transformation matrix to apply to its content."
Break::usage:= "Break() exits the nearest enclosing Do, For or While.\nBreak(\(\"n\".StyleBox(\"Arg\")\)) exits the \(\"n\".StyleBox(\"Arg\")\)-th nearest enclosing Do, For or While."
Button::usage:= "Button(\({\"label\".StyleBox(\"Arg\"), \",\", \"action\".StyleBox(\"Arg\")}\)) represents a button, that is labeled with \(\"label\".StyleBox(\"Arg\")\) and evaluates \(\"action\".StyleBox(\"Arg\")\) whenever it is pressed."
ButtonBox::usage:= "ButtonBox(\(\"boxes\".StyleBox(\"Arg\")\)) is a low-level box construct that represents a button in a document expression."
ButtonFrame::usage:= "ButtonFrame is an option for Button and ButtonBox which specifies the type of frame to display around a button."
ButtonFunction::usage:= "ButtonFunction is an option for ButtonBox which specifes the action to perform when the button is clicked."
ByteCount::usage:= "ByteCount(\(\"expr\".StyleBox(\"Arg\")\)) gives the number of bytes used internally to store \(\"expr\".StyleBox(\"Arg\")\)."
ByteOrdering::usage:= "ByteOrdering is an option for BinaryRead, BinaryWrite and related functions which specifies what ordering of bytes should be assumed for your computer."
Cases::usage:= "Cases(\({{\"{\", {{\"e\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"e\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}, \",\", \"pattern\".StyleBox(\"Arg\")}\)) gives a list of the \({\"e\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\) that match the pattern.\nCases(\({{\"{\", {{\"e\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"e\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}, \",\", {\"pattern\".StyleBox(\"Arg\"), \"->\", \"rhs\".StyleBox(\"Arg\")}}\)) gives a list of the \(\"rhs\".StyleBox(\"Arg\")\) corresponding to the \({\"e\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\) that match the pattern.\nCases(\({\"expr\".StyleBox(\"Arg\"), \",\", \"pattern\".StyleBox(\"Arg\"), \",\", \"levelspec\".StyleBox(\"Arg\")}\)) gives a list of all parts of \(\"expr\".StyleBox(\"Arg\")\) at levels specified by \(\"levelspec\".StyleBox(\"Arg\")\) which match the pattern.\nCases(\({\"expr\".StyleBox(\"Arg\"), \",\", {\"pattern\".StyleBox(\"Arg\"), \"->\", \"rhs\".StyleBox(\"Arg\")}, \",\", \"levelspec\".StyleBox(\"Arg\")}\)) gives the values of \(\"rhs\".StyleBox(\"Arg\")\) for parts which match the pattern.\nCases(\({\"expr\".StyleBox(\"Arg\"), \",\", \"pattern\".StyleBox(\"Arg\"), \",\", \"levelspec\".StyleBox(\"Arg\"), \",\", \"n\".StyleBox(\"Arg\")}\)) gives the first \(\"n\".StyleBox(\"Arg\")\) parts in \(\"expr\".StyleBox(\"Arg\")\) which match the pattern."
Catch::usage:= "Catch(\(\"expr\".StyleBox(\"Arg\")\)) returns the argument of the first Throw generated in the evaluation of \(\"expr\".StyleBox(\"Arg\")\).\nCatch(\({\"expr\".StyleBox(\"Arg\"), \",\", \"form\".StyleBox(\"Arg\")}\)) returns the argument of the first Throw generated in the evaluation of \(\"expr\".StyleBox(\"Arg\")\) if it matches \(\"form\".StyleBox(\"Arg\")\)."
Ceiling::usage:= "Ceiling(\(\"x\".StyleBox(\"Arg\")\)) gives the smallest integer greater than or equal to \(\"x\".StyleBox(\"Arg\")\).\nCeiling(\({\"x\".StyleBox(\"Arg\"), \",\", \"a\".StyleBox(\"Arg\")}\)) gives the smallest multiple of \(\"a\".StyleBox(\"Arg\")\) greater than or equal to \(\"x\".StyleBox(\"Arg\")\)."
Character::usage:= "Character represents a single character in Read."
CharacterEncoding::usage:= "CharacterEncoding is an option for OpenRead and related functions which the character encoding for text input and output."
Characters::usage:= "Characters(\(StyleBox(\"string\", BaseStyle -> \"Arg\")\)) gives a list of the characters in a string."
Chop::usage:= "Chop(\(\"expr\".StyleBox(\"Arg\")\)) replaces approximate real numbers in \(\"expr\".StyleBox(\"Arg\")\) which are close to zero by the exact integer 0."
CirclePlus::usage:= "CirclePlus(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[CirclePlus]\", \"y\".StyleBox(\"Arg\"), \"\[CirclePlus]\", \"\[Ellipsis]\"}\) in StandardForm."
CircleTimes::usage:= "CircleTimes(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[CircleTimes]\", \"y\".StyleBox(\"Arg\"), \"\[CircleTimes]\", \"\[Ellipsis]\"}\) in StandardForm."
Clear::usage:= "Clear(\({{\"symbol\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"symbol\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}\)) clears values and definitions for the \({\"symbol\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\).\nClear(\({{\"form\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"form\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}\)) clears values and definitions for all symbols whose names match any of the string patterns \({\"form\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\)."
ClearAll::usage:= "ClearAll(\({{\"symbol\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"symbol\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}\)) clears values, definitions, attributes and options for the \({\"symbol\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\).\nClear(\({{\"form\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"form\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}\)) clears values, definitions attributes and options for all symbols whose names match any of the string patterns \({\"form\".StyleBox(\"Arg\"), SubscriptBox(\"i\".StyleBox(\"Arg\"))}\)."
Close::usage:= "Close(\(\"stream\".StyleBox(\"Arg\")\)) closes a stream."
Colon::usage:= "Colon(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}\)) displays as \({\"x\".StyleBox(\"Arg\"), \"\[Colon]\", \"y\".StyleBox(\"Arg\"), \"\[Colon]\", \"\[Ellipsis]\"}\)."
Column::usage:= "Column(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\)) displays a \(StyleBox(\"list\", BaseStyle -> \"Arg\")\) of items in a column."
Complement::usage:= "Complement(\({{\"e\",SubscriptBox(\"all\")}.StyleBox(\"Arg\"), \",\", {\"e\".StyleBox(\"Arg\"),SubscriptBox(\"1\")}, \",\", {\"e\".StyleBox(\"Arg\"),SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}\)) gives the elements in \({\"e\",SubscriptBox(\"all\")}.StyleBox(\"Arg\")\) which are not in any of the \({\"e\",SubscriptBox(\"i\")}.StyleBox(\"Arg\")\)."
Complex::usage:= "Complex(\({\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\")}\)) represents a complex number with real part \(\"x\".StyleBox(\"Arg\")\) and imaginary part \(\"y\".StyleBox(\"Arg\")\)."
ComplexInfinity::usage:= "ComplexInfinity represents an infinite numerical quantity whose direction in the comlex plane is unknown."
Condition::usage:= "\({\"patt\".StyleBox(\"Arg\"), \"/?\", \"test\".StyleBox(\"Arg\")}\) is a pattern which matches only if the evaluation of \(\"test\".StyleBox(\"Arg\")\) yields True.\n\({\"lhs\".StyleBox(\"Arg\"), \":>\", {\"rhs\".StyleBox(\"Arg\"), \"/?\", \"test\".StyleBox(\"Arg\")}}\) represents a rule which applies only if the evaluation of \(\"test\".StyleBox(\"Arg\")\) yields True.\n\({\"lhs\".StyleBox(\"Arg\"), \"::=\", {\"rhs\".StyleBox(\"Arg\"), \"/?\", \"test\".StyleBox(\"Arg\")}}\) is a definition to be ued only if \(\"test\".StyleBox(\"Arg\")\) yields True."
ConstantArray::usage:= "ConstantArray(\(StyleBox(\"c\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) generates a list of \(StyleBox(\"n\", BaseStyle -> \"Arg\")\) copies of the element \(StyleBox(\"c\", BaseStyle -> \"Arg\")\).\nConstantArray(\(StyleBox(\"c\", BaseStyle -> \"Arg\")\), {\(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) generates an \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\) \xD7 \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\) \xD7 \[Ellipsis] array of nested lists containing the element \(StyleBox(\"c\", BaseStyle -> \"Arg\")\)."
Continue::usage:= "Continue() jumps to the next iteration of the neares enclosing For, Do or While loop."
CopyDirectory::usage:= "CopyDirectory(\({{\"dir\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"dir\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}}\)) copies the directory \({\"dir\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}\) to \({\"dir\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}\)."
CopyFile::usage:= "CopyFile(\({{\"file\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"file\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}}\)) copies \({\"file\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}\) to \({\"file\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}\)."
Cos::usage:= "Cos(\(\"z\".StyleBox(\"Arg\")\)) gives the cosine of \(\"z\".StyleBox(\"Arg\")\)."
Cosh::usage:= "Cosh(\(\"z\".StyleBox(\"Arg\")\)) gives the hyperbolic cosine of \(\"z\".StyleBox(\"Arg\")\)."
Cot::usage:= "Cot(\(\"z\".StyleBox(\"Arg\")\)) gives the cotangent of \(\"z\".StyleBox(\"Arg\")\)."
Coth::usage:= "Coth(\(\"z\".StyleBox(\"Arg\")\)) gives the hyperbolic cotangent of \(\"z\".StyleBox(\"Arg\")\)."
Count::usage:= "Count(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), \(StyleBox(\"pattern\", BaseStyle -> \"Arg\")\)) gives the number of elements in \(StyleBox(\"list\", BaseStyle -> \"Arg\")\) that match \(StyleBox(\"pattern\", BaseStyle -> \"Arg\")\).\nCount(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"pattern\", BaseStyle -> \"Arg\")\), \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\)) gives the total number of subexpressions matching \(StyleBox(\"pattern\", BaseStyle -> \"Arg\")\) that appear at the levels in \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) specified by \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\)."
CreateDirectory::usage:= "Create(\"\(\"dir\".StyleBox(\"Arg\")\) \") creates a directory with name \(\"dir\".StyleBox(\"Arg\")\)."
Cross::usage:= "Cross(\(StyleBox(\"a\", BaseStyle -> \"Arg\")\), \(StyleBox(\"b\", BaseStyle -> \"Arg\")\)) gives the vector cross product of \(StyleBox(\"a\", BaseStyle -> \"Arg\")\) and \(StyleBox(\"b\", BaseStyle -> \"Arg\")\)."
Csc::usage:= "Csc(\(\"z\".StyleBox(\"Arg\")\)) gives the cosecant of \(\"z\".StyleBox(\"Arg\")\)."
Csch::usage:= "Csch(\(\"z\".StyleBox(\"Arg\")\)) gives the hyperbolic cosecant of \(\"z\".StyleBox(\"Arg\")\)."
Decrement::usage:= "\({\"--\", StyleBox(\"x\", BaseStyle -> \"Arg\")}\) decreases the value of \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) by 1 and returns the new value.\n\({StyleBox(\"x\", BaseStyle -> \"Arg\"), \"-=\", \"y\"}\) decreses \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) by \(StyleBox(\"y\", BaseStyle -> \"Arg\")\) and returns the new value."
DeepHoldAll::usage:= "DeepHoldAll is an attribute that can be assigned to a symbol \(\"f\".StyleBox(\"Arg\")\) to indicate that all arguments \(\"x\".StyleBox(\"Arg\")\), \(\"y\".StyleBox(\"Arg\")\), \[Ellipsis] in \({{\"f\".StyleBox(\"Arg\"), \"(\", {\"a\".StyleBox(\"Arg\"), \",\", \"b\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}, \")\"}, \"(\", {\"x\".StyleBox(\"Arg\"), \",\", \"y\".StyleBox(\"Arg\"), \",\", \"\[Ellipsis]\"}, \")\"}\) are to be maintained in unevaluated form."
Default::usage:= "Default(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\)) gives the default value for arguments of the function \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) obtained with the ?\(StyleBox(\"x\", BaseStyle -> \"Arg\")\) pattern.\nDefault(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \(StyleBox(\"i\", BaseStyle -> \"Arg\")\)) gives the default value to use when ?\(StyleBox(\"x\", BaseStyle -> \"Arg\")\) appears as the \(StyleBox(\"i\", BaseStyle -> \"Arg\")\)\(SuperscriptBox(\"th\")\) argument of \(StyleBox(\"f\", BaseStyle -> \"Arg\")\).\nDefault(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \(StyleBox(\"i\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) gives the default value for the \(StyleBox(\"i\", BaseStyle -> \"Arg\")\)\(SuperscriptBox(\"th\")\) argument out of a total of \(StyleBox(\"n\", BaseStyle -> \"Arg\")\) arguments.\nDefault(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \[Ellipsis]):= \(StyleBox(\"val\", BaseStyle -> \"Arg\")\) defines the default value for arguments of \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)."
DefaultRules::usage:= "DefaultRules(\(\"f\".StyleBox(\"Arg\")\)) gives a list of transformation rules corresponding to the Defaul and Options definitions of \(\"f\".StyleBox(\"Arg\")\)."
DeleteContents::usage:= "DeleteContents is an option for DeleteDirectory which specifies whether the contents of directories should automatically be deleted."
DeleteDirectory::usage:= "DeleteDirectory(\"\(\"dir\".StyleBox(\"Arg\")\) \") deletes the specified directory."
DeleteFile::usage:= "DeleteFile(\"\(\"file\".StyleBox(\"Arg\")\) \") deletes a file."
Depth::usage:= "Depth(\(\"expr\".StyleBox(\"Arg\")\)) gives the maximum number of indices needed to specify any part of \(\"expr\".StyleBox(\"Arg\")\), plus one."
Det::usage:= "Det(\(StyleBox(\"m\", BaseStyle -> \"Arg\")\)) gives the determinant of a square matrix \(StyleBox(\"m\", BaseStyle -> \"Arg\")\)."
DiagonalMatrix::usage:= "DiagonalMatrix(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\) ) gives a matrix with elements \(StyleBox(\"list\", BaseStyle -> \"Arg\")\) on the leading diagonal, and 0 elsewhere.\nDiagonalMatrix(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), \(StyleBox(\"k\", BaseStyle -> \"Arg\")\)) gives a matrix with the elements of \(StyleBox(\"list\", BaseStyle -> \"Arg\")\) on the \(StyleBox(\"k\", BaseStyle -> \"Arg\")\)\(SuperscriptBox(\"th\")\) diagonal."
Dialog::usage:= "Dialog() enters a new subsession."
DigitCharacter::usage:= "DigitCharacter represents a digit character 0-9 in StringExpression."
Dimensions::usage:= "Dimensions(\(\"expr\".StyleBox(\"Arg\")\)) gives a list of dimensions of \(\"expr\".StyleBox(\"Arg\")\).\nDimensions(\({\"expr\".StyleBox(\"Arg\"), \",\", \"n\".StyleBox(\"Arg\")}\)) gives a list of dimensions of \(\"expr\".StyleBox(\"Arg\")\) down to level \(\"n\".StyleBox(\"Arg\")\)."
DirectedInfinity::usage:= "DirectedInfinity() represents an infinite numerical quantity whose direction in the comlex plane is unknown.\nDirectedInfinity(\(\"z\".StyleBox(\"Arg\")\)) represents an infinite numerical quantity that is a positive real multiple of the complex number \(\"z\".StyleBox(\"Arg\")\)."
Directory::usage:= "Directory() gives the current working directory."
DirectoryName::usage:= "DirectoryName(\"\(\"name\".StyleBox(\"Arg\")\) \") extracts the directory name from the specification for a file."
DivideBy::usage:= "\({\"x\", \"/=\", \"y\"}\) divides \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) by \(StyleBox(\"y\", BaseStyle -> \"Arg\")\) and returns the new value."
Do::usage:= "Do(\({\"expr\".StyleBox(\"Arg\"), \",\", {\"i\", SubscriptBox(\"max\")}.StyleBox(\"Arg\")}\)) evaluates \(\"expr\".StyleBox(\"Arg\")\)  \({\"i\", SubscriptBox(\"max\")}.StyleBox(\"Arg\")\) times.\nDo(\({\"expr\".StyleBox(\"Arg\"), \",\", {\"i\".StyleBox(\"Arg\"), \"->\", {\"i\", SubscriptBox(\"max\")}.StyleBox(\"Arg\")}}\)) evaluates \(\"expr\".StyleBox(\"Arg\")\) with the vaiable \(\"i\".StyleBox(\"Arg\")\) successively taking the values 1 through \({\"i\", SubscriptBox(\"max\")}.StyleBox(\"Arg\")\).\nDo(\({\"expr\".StyleBox(\"Arg\"), \",\", {\"i\".StyleBox(\"Arg\"), \"->\", {{\"i\", SubscriptBox(\"min\")}.StyleBox(\"Arg\"), \"..\", {\"i\", SubscriptBox(\"max\")}.StyleBox(\"Arg\")}}}\)) evaluates \(\"expr\".StyleBox(\"Arg\")\) with the vaiable \(\"i\".StyleBox(\"Arg\")\) successively taking the values \({\"i\", SubscriptBox(\"min\")}.StyleBox(\"Arg\")\) through \({\"i\", SubscriptBox(\"max\")}.StyleBox(\"Arg\")\).\nDo(\({\"expr\".StyleBox(\"Arg\"), \",\", {\"i\".StyleBox(\"Arg\"), \"->\", {{{\"i\", SubscriptBox(\"min\")}.StyleBox(\"Arg\"), \"..\", {\"i\", SubscriptBox(\"max\")}.StyleBox(\"Arg\")}, \"..\", \"di\".StyleBox(\"Arg\")}}}\)) uses steps \(\"di\".StyleBox(\"Arg\")\).\nDo(\({\"expr\".StyleBox(\"Arg\"), \",\", {\"i\".StyleBox(\"Arg\"), \"->\", {\"{\", {{\"i\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"i\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"},\"}\"}}}\)) uses the successive values \({\"i\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}\), \({\"i\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}\), \(\"\[Ellipsis]\"\)."
Document::usage:= "Document(\({\"{\", {{\"section\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"section\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}, \"}\"}\)) is a low-level construct that represents a document manipulated by the \(\"pMath\".StyleBox(FontSlant->\"Italic\")\) front-end."
DocumentApply::usage:= "DocumentApply(\(StyleBox(\"document\", BaseStyle -> \"Arg\")\), \(StyleBox(\"data\", BaseStyle -> \"Arg\")\)) writes \(StyleBox(\"data\", BaseStyle -> \"Arg\")\) into a document at the current selection, replacing the first selection placeholder in \(StyleBox(\"data\", BaseStyle -> \"Arg\")\) by the current selection and then setting the cursor just after the data written."
Documents::usage:= "Documents() gives a list of all documents currently opened in the front-end."
Dot::usage:= "Dot(\(StyleBox(\"a\", BaseStyle -> \"Arg\")\), \(StyleBox(\"b\", BaseStyle -> \"Arg\")\), \[Ellipsis]) gives the products of vectors, matrices and tensors."
DownRules::usage:= "DownRules(\(\"f\".StyleBox(\"Arg\")\)) gives a list of transformation rules corresponding to all definitions \({{\"f\".StyleBox(\"Arg\"), \"(\", \"\[Ellipsis]\", \")\"}, \"::=\", \"\[Ellipsis]\"}\)."
Drop::usage:= "Drop(\({\"list\".StyleBox(\"Arg\"), \",\", \"n\".StyleBox(\"Arg\")}\)) gives \(\"list\".StyleBox(\"Arg\")\) with the first \(\"n\".StyleBox(\"Arg\")\) elements dropped.\nDrop(\({\"list\".StyleBox(\"Arg\"), \",\", {\"-\", \"n\".StyleBox(\"Arg\")}}\)) gives \(\"list\".StyleBox(\"Arg\")\) with the last \(\"n\".StyleBox(\"Arg\")\) elements dropped.\nDrop(\({\"list\".StyleBox(\"Arg\"), \",\", {\"m\".StyleBox(\"Arg\"), \"..\", \"n\".StyleBox(\"Arg\")}}\)) gives \(\"list\".StyleBox(\"Arg\")\) with the elements \(\"m\".StyleBox(\"Arg\")\) through \(\"n\".StyleBox(\"Arg\")\) dropped.\nDrop(\({\"list\".StyleBox(\"Arg\"), \",\", {{\"m\".StyleBox(\"Arg\"), \"..\", \"n\".StyleBox(\"Arg\")}, \"..\", \"s\".StyleBox(\"Arg\")}}\)) gives \(\"list\".StyleBox(\"Arg\")\) with the elements \(\"m\".StyleBox(\"Arg\")\) through \(\"n\".StyleBox(\"Arg\")\) in steps of \(\"s\".StyleBox(\"Arg\")\) dropped.\nDrop(\({\"list\".StyleBox(\"Arg\"), \",\", {\"seq\".StyleBox(\"Arg\"), SubscriptBox(\"1\")}, \",\", {\"seq\".StyleBox(\"Arg\"), SubscriptBox(\"2\")}, \",\", \"\[Ellipsis]\"}\)) gives a nested list in which elements specified by \({\"seq\", SubscriptBox(\"i\")}.StyleBox(\"Arg\")\) have been dropped at level \(\"i\".StyleBox(\"Arg\")\) in \(\"list\".StyleBox(\"Arg\")\)."
Dynamic::usage:= "Dynamic(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) represents an object that displays the dynamically updated current value of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\).\nDynamic(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)) continually evaluates \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)(\(StyleBox(\"val\", BaseStyle -> \"Arg\")\)) during interactive changing or edition of \(StyleBox(\"val\", BaseStyle -> \"Arg\")\)."
DynamicBox::usage:= "DynamicBox(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) is a low-level construct that reprtesents content which updates dynamically in the front end."
E::usage:= "E is the exponential constant \[ScriptE] (base of the natural logarithm) with numerical value \[TildeTilde] 2.71828."
Editable::usage:= "Editable is an option for displayed objects which specifies whether their content can be edited interactively by the user."
Emit::usage:= "Emit(\(StyleBox(\"e\", BaseStyle -> \"Arg\")\)) specifies that \(StyleBox(\"e\", BaseStyle -> \"Arg\")\) should be collected by the nearest enclosing Gather.\nEmit(\(StyleBox(\"e\", BaseStyle -> \"Arg\")\), \(StyleBox(\"tag\", BaseStyle -> \"Arg\")\)) specifies that \(StyleBox(\"e\", BaseStyle -> \"Arg\")\) should be collected by the nearest enclosing Gather whose pattern matches \(StyleBox(\"tag\", BaseStyle -> \"Arg\")\)."
End::usage:= "End() returns the current namespace and reverts to a previous one."
EndOfFile::usage:= "EndOfFile is returned by Read and related functions when it reaches the end of file."
EndOfLine::usage:= "EndOfLine represents the end of a line in a string in StringMatch and related function."
EndOfString::usage:= "EndOfString represents the end of a string in StringMatch and related function."
EndPackage::usage:= "EndPackage() restores $Namespace and $NamespacePath to their values before the preceding BeginPackage, and preprend the current namespace to the list $NamespacePath."
Environment::usage:= "Environment(\"\(StyleBox(\"var\", BaseStyle -> \"Arg\")\) \") gives the value of an operating system environment variable.\nEnvironment() gives a list of all operating system environment variables in the form \({\"{\", {{{\"key\", SubscriptBox(\"1\")}, \"\\[Rule]\", {\"value\", SubscriptBox(\"1\")}}, \",\", {{\"key\", SubscriptBox(\"2\")}, \"\\[Rule]\", {\"value\", SubscriptBox(\"2\")}}, \",\", \"\\[Ellipsis]\"}, \"}\"}\)"
Equal::usage:= "\(StyleBox(\"lhs\", BaseStyle -> \"Arg\")\) = \(StyleBox(\"rhs\", BaseStyle -> \"Arg\")\) returns true if \(StyleBox(\"lhs\", BaseStyle -> \"Arg\")\) and \(StyleBox(\"rhs\", BaseStyle -> \"Arg\")\) are equal."
EulerGamma::usage:= "EulerGamma is Euler's constant \(\"\\[Gamma]\"\) with numerical value \[TildeTilde] 0.577216."
Evaluatable::usage:= "Evaluatable is an option for Section which specifies whether a section can be used as input to be evaluated by \(StyleBox(\"pMath\", FontSlant -> Italic)\)."
Evaluate::usage:= "Evaluate(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) causes \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) to evaluate even if it occurs as the argument of a function whose attributes specify that it should be held unevaluated."
EvaluateDelayed::usage:= "EvaluateDelayed(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"t\", BaseStyle -> \"Arg\")\)) causes \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) to be evaluated in \(StyleBox(\"t\", BaseStyle -> \"Arg\")\) seconds."
EvaluationSequence::usage:= "\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\) ; \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\) ; \[Ellipsis] evaluates the \(StyleBox({\"expr\", SubscriptBox(\"i\")}, BaseStyle -> \"Arg\")\) in order and gives the last one as the result."
Except::usage:= "Except(\(StyleBox(\"c\", BaseStyle -> \"Arg\")\)) is a pattern which represents any expression except one that matches \(StyleBox(\"c\", BaseStyle -> \"Arg\")\).\nExcept(\(StyleBox(\"c\", BaseStyle -> \"Arg\")\), \(StyleBox(\"p\", BaseStyle -> \"Arg\")\)) represents any expression that matches \(StyleBox(\"p\", BaseStyle -> \"Arg\")\) but not \(StyleBox(\"c\", BaseStyle -> \"Arg\")\)."
Exp::usage:= "Exp(\(StyleBox(\"z\", BaseStyle -> \"Arg\")\)) is the exponential function."
Expand::usage:= "Expand(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) expands out products and positive integer powers in \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)."
ExpandAll::usage:= "ExpandAll(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) expands out products and integer powers in any part of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)."
Expression::usage:= "Expression is a symbol that represents \(StyleBox(\"pMath\", FontSlant -> \"Italic\")\) expressions in Read and related functions."
Extract::usage:= "Extract(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"list\", BaseStyle -> \"Arg\")\)) extracts the part of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) at the position specified by \(StyleBox(\"list\", BaseStyle -> \"Arg\")\).\nExtract(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"list\", BaseStyle -> \"Arg\")\), \(StyleBox(\"h\", BaseStyle -> \"Arg\")\)) wraps the extracted part with the head \(StyleBox(\"h\", BaseStyle -> \"Arg\")\)."
Factorial::usage:= "\(StyleBox(\"n\", BaseStyle -> \"Arg\")\)! gives the factorial of \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)."
Factorial2::usage:= "\(StyleBox(\"n\", BaseStyle -> \"Arg\")\)!! gives the double factorial of \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)."
False::usage:= "False is the symbol for the boolean value false."
File::usage:= "File represents an ordinary file as a result of FileType."
FileByteCount::usage:= "FileByteCount(\"\(StyleBox(\"file\", BaseStyle -> \"Arg\")\)\") gives the number of bytes in a file."
FileNames::usage:= "FileNames(\\) lists all files in the current working directory.\nFileNames(\(StyleBox(\"form\", BaseStyle -> \"Arg\")\)) lists all files in the current directory whose names match the string pattern \(StyleBox(\"form\", BaseStyle -> \"Arg\")\).\nFileNames({\(StyleBox(\"form\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"form\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) lists files whose names match any of the \(StyleBox({\"form\", SubscriptBox(\"i\")}, BaseStyle -> \"Arg\")\).\nFileName(\(StyleBox(\"forms\", BaseStyle -> \"Arg\")\), {\(StyleBox(\"dir\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"dir\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) lists files with names matching \(StyleBox(\"forms\", BaseStyle -> \"Arg\")\) in any of the \(StyleBox({\"dir\", SubscriptBox(\"i\")}, BaseStyle -> \"Arg\")\)."
FileType::usage:= "FileType(\"\(StyleBox(\"file\", BaseStyle -> \"Arg\")\)\") gives the type of a file: File, Directory, Special or None."
FillBox::usage:= "FillBox(\(StyleBox(\"content\", BaseStyle -> \"Arg\")\)) is a box that fills up the whole line by repeating \(StyleBox(\"content\", BaseStyle -> \"Arg\")\)."
Finally::usage:= "Finally(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"end\", BaseStyle -> \"Arg\")\)) evaluates \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) and then \(StyleBox(\"end\", BaseStyle -> \"Arg\")\), even if an exception occurs during the evaluation of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)."
Find::usage:= "Find(\(StyleBox(\"stream\", BaseStyle -> \"Arg\")\), \(StyleBox(\"form\", BaseStyle -> \"Arg\")\)) finds the first line in \(StyleBox(\"stream\", BaseStyle -> \"Arg\")\) that matches \(StyleBox(\"form\", BaseStyle -> \"Arg\")\)."
FindList::usage:= "FindList(\(StyleBox(\"file\", BaseStyle -> \"Arg\")\), \(StyleBox(\"form\", BaseStyle -> \"Arg\")\)) gives a list of all lines in \(StyleBox(\"file\", BaseStyle -> \"Arg\")\) that match \(StyleBox(\"form\", BaseStyle -> \"Arg\")\).\nFindList(\(StyleBox(\"file\", BaseStyle -> \"Arg\")\), \(StyleBox(\"form\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) returns the first \(StyleBox(\"n\", BaseStyle -> \"Arg\")\) occurences."
First::usage:= "First(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) gives the first element in \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)."
Flatten::usage:= "Flatten(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\)) flattens out nested lists.\nFlatten(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) flattens to level \(StyleBox(\"n\", BaseStyle -> \"Arg\")\).\nFlatten(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\), \(StyleBox(\"h\", BaseStyle -> \"Arg\")\)) flattens subexpressions with head \(StyleBox(\"h\", BaseStyle -> \"Arg\")\)."
Floor::usage:= "Floor(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) gives the largest integer less than or equal to \(StyleBox(\"x\", BaseStyle -> \"Arg\")\).\nFloor(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\), \(StyleBox(\"a\", BaseStyle -> \"Arg\")\)) gives the largest multiple of \(StyleBox(\"a\", BaseStyle -> \"Arg\")\) less than or equal to \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)."
Fold::usage:= "Fold(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) gives the last element of FoldList(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \(StyleBox(\"x\", BaseStyle -> \"Arg\")\))."
FoldList::usage:= "FoldList({\(StyleBox(\"a\", BaseStyle -> \"Arg\")\), \(StyleBox(\"b\", BaseStyle -> \"Arg\")\), \[Ellipsis]}, \(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) gives {\(StyleBox(\"x\", BaseStyle -> \"Arg\")\), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\), \(StyleBox(\"a\", BaseStyle -> \"Arg\")\)), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\)(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\), \(StyleBox(\"a\", BaseStyle -> \"Arg\")\)), \(StyleBox(\"b\", BaseStyle -> \"Arg\")\)), \[Ellipsis]}."
FontColor::usage:= "FontColor is an option for Section, Style and related constructs which specifies the default color in which to render text."
FontFamily::usage:= "FontFamily is an option for Section, Style and related constructs which specifies the font family in which text should be rendered."
FontSize::usage:= "FontSize is an option for Section, Style and related constructs which specifies the default font size in which to render text."
FontSlant::usage:= "FontSlant is an option for Section, Style and related constructs which specifies how slanted characters in text should be."
FontWeight::usage:= "FontWeight is an option for Style, Section and related constructs which specifies how heavy characters in a font should be."
For::usage:= "For(\(StyleBox(\"start\", BaseStyle -> \"Arg\")\), \(StyleBox(\"test\", BaseStyle -> \"Arg\")\), \(StyleBox(\"incr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"body\", BaseStyle -> \"Arg\")\)) executes \(StyleBox(\"start\", BaseStyle -> \"Arg\")\), then repeatedly evaluates \(StyleBox(\"body\", BaseStyle -> \"Arg\")\) and \(StyleBox(\"incr\", BaseStyle -> \"Arg\")\) until \(StyleBox(\"test\", BaseStyle -> \"Arg\")\) fails to give True."
FormatRules::usage:= "FormatRules(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\)) gives a list of formating rules for the symbol \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) and expressions of the form \({StyleBox(\"f\", BaseStyle -> \"Arg\"), \"(\", \"\\[Ellipsis]\", \")\"}\)."
FractionBox::usage:= "FractionBox(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\), \(StyleBox(\"y\", BaseStyle -> \"Arg\")\)) is a low-level construct that represents \(FractionBox(StyleBox(\"x\", BaseStyle -> \"Arg\"), StyleBox(\"y\", BaseStyle -> \"Arg\"))\) in document expression."
Framed::usage:= "Framed(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) displays \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) inside a frame."
FrontEndObject::usage:= "FrontEndObject(\[Ellipsis]) represents any user interface object in \(StyleBox(\"pMath\", FontSlant -> Italic)\) code."
FrontEndTokenExecute::usage:= "FrontEndTokenExecute(\\\"\(StyleBox(\"cmd\", BaseStyle -> \"Arg\")\) \\\") executes the specified front end command token, typically corresponding to a front end menu item."
FullForm::usage:= "FullForm(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) prints as the full form of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), without any special syntax."
Function::usage:= "Function(\(StyleBox(\"body\", BaseStyle -> \"Arg\")\)) or \(StyleBox(\"body\", BaseStyle -> \"Arg\")\) & is a pure funtion. The formal parameters are # (or #1), #2, etc.\nFunction({\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"body\", BaseStyle -> \"Arg\")\)) is a pure function with a list of named formal parameters.\nFunction(\(StyleBox(\"params\", BaseStyle -> \"Arg\")\), \(StyleBox(\"body\", BaseStyle -> \"Arg\")\), \(StyleBox(\"attr\", BaseStyle -> \"Arg\")\)) is a pure function with attributes \(StyleBox(\"attr\", BaseStyle -> \"Arg\")\)."
Gamma::usage:= "Gamma(\(StyleBox(\"z\", BaseStyle -> \"Arg\")\)) is the Euler gamma function \({\"\\[CapitalGamma]\", \"(\", StyleBox(\"z\", BaseStyle -> \"Arg\"), \")\"}\)."
Gather::usage:= "Gather(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) returns the value of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) together with a list of all expressions to which Emit has been applied during its evaluation.\nGather(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"patt\", BaseStyle -> \"Arg\")\)) gathers only expressions emitted with tags that match \(StyleBox(\"patt\", BaseStyle -> \"Arg\")\)."
GCD::usage:= "GCD(\(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) returns the greatest common divisor of the integers \(StyleBox({\"n\", SubscriptBox(\"i\")}, BaseStyle -> \"Arg\")\)."
General::usage:= "General is a symbol to which general system messages are attached."
Get::usage:= "\({\"<<\", StyleBox(\"name\", BaseStyle -> \"Arg\")}\) opens a file, evaluates each expression in it, and returns the last one. When \(StyleBox(\"name\", BaseStyle -> \"Arg\")\) is a namespace which has already been included, nothing happens."
Goto::usage:= "Goto(\(StyleBox(\"tag\", BaseStyle -> \"Arg\")\)) searches Label(\(StyleBox(\"tag\", BaseStyle -> \"Arg\")\)) and transfers control to that point."
GrayLevel::usage:= "GrayLevel(\(StyleBox(\"level\", BaseStyle -> \"Arg\")\)) is a directive which specifies a gray-level intensity to use for graphics and text."
Greater::usage:= "\({\"x\", \">\", \"y\"}\) yields True if \(\"x\"\) is determined to be greather than \(\"y\"\).\n\({{\"x\", SubscriptBox(\"1\")}, \">\", {\"x\", SubscriptBox(\"2\")}, \">\", {\"x\", SubscriptBox(\"3\")}}\) yields True if the \({\"x\", SubscriptBox(\"i\")}\) form a strictly decreasing sequence."
GreaterEqual::usage:= "\({\"x\", \">=\", \"y\"}\) or \({\"x\", \"\\[GreaterEqual]\", \"y\"}\) yields True if \(\"x\"\) is determined to be greather than or equal to \(\"y\"\).\n\({{\"x\", SubscriptBox(\"1\")}, \"\\[GreaterEqual]\", {\"x\", SubscriptBox(\"2\")}, \"\\[GreaterEqual]\", {\"x\", SubscriptBox(\"3\")}}\) yields True if the \({\"x\", SubscriptBox(\"i\")}\) form a non-increasing sequence."
Grid::usage:= "Grid({{\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"11\")\), \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"12\")\), \[Ellipsis]}, {\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"21\")\), \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"22\")\), \[Ellipsis]}, \[Ellipsis]}) is an object that formats with the \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"ij\", BaseStyle -> \"Arg\"))\) arranged in a two-dimensional grid."
GridBox::usage:= "GridBox({{\(StyleBox(\"box\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"11\")\), \(StyleBox(\"box\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"12\")\), \[Ellipsis]}, {\(StyleBox(\"box\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"21\")\), \(StyleBox(\"box\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"22\")\), \[Ellipsis]}, \[Ellipsis]}) is a low-level box construct that represents a two-dimensional grid of boxes in document expressions."
GridBoxColumnSpacing::usage:= "GridBoxColumnSpacing is an option for GridBox which specifies the spacing between adjacent columns in points."
GridBoxRowSpacing::usage:= "GridBoxRowSpacing is an option for GridBox which specifies the spacing between adjacent rows in points."
Hash::usage:= "Hash(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) gives a hash number for an expression. Hash numbers are a first clue whether two objects are identical."
Heads::usage:= "Heads is an option for functions which use level specifications taht specifies whether heads of expressions should be included."
Hold::usage:= "Hold(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) maintains \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) in unevaluated form."
HoldAll::usage:= "HoldAll is an attribute which specifies that all arguments to a function are to be maintained in unevaluated form."
HoldAllComplete::usage:= "HoldAllComplete is an attribute which specifies that all arguments to a function are not to be modified or looked at in any way in the process of evaluation."
HoldComplete::usage:= "HoldComplete(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) shields \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) completely from the standard \(StyleBox(\"pMath\", FontSlant -> Italic)\) evaluation process, even preventind uprules associated with \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) from being used."
HoldFirst::usage:= "HoldFirst is an attribute which specifies that the first argument to a function is to be maintained in unevaluated form."
HoldForm::usage:= "HoldForm(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) displays as the expression \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) , with \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) maintained in unevaluated form."
HoldPattern::usage:= "HoldPattern(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) is equivalent to \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) for pattern matching, but maintains \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) in unevaluated form."
HoldRest::usage:= "HoldRest is an attribute which specifies that all but the first argument to a function are to be maintained in unevaluated form."
I::usage:= "I represents the imaginary unit \(SqrtBox({\"-\", \"1\"})\)."
Identical::usage:= "\(StyleBox(\"lhs\", BaseStyle -> \"Arg\")\) === \(StyleBox(\"rhs\", BaseStyle -> \"Arg\")\) yields True if \(StyleBox(\"lhs\", BaseStyle -> \"Arg\")\) and \(StyleBox(\"rhs\", BaseStyle -> \"Arg\")\) are identical, and yields False otherwise."
Identity::usage:= "Identity(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) gives \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) (the identity operation)."
IdentityMatrix::usage:= "IdentityMatrix(\(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) gives the \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\[Times]\(StyleBox(\"n\", BaseStyle -> \"Arg\")\) identity matrix."
If::usage:= "If(\(StyleBox(\"condition\", BaseStyle -> \"Arg\")\), \(StyleBox(\"t\", BaseStyle -> \"Arg\")\), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)) gives \(StyleBox(\"t\", BaseStyle -> \"Arg\")\) if \(StyleBox(\"condition\", BaseStyle -> \"Arg\")\) evaluates to True and \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) if it evaluates to False.\nIf(\(StyleBox(\"condition\", BaseStyle -> \"Arg\")\), \(StyleBox(\"t\", BaseStyle -> \"Arg\")\), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \(StyleBox(\"u\", BaseStyle -> \"Arg\")\)) gives \(StyleBox(\"u\", BaseStyle -> \"Arg\")\) if \(StyleBox(\"condition\", BaseStyle -> \"Arg\")\) evaluates neither to True nor to False."
IgnoreCase::usage:= "IgnoreCase is an option for string manipulation and searching functions which specifies whether low- and upper-case letters should be treated as equivalent."
Im::usage:= "Im(\(StyleBox(\"z\", BaseStyle -> \"Arg\")\)) gives the imaginary part of the complex number \(StyleBox(\"z\", BaseStyle -> \"Arg\")\)."
Increment::usage:= "++\(StyleBox(\"x\", BaseStyle -> \"Arg\")\) increases the value of \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) by 1 and returns the new value.\n\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)+= \(StyleBox(\"dx\", BaseStyle -> \"Arg\")\) increases the value of \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) by \(StyleBox(\"dx\", BaseStyle -> \"Arg\")\)."
Indeterminate::usage:= "Indeterminate is a symbol that represents a numerical quantity whose magnitude cannot be determined."
Inequation::usage:= "Inequation represents a sequence of relational statements."
Infinity::usage:= "Infinity or \[Infinity] is a symbol that represents a positive infinite quantity."
Inherited::usage:= "Inherited is an option value for various box options which specifies that the actual value should be determined by the owner box."
Inner::usage:= "Inner(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \(StyleBox(\"list\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"list\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \(StyleBox(\"g\", BaseStyle -> \"Arg\")\)) is a generalization of Dot in which \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) play the role of multiplication and \(StyleBox(\"g\", BaseStyle -> \"Arg\")\) of addition. It effectively contracts the last index of the first tensor \(StyleBox(\"list\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\) with the first index of the second tensor \(StyleBox(\"list\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\).\nInner(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \(StyleBox(\"list\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"list\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \(StyleBox(\"g\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) contracts index \(StyleBox(\"n\", BaseStyle -> \"Arg\")\) of the first tensor with the first index of the second tensor."
InputFieldBox::usage:= "InputFieldBox(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) is a low-level construct that represents an field where the user can enter text."
InputForm::usage:= "InputForm(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) displays as \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) in a form that is valid input for \(StyleBox(\"pMath\", BaseStyle -> \"Arg\")\)."
Integer::usage:= "Integer is the head used for integers."
Interpretation::usage:= "Interpretation(\(StyleBox(\"e\", BaseStyle -> \"Arg\")\), \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) represents an object that displays as \(StyleBox(\"e\", BaseStyle -> \"Arg\")\), but is interpreted as \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) when used as input."
InterpretationBox::usage:= "InterpretationBox(\(StyleBox(\"box\", BaseStyle -> \"Arg\")\), \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) is a low-level box construct that displays as \(StyleBox(\"box\", BaseStyle -> \"Arg\")\) but is interpreted on input as \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)."
Interrupt::usage:= "Interrupt() interrupts the evaluation, asking the user how to proceed."
Intersection::usage:= "Intersection(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"list\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) gives a sorted list of elements common to all \(StyleBox(\"list\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\)."
IsArray::usage:= "IsArray(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) gives True if \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) is a rectangular array (a tensor) and False otherwise.\nIsArray(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"patt\", BaseStyle -> \"Arg\")\)) requires \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) to be a rectangular array with a depth that matches \(StyleBox(\"patt\", BaseStyle -> \"Arg\")\).\nIsArray(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"patt\", BaseStyle -> \"Arg\")\), \(StyleBox(\"test\", BaseStyle -> \"Arg\")\)) requires also that \(StyleBox(\"test\", BaseStyle -> \"Arg\")\) yields True when applied to each of the array elements in \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)."
IsEven::usage:= "IsEven(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) yields True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is an even integer number and yields False otherwise."
IsExactNumber::usage:= "IsExactNumber(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) yields True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is an exact real or complex number and False otherwise."
IsFloat::usage:= "IsFloat(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) yields True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is a floating point number."
IsFreeOf::usage:= "IsFreeOf(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"form\", BaseStyle -> \"Arg\")\)) yields True if no subexpression in \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) matches \(StyleBox(\"form\", BaseStyle -> \"Arg\")\) and yields False otherwise.\nIsFreeOf(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"form\", BaseStyle -> \"Arg\")\), \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\)) searches subexpressions in levels specified by \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\)."
IsHeld::usage:= "IsHeld(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\))(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) returns \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) with \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) being unevaluated regardless of whether \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) has attributes like HoldFirst."
IsInexactNumber::usage:= "IsInexactNumber(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) gives True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is an inexact real or complex number and False otherwise."
IsInteger::usage:= "IsInteger(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) yields True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is an integer and False otherwise."
IsMachineNumber::usage:= "IsMachineNumber(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) yields True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is a machine-precision real or complex number and yields False otherwise."
IsMatrix::usage:= "IsMatrix(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) gives True if \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) is a list of lists of the same length and False otherwise.\nIsMatrix(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"test\", BaseStyle -> \"Arg\")\)) also requires that \(StyleBox(\"test\", BaseStyle -> \"Arg\")\) yields True when applied to each of the matrix elements in \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)."
IsNegative::usage:= "IsNegative(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) gives True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is a negative number."
IsNonNegative::usage:= "IsNonNegative(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) gives True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is a non-negative number."
IsNonPositive::usage:= "IsNonPositive(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) gives True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is a non-positive number."
IsNumber::usage:= "IsNumber(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) yields True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is a real or complex number and yields False otherwise."
IsNumeric::usage:= "IsNumeric(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) yields True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is a numeric quantity and False otherwise."
IsOdd:usage:= "IsOdd(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) yields True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is an odd integer number and yields False otherwise."
IsOrdered::usage:= "IsOrdered(\(StyleBox(\"h\", BaseStyle -> \"Arg\")\)(\(StyleBox(\"e\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"e\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis])) gives True if the \(StyleBox(\"e\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\) are in canonical order and False otherwise."
IsPositive::usage:= "IsPositive(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) gives True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is a positive number."
IsPrime::usage:= "IsPrime(\(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) gives True if \(StyleBox(\"n\", BaseStyle -> \"Arg\")\) is determined to be a prime number and False otherwise."
IsQuotient::usage:= "IsQuotient(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) yields True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is a non-integer quotient and False otherwise."
IsRational::usage:= "IsRational(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) yields True if \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) is a rational number and False otherwise."
IsString::usage:= "IsString(\(StyleBox(\"s\", BaseStyle -> \"Arg\")\)) yields True if \(StyleBox(\"s\", BaseStyle -> \"Arg\")\) is a string and False otherwise."
IsSymbol::usage:= "IsSymbol(\(StyleBox(\"s\", BaseStyle -> \"Arg\")\)) yields True if \(StyleBox(\"s\", BaseStyle -> \"Arg\")\) is a symbol and False otherwise."
IsValidArgumentCount::usage:= "IsValidArgumentCount(\(StyleBox(\"head\", BaseStyle -> \"Arg\")\), \(StyleBox(\"len\", BaseStyle -> \"Arg\")\), \(StyleBox(\"min\", BaseStyle -> \"Arg\")\), \(StyleBox(\"max\", BaseStyle -> \"Arg\")\)) checks whether the number \(StyleBox(\"len\", BaseStyle -> \"Arg\")\) of arguments of a function \(StyleBox(\"head\", BaseStyle -> \"Arg\")\) is between \(StyleBox(\"min\", BaseStyle -> \"Arg\")\) and \(StyleBox(\"max\", BaseStyle -> \"Arg\")\). If not, an appropriate message is generated."
IsVector::usage:= "IsVector(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) gives True if \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) is a list with all of its elements being non-lists, and gives False otherwise.\nIsVector(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"test\", BaseStyle -> \"Arg\")\)) also requires \(StyleBox(\"test\", BaseStyle -> \"Arg\")\) to yield True when applied to each element of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)."
Italic::usage:= "Italic represents an italic font slant."
Join::usage:= "Join(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) concatenates the lists, expressions or strings \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\)."
Label::usage:= "Label(\(StyleBox(\"tag\", BaseStyle -> \"Arg\")\)) represents a point in an evaluation sequence to which control can be transfered using Goto."
Last::usage:= "Last(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) returns the last element in \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)."
LCM::usage:= "LCM(\(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) returns the least common multiplier of the integers \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\)."
LeafCount::usage:= "LeafCount(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) gives the total number of indivisible subexpressions in \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)."
Length::usage:= "Length(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) gives the number of elements in the expression \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) or the number of characters if \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) is a string."
Less::usage:= "\({\"x\", \"<\", \"y\"}\) yields True if \(\"x\"\) is determined to be less than \(\"y\"\).\n\({{\"x\", SubscriptBox(\"1\")}, \"<\", {\"x\", SubscriptBox(\"2\")}, \"<\", \"\\[Ellipsis]\"}\) yields True if the \({\"x\", SubscriptBox(\"i\")}\) form a strictly increasing sequence."
LessEqual::usage:= "\({\"x\", \"<=\", \"y\"}\) or \({\"x\", \"\\[LessEqual]\", \"y\"}\) yields True if \(\"x\"\) is determined to be less than or equal to \(\"y\"\).\n\({{\"x\", SubscriptBox(\"1\")}, \"\\[LessEqual]\", {\"x\", SubscriptBox(\"2\")}, \"\\[LessEqual]\", \"\\[Ellipsis]\"}\) yields True if the \({\"x\", SubscriptBox(\"i\")}\) form a non-decreasing sequence."
LetterCharacter::usage:= "LetterCharacter represents a letter character in StringExpression."
Level::usage:= "Level(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\)) gives a list of subexpressions of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) on levels specified by \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\).\nLevel(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)) applies \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) to the sequence of subexpressions."
LineBreakWithin::usage:= "LineBreakWithin is an option for Section and Style which specifies whether automatic line breaks should occur when the right margin of the window or page is reached."
List::usage:= "{\(StyleBox(\"e\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"e\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]} is a list of elements."
Listable::usage:= "Listable is an attribute that can be assigned to a symbol \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) to indicate that the function \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) should automatically be threaded over lists that appear as its arguments."
Literal::usage:= "Literal(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) represents \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) in pattern matching, requiring that is matched exactly as it appears, with no substitutions for SingleMatch() or other transformations."
LoadLibrary::usage:= "LoadLibrary(\"\(StyleBox(\"filename\", BaseStyle -> \"Arg\")\)\") loads a dynamic link library which adds functionaly written in C to \(StyleBox(\"pMath\", FontSlant -> Italic)\)."
Local::usage:= "Local({\(StyleBox(\"x\", BaseStyle -> \"Arg\")\), \(StyleBox(\"y\", BaseStyle -> \"Arg\")\), \[Ellipsis]}, \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) specifies that occurences of the symbols \(StyleBox(\"x\", BaseStyle -> \"Arg\")\), \(StyleBox(\"y\", BaseStyle -> \"Arg\")\), \[Ellipsis] in expr should be treated as local.\nLocal({\(StyleBox(\"x\", BaseStyle -> \"Arg\")\):= \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"0\")\), \[Ellipsis]}, \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) defines initial values for \(StyleBox(\"x\", BaseStyle -> \"Arg\")\), \[Ellipsis]."
Log::usage:= "Log(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) returns the natural logarithm of \(StyleBox(\"x\", BaseStyle -> \"Arg\")\).\nLog(\(StyleBox(\"b\", BaseStyle -> \"Arg\")\), \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) returns the logarithm to base \(StyleBox(\"b\", BaseStyle -> \"Arg\")\)."
LogGamma::usage:= "LogGamma(\(StyleBox(\"z\", BaseStyle -> \"Arg\")\)) gives the logarithm of the gamma function \({\"log\", \" \", {\"\\[CapitalGamma]\", \"(\", \"z\", \")\"}}\)."
Longest::usage:= "Longest(\(StyleBox(\"p\", BaseStyle -> \"Arg\")\)) is a pattern object which matches the longest sequence consistent with the pattern \(StyleBox(\"p\", BaseStyle -> \"Arg\")\)"
LongForm::usage:= "LongForm(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) displays as \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) with all symbols being shown along with their namespace."
LUDecomposition::usage:= "LUDecomposition(\(StyleBox(\"m\", BaseStyle -> \"Arg\")\)) generates a representation of the LU decomposition of a square matrix \(StyleBox(\"m\", BaseStyle -> \"Arg\")\)."
MachinePrecision::usage:= "MachinePrecision is a symbol used to indicate machine-number precision."
MakeBoxes::usage:= "MakeBoxes(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) is a low-level function used in \(StyleBox(\"pMath\", FontSlant -> Italic)\) sessions to convert \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) to StandardForm boxes."
MakeExpression::usage:= "MakeExpression(\(StyleBox(\"boxes\", BaseStyle -> \"Arg\")\)) is an low-level function which parses \(StyleBox(\"pMath\", FontSlant -> \"Italic\")\) code represented in two-dimensional boxed form that does not contain any whitespace or comments."
Map::usage:= "Map(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)) or \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)/@ \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) applies \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) to each element on the first level in \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\).\nMap(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\)) applies \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) to parts of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) specified by \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\)."
Match::usage:= "Match(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"pattern\", BaseStyle -> \"Arg\")\)) yields True if \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) matches \(StyleBox({\"pattern\", \".\"}, BaseStyle -> \"Arg\")\)"
MatrixForm::usage:= "MatrixForm(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\)) displays \(StyleBox(\"list\", BaseStyle -> \"Arg\")\) as a matrix or column vector."
Max::usage:= "Max(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) gives the numerically largest of the \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\).\nMax({\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, {\(StyleBox(\"y\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \[Ellipsis]}, \[Ellipsis]) gives the largest element in any of the lists."
Mean::usage:= "Mean(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\)) gives the arithmetic mean of the elements in \(StyleBox(\"list\", BaseStyle -> \"Arg\")\)."
MemoryUsage::usage:= "MemoryUsage() returns a list of the currently used memory byte count and maximum used memory byte count so far."
Message::usage:= "Message(\(StyleBox(/\\/(\"symbol\", \"::\", \"tag\"), BaseStyle -> \"Arg\")\)) prints the message \(StyleBox(\"symbol\", BaseStyle -> \"Arg\")\)::\(StyleBox(\"tag\", BaseStyle -> \"Arg\")\) unless it has been switched off.\nMessage(\(StyleBox(/\\/(\"symbol\", \"::\", \"tag\"), BaseStyle -> \"Arg\")\), \(StyleBox(\"e\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"e\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) prints the message, inserting the values of the \(StyleBox(\"e\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\) as needed."
MessageName::usage:= "\(StyleBox(/\\/(\"symbol\", \"::\", \"tag\"), BaseStyle -> \"Arg\")\) is a name for a message."
Messages::usage:= "Messages(\(StyleBox(\"symbol\", BaseStyle -> \"Arg\")\)) gives all the messages assigned to a particular symbol."
Method::usage:= "Method is an option for various algorithm-intensive functions that specifies what internal methods they should use."
Min::usage:= "Min(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) gives the numerically smallest of the \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\).\nMin({\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, {\(StyleBox(\"y\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \[Ellipsis]}, \[Ellipsis]) gives the smallest element in any of the lists."
MinusPlus::usage:= "MinusPlus(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\), \(StyleBox(\"y\", BaseStyle -> \"Arg\")\)) displays as \({\"x\", \"\\[MinusPlus]\", \"y\"}\).\nMinusPlus(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) displays as \({{{\"x\", SubscriptBox(\"1\")}, \"\\[MinusPlus]\", {\"x\", SubscriptBox(\"2\")}}, \"\\[MinusPlus]\", \"\\[Ellipsis]\"}\)."
Mod::usage:= "Mod(\(StyleBox(\"m\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) gives the remainder on division of \(StyleBox(\"m\", BaseStyle -> \"Arg\")\) by \(StyleBox(\"n\", BaseStyle -> \"Arg\")\).\nMod(\(StyleBox(\"m\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\), \(StyleBox(\"d\", BaseStyle -> \"Arg\")\)) uses an offset \(StyleBox(\"d\", BaseStyle -> \"Arg\")\)."
Most::usage:= "Most(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) returns \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) with the last element removed."
N::usage:= "N(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) gives the numerical value of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\).\nN(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"p\", BaseStyle -> \"Arg\")\)) attempts to give a result with \(StyleBox(\"p\", BaseStyle -> \"Arg\")\)-digit precision.\nN(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), {\(StyleBox(\"p\", BaseStyle -> \"Arg\")\), \(StyleBox(\"a\", BaseStyle -> \"Arg\")\)}) gives a result with at most \(StyleBox(\"a\", BaseStyle -> \"Arg\")\) digits of accuracy."
Names::usage:= "Names(\"\(StyleBox(\"string\", BaseStyle -> \"Arg\")\)\") gives a list of the names of symbols which match the string.\nNames(\(StyleBox(\"form\", BaseStyle -> \"Arg\")\)) gives a list of names matching the arbitrary string pattern \(StyleBox(\"form\", BaseStyle -> \"Arg\")\)."
Namespace::usage:= "Namespace() returns the current namespace.\nNamespace(\(StyleBox(\"symbol\", BaseStyle -> \"Arg\")\)) returns the namespace in which a \(StyleBox(\"symbol\", BaseStyle -> \"Arg\")\) appears."
NewTask::usage:= "NewTask(\(StyleBox(\"body\", BaseStyle -> \"Arg\")\)) starts a new asynchronous task for evaluating \(StyleBox(\"body\", BaseStyle -> \"Arg\")\). A task object is returned which can be used to wait for and get the evaluations result with Wait."
NextPrime::usage:= "NextPrime(\(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) returns the first prime that is greater than \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)."
NHoldAll::usage:= "NHoldAll is an attribute which specifies that none of the arguments to a function should be affected by N."
NHoldFirst::usage:= "NHoldFirst is an attribute which specifies that the first argument to a function should not be affected by N."
NHoldRest::usage:= "NHoldRest is an attribute which specifies that none but the first argument to a function should be affected by N."
None::usage:= "None is a setting for certain options."
Not::usage:= "!\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) is the logical NOT function. It gives True if \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) is False, and False if is True."
NRules::usage:= "NRules(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\)) gives a list of transformation rules corresponding to all numerical values (values for N(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\)(x, \[Ellipsis]), \[Ellipsis]), etc.) defined for the symbol \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)."
Number::usage:= "Number represents an exact integer or an approximate real number in Read."
NumericFunction::usage:= "NumericFunction is an attribute that can be assigned to a symbol \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) to indicate that \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)(\(StyleBox(\"arg\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"arg\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) should be considered a numeric quantity whenevel all the \(StyleBox(\"arg\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\) are numeric quantities."
Off::usage:= "Off(\(StyleBox(/\\/(\"symbol\", \"::\", \"tag\"), BaseStyle -> \"Arg\")\)) switches off a message, so that is no longer printed.\nOff(\(StyleBox(\"s\", BaseStyle -> \"Arg\")\)) switches off tracing messages associated with the symbol \(StyleBox(\"s\", BaseStyle -> \"Arg\")\).\nOff(\(StyleBox(\"m\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"m\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) switches off several messages."
On::usage:= "On(\(StyleBox(/\\/(\"symbol\", \"::\", \"tag\"), BaseStyle -> \"Arg\")\)) switches on a message, so that can be printed.\nOn(\(StyleBox(\"s\", BaseStyle -> \"Arg\")\)) switches on tracing for the symbol \(StyleBox(\"s\", BaseStyle -> \"Arg\")\).\nOn(\(StyleBox(\"m\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"m\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) switches on tracing for several messages."
OneIdentity::usage:= "OneIdentity is an attribute that can be assigned to a symbol \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) to indicate that \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\)(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\))), etc. are all equivalent to \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) for the purpose of pattern matching."
OpenAppend::usage:= "OpenAppend(\"\(StyleBox(\"file\", BaseStyle -> \"Arg\")\)\") opens a file to append output to it and returns a file stream object."
OpenRead::usage:= "OpenRead(\"\(StyleBox(\"file\", BaseStyle -> \"Arg\")\)\") opens a file to read data from, and returns a file stream object."
OpenWrite::usage:= "OpenWrite(\"\(StyleBox(\"file\", BaseStyle -> \"Arg\")\)\") opens a file to write data to, and returns a file stream object."
Operate::usage:= "Operate(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\)(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\), \(StyleBox(\"y\", BaseStyle -> \"Arg\")\)), \(StyleBox(\"p\", BaseStyle -> \"Arg\")\)) gives \(StyleBox(\"p\", BaseStyle -> \"Arg\")\)(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\))(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\), \(StyleBox(\"y\", BaseStyle -> \"Arg\")\))\nOperate(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"p\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) applies \(StyleBox(\"p\", BaseStyle -> \"Arg\")\) at level \(StyleBox(\"n\", BaseStyle -> \"Arg\")\) in the head of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)."
Optional::usage:= "?\(StyleBox(\"x\", BaseStyle -> \"Arg\")\):\(StyleBox(\"v\", BaseStyle -> \"Arg\")\) is a pattern object with the name \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) that matches any expression or can be omitted, in which case \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) takes the value \(StyleBox(\"v\", BaseStyle -> \"Arg\")\).\n?\(StyleBox(\"x\", BaseStyle -> \"Arg\")\) takes an appropriate default value from Default definitions for the enclosing expressions head."
Options::usage:= "Options(\(StyleBox(\"symbol\", BaseStyle -> \"Arg\")\)) returns the list of default options assigned to a symbol.\nOptions(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) returns the options explicitly specified in a particular expression.\nOptions(\(StyleBox(\"object\", BaseStyle -> \"Arg\")\)) returns options associated with a special object such as file streams or document objects\nOptions(\(StyleBox(\"obj\", BaseStyle -> \"Arg\")\), \(StyleBox(\"name\", BaseStyle -> \"Arg\")\)) returns the settings for the option \(StyleBox(\"name\", BaseStyle -> \"Arg\")\).\nOptions(\(StyleBox(\"obj\", BaseStyle -> \"Arg\")\), {\(StyleBox(\"name\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"name\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) returns a list of settings fpr the options \(StyleBox(\"name\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\)."
OptionsPattern::usage:= "OptionsPattern() is a pattern object that represents a collection of options given as rules, where the values of the options can be accessed using OptionValue.\nOptionsPattern(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\)) takes default option values from Options(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\))."
OptionValue::usage:= "OptionValue(\(StyleBox(\"name\", BaseStyle -> \"Arg\")\)) returns the value of \(StyleBox(\"name\", BaseStyle -> \"Arg\")\) in options matched by OptionsPattern.\nOptionValue(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \(StyleBox(\"name\", BaseStyle -> \"Arg\")\)) returns the value of \(StyleBox(\"name\", BaseStyle -> \"Arg\")\) in options associated with head \(StyleBox(\"f\", BaseStyle -> \"Arg\")\).\nOptionValue(\(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \(StyleBox(\"opts\", BaseStyle -> \"Arg\")\), \(StyleBox(\"name\", BaseStyle -> \"Arg\")\)) extracts option values from the explicit list of rules \(StyleBox(\"opts\", BaseStyle -> \"Arg\")\)."
Or::options:= "\(StyleBox(\"e\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\) || \(StyleBox(\"e\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\) || \[Ellipsis] is the logical OR function. It evaluates its arguments in order, giving True immediately if any of them is True, and False if all of them are False."
OutputForm::usage:= "OutputForm(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) displays \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) with only boxes that can be displayed using keyboard characters."
Overflow::usage:= "Overflow() represents a number too large to be represented explicitly on your computer system."
Overlaps::usage:= "Overlaps is an option for StringCases and StringPosition that specifies how to treat overlapping substrings."
Overscript::usage:= "Overscript(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\), \(StyleBox(\"y\", BaseStyle -> \"Arg\")\)) displays as \(OverscriptBox(StyleBox(\"x\", BaseStyle -> \"Arg\"), StyleBox(\"y\", BaseStyle -> \"Arg\"))\)."
OverscriptBox::usage:= "OverscriptBox(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\), \(StyleBox(\"y\", BaseStyle -> \"Arg\")\)) is the low-level box representation for \(OverscriptBox(StyleBox(\"x\", BaseStyle -> \"Arg\"), StyleBox(\"y\", BaseStyle -> \"Arg\"))\) in document expressions."
OwnRules::usage:= "OwnRules(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) gives the rules corresponding to any ownvalue for the symbol \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)."
ParallelMap::usage:= "ParallelMap(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)) applies \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) in parallel to each element on the first level in \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\).\nParallelMap(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\)) applies \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) in parallel to parts of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) specified by \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\)."
ParallelScan::usage:= "ParallelScan(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)) evaluates in parallel \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) applied to each element of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\).\nParallelScan(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\)) applies \(StyleBox(\"f\", BaseStyle -> \"Arg\")\) in parallel to parts of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\) specified by \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\)."
ParallelTry::usage:= "ParallelTry({\(StyleBox(\"arg\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"arg\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)) evaluates \(StyleBox(\"f\", BaseStyle -> \"Arg\")\)(\(StyleBox(\"arg\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"i\")\)) in parallel, returning the first result received.\nParallelTry({\(StyleBox(\"arg\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"arg\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \(StyleBox(\"f\", BaseStyle -> \"Arg\")\), \(StyleBox(\"k\", BaseStyle -> \"Arg\")\)) returns a list of the first \(StyleBox(\"k\", BaseStyle -> \"Arg\")\) results."
ParenthesizeBoxes::usage:= "ParenthesizeBoxes(\(StyleBox(\"boxes\", BaseStyle -> \"Arg\")\), \(StyleBox(\"prec\", BaseStyle -> \"Arg\")\), \(StyleBox(\"group\", BaseStyle -> \"Arg\")\)) is a low-level function, that surrounds \(StyleBox(\"boxes\", BaseStyle -> \"Arg\")\) with parenthesis if the requested operator precedence \(StyleBox(\"prec\", BaseStyle -> \"Arg\")\) and operator group \(StyleBox(\"group\", BaseStyle -> \"Arg\")\) demand that."
ParserArguments::usage:= "ParserArguments is an option for ToExpression which specifies addition arguments {\(StyleBox(\"arg\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"arg\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]} to replace `\(StyleBox(\"i\", BaseStyle -> \"Arg\")\)` in the code with \(StyleBox(\"arg\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\)."
ParseSymbols::usage:= "ParseSymbols is an option for ToExpression which specifies whether new symbols may be generated during parsing."
Part::usage:= "\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)[\(StyleBox(\"i\", BaseStyle -> \"Arg\")\)] or Part(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"i\", BaseStyle -> \"Arg\")\)) gives the \(StyleBox(\"i\", BaseStyle -> \"Arg\")\)\(SuperscriptBox(\"th\")\) part of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\).\n\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)[-\(StyleBox(\"i\", BaseStyle -> \"Arg\")\)] counts from the end.\n\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)[\(StyleBox(\"i\", BaseStyle -> \"Arg\")\), \(StyleBox(\"j\", BaseStyle -> \"Arg\")\), \[Ellipsis]] or Part(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"i\", BaseStyle -> \"Arg\")\), \(StyleBox(\"j\", BaseStyle -> \"Arg\")\), \[Ellipsis]) is equivalent to \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)[\(StyleBox(\"i\", BaseStyle -> \"Arg\")\)][\(StyleBox(\"j\", BaseStyle -> \"Arg\")\)]\[Ellipsis].\n\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)[{\(StyleBox(\"i\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}] gives a list of the parts \(StyleBox(\"i\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"i\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis] of \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\).\n\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)[\(StyleBox(\"m\", BaseStyle -> \"Arg\")\) .. \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)] gives parts \(StyleBox(\"m\", BaseStyle -> \"Arg\")\) through \(StyleBox(\"n\", BaseStyle -> \"Arg\")\).\n\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)[\(StyleBox(\"m\", BaseStyle -> \"Arg\")\) .. \(StyleBox(\"n\", BaseStyle -> \"Arg\")\) .. \(StyleBox(\"s\", BaseStyle -> \"Arg\")\)] gives parts \(StyleBox(\"m\", BaseStyle -> \"Arg\")\) through \(StyleBox(\"n\", BaseStyle -> \"Arg\")\) in steps of \(StyleBox(\"s\", BaseStyle -> \"Arg\")\)."
Partition::usage:= "Partition(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) partitions \(StyleBox(\"list\", BaseStyle -> \"Arg\")\) into non-overlapping sublists of length \(StyleBox(\"n\", BaseStyle -> \"Arg\")\).\nPartition(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\), \(StyleBox(\"d\", BaseStyle -> \"Arg\")\)) generates sublists with offset \(StyleBox(\"d\", BaseStyle -> \"Arg\")\).\nPartition(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), {\(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) partitions a nested list into blocks of size \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\) \[Times] \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\) \[Times] \[Ellipsis].\nPartition(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), {\(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, {\(StyleBox(\"d\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"d\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) uses offset \(StyleBox(\"d\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\) at level \(StyleBox(\"i\", BaseStyle -> \"Arg\")\) in \(StyleBox(\"list\", BaseStyle -> \"Arg\")\).\nPartition(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\), \(StyleBox(\"d\", BaseStyle -> \"Arg\")\), {\(StyleBox(\"k\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"L\", BaseStyle -> \"Arg\"))\), \(StyleBox(\"k\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"R\", BaseStyle -> \"Arg\"))\)}) specifies that the first elemnt of \(StyleBox(\"list\", BaseStyle -> \"Arg\")\) should appear at position \(StyleBox(\"k\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"L\", BaseStyle -> \"Arg\"))\) in the first sublist, and the last element of \(StyleBox(\"list\", BaseStyle -> \"Arg\")\) should appear at or after position \(StyleBox(\"k\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"R\", BaseStyle -> \"Arg\"))\) in the last sublist. If additional elements are needed, Partition fills them in by treating \(StyleBox(\"list\", BaseStyle -> \"Arg\")\) as cyclic.\nPartition(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\), \(StyleBox(\"d\", BaseStyle -> \"Arg\")\), {\(StyleBox(\"k\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"L\", BaseStyle -> \"Arg\"))\), \(StyleBox(\"k\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"R\", BaseStyle -> \"Arg\"))\)}, \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) pads if necessary by repeating the element \(StyleBox(\"x\", BaseStyle -> \"Arg\")\).\nPartition(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\), \(StyleBox(\"d\", BaseStyle -> \"Arg\")\), {\(StyleBox(\"k\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"L\", BaseStyle -> \"Arg\"))\), \(StyleBox(\"k\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"R\", BaseStyle -> \"Arg\"))\)}, {\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) pads if necessary by cyclically repeating the elements \(StyleBox(\"x\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\).\nPartition(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\), \(StyleBox(\"d\", BaseStyle -> \"Arg\")\), {\(StyleBox(\"k\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"L\", BaseStyle -> \"Arg\"))\), \(StyleBox(\"k\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"R\", BaseStyle -> \"Arg\"))\)}, {}) uses no padding, and so can yield sublists of different lengths.\nPartition(\(StyleBox(\"list\", BaseStyle -> \"Arg\")\), \(StyleBox(\"nlist\", BaseStyle -> \"Arg\")\), \(StyleBox(\"dlist\", BaseStyle -> \"Arg\")\), {\(StyleBox(\"klist\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"L\", BaseStyle -> \"Arg\"))\), \(StyleBox(\"klist\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"R\", BaseStyle -> \"Arg\"))\)}, \(StyleBox(\"padlist\", BaseStyle -> \"Arg\")\)) specifies alignments and padding in a nested list."
Path::usage:= "Path is an option for Get and related functions which specifies a list of directories to search in to find a file."
Pattern::usage:= "\(StyleBox(\"s\", BaseStyle -> \"Arg\")\):\(StyleBox(\"pat\", BaseStyle -> \"Arg\")\) represents the pattern object \(StyleBox(\"pat\", BaseStyle -> \"Arg\")\), assigned the name \(StyleBox(\"s\", BaseStyle -> \"Arg\")\)."
PatternSequence::usage:= "PatternSequence(\(StyleBox(\"p\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"p\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]) is a pattern object which represents a sequence of arguments matching \(StyleBox(\"p\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"p\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]."
Pause::usage:= "Pause(\(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) pauses for at least \(StyleBox(\"n\", BaseStyle -> \"Arg\")\) seconds."
Pi::usage:= "Pi is Archimedes' Constant \[Pi] with numerical value \[TildeTilde] 3.14159."
Piecewise::usage:= "Piecewise({{\(StyleBox(\"val\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"cond\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\)}, {\(StyleBox(\"val\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\), \(StyleBox(\"cond\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"2\")\)}, \[Ellipsis]}) represents a piecewise function with values \(StyleBox(\"val\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\) in the regions defined by the conditions \(StyleBox(\"cond\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\).\nPiecewise({{\(StyleBox(\"val\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"cond\", BaseStyle -> \"Arg\")\)\(SubscriptBox(\"1\")\)}, \[Ellipsis]}, \(StyleBox(\"val\", BaseStyle -> \"Arg\")\)) uses default value \(StyleBox(\"val\", BaseStyle -> \"Arg\")\) if none of the \(StyleBox(\"cond\", BaseStyle -> \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", BaseStyle -> \"Arg\"))\) apply.The default for \(StyleBox(\"val\", BaseStyle -> \"Arg\")\) is 0."
Placeholder::usage:= "Placeholder() displays as \[Placeholder], a navigatable placeholder.\nPlaceholder(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\)) displays as \(TagBox(FrameBox(StyleBox(\"expr\", BaseStyle -> \"Arg\")), \"Placeholder\")\)."
Plain::usage:= "Plain represents a font that is neither bold nor italic."
Plus::usage:= "\(StyleBox(\"x\", BaseStyle -> \"Arg\")\) + \(StyleBox(\"y\", BaseStyle -> \"Arg\")\) + \(StyleBox(\"z\", BaseStyle -> \"Arg\")\) is a sum of terms."
PlusMinus::usage:= "PlusMinus(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\)) displays as \[PlusMinus]\(StyleBox(\"x\", BaseStyle -> \"Arg\")\).\nPlusMinus(\(StyleBox(\"x\", BaseStyle -> \"Arg\")\), \(StyleBox(\"y\", BaseStyle -> \"Arg\")\), \[Ellipsis]) displays as \(StyleBox(\"x\", BaseStyle -> \"Arg\")\) \[PlusMinus] \(StyleBox(\"y\", BaseStyle -> \"Arg\")\) \[PlusMinus] \[Ellipsis]."
PolyGamma::usage:= "PolyGamma(\(StyleBox(\"z\", BaseStyle -> \"Arg\")\)) is the digamma function \(\"\\[Psi]\"\)(\(StyleBox(\"z\", BaseStyle -> \"Arg\")\)).\nPolyGamma(\(StyleBox(\"n\", BaseStyle -> \"Arg\")\), \(StyleBox(\"z\", BaseStyle -> \"Arg\")\)) is the \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)\(SuperscriptBox(\"th\")\) derivative of the digamma function \({\"\\[Psi]\", SuperscriptBox({\"(\", StyleBox(\"n\", BaseStyle -> \"Arg\"), \")\"})}\)(\(StyleBox(\"z\", BaseStyle -> \"Arg\")\))."
Position::usage:= "Position(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"pattern\", BaseStyle -> \"Arg\")\)) returns a list of the positions at which objects matching \(StyleBox(\"pattern\", BaseStyle -> \"Arg\")\) appear in \(StyleBox(\"expr\", BaseStyle -> \"Arg\")\).\nPosition(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"pattern\", BaseStyle -> \"Arg\")\), \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\)) gives only objects that appear on levels specified by \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\).\nPosition(\(StyleBox(\"expr\", BaseStyle -> \"Arg\")\), \(StyleBox(\"pattern\", BaseStyle -> \"Arg\")\), \(StyleBox(\"levelspec\", BaseStyle -> \"Arg\")\), \(StyleBox(\"n\", BaseStyle -> \"Arg\")\)) gives the positions of the first \(StyleBox(\"n\", BaseStyle -> \"Arg\")\) objects found."



