<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>pMath: Atomic Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Atomic Operations</h1>Using atomic operations (independent of the rest of the library).  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomic__ops.html#g7c8d6965c55b4461f4c93dbcd0e54e44">PMATH_DECLARE_ALIGNED</a>(TYPE, NAME, ALIGNMENT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declares a variable with specified alignment.  <a href="#g7c8d6965c55b4461f4c93dbcd0e54e44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomic__ops.html#gea9d23f3c2f74768863e67ff2a8d17df">PMATH_DECLARE_ATOMIC</a>(NAME)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declares a volatile machine size integer with proper alignment.  <a href="#gea9d23f3c2f74768863e67ff2a8d17df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomic__ops.html#g2228cd9578858b0f60078fc87ef0774a">PMATH_DECLARE_ATOMIC_2</a>(NAME)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declares a volatile double-machine-size integer with proper alignment.  <a href="#g2228cd9578858b0f60078fc87ef0774a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">intptr_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomic__ops.html#ge84bfddad2c018c6273b43164e6064ab">pmath_atomic_fetch_add</a> (intptr_t volatile *atom, intptr_t delta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a value to another.  <a href="#ge84bfddad2c018c6273b43164e6064ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">intptr_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomic__ops.html#gc39a86500a2344c9c7f7f42d2d069334">pmath_atomic_fetch_set</a> (intptr_t volatile *atom, intptr_t new_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange a value.  <a href="#gc39a86500a2344c9c7f7f42d2d069334"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">intptr_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomic__ops.html#g0eb65b0a5caacf019bf1c97616f69603">pmath_atomic_fetch_compare_and_set</a> (intptr_t volatile *atom, intptr_t old_value, intptr_t new_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange a value if it equals another value.  <a href="#g0eb65b0a5caacf019bf1c97616f69603"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomic__ops.html#g8e2ec6134e5f1161aed5c890abb2e53b">pmath_atomic_compare_and_set</a> (intptr_t volatile *atom, intptr_t old_value, intptr_t new_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange a value if it equals another value.  <a href="#g8e2ec6134e5f1161aed5c890abb2e53b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomic__ops.html#g868adc2a74d7aafbb0670922f61a21cc">pmath_atomic_compare_and_set_2</a> (intptr_t volatile *atom, intptr_t old_value_fst, intptr_t old_value_snd, intptr_t new_value_fst, intptr_t new_value_snd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange two values value if they equal another two values.  <a href="#g868adc2a74d7aafbb0670922f61a21cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomic__ops.html#g9bc606e66ad7965f09dc9200f0b21bcc">pmath_atomic_have_cas2</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check, whether the CPU supports <a class="el" href="group__atomic__ops.html#g868adc2a74d7aafbb0670922f61a21cc" title="Exchange two values value if they equal another two values.">pmath_atomic_compare_and_set_2()</a>.  <a href="#g9bc606e66ad7965f09dc9200f0b21bcc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7f23c95c69503003e2bda2ab6dc0aae4"></a><!-- doxytag: member="atomic_ops::pmath_atomic_barrier" ref="g7f23c95c69503003e2bda2ab6dc0aae4" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomic__ops.html#g7f23c95c69503003e2bda2ab6dc0aae4">pmath_atomic_barrier</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an explicit memory barrier. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomic__ops.html#gf143a22332da6a2065bac14069ecbf7f">pmath_atomic_lock</a> (intptr_t volatile *atom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to aquire a lock.  <a href="#gf143a22332da6a2065bac14069ecbf7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomic__ops.html#ga61bbbab4adc550cc66d1d5f9cf22afd">pmath_atomic_unlock</a> (intptr_t volatile *atom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a previously aquired lock.  <a href="#ga61bbbab4adc550cc66d1d5f9cf22afd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomic__ops.html#gf92920164c2e99abfbbe092dfc5dae86">pmath_atomic_loop_nop</a> (void)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Using atomic operations (independent of the rest of the library). 
<p>
pMath provides a collection of functions/macros to do atomic operations. This part of the library is completely independent of the rest of pMath. To use atomic opertions, #include &lt;pmath-util/concurrency/atomic.h&gt;. You do not have to link to an additionl library.<p>
At the moment, supported compilers are GCC and Microsoft Visual C++.<p>
On some platforms, the atomic opertations are implemented as inline functions with inline assembler (currently GCC older than 4.x). On other platforms, macros and compiler intrinsic functions (GCC 4.x, MSVC) are used.<h2><a class="anchor" name="sect_atomic_ops_ref">
Nice to read:</a></h2>
<ul>
<li><a href="http://developers.sun.com/solaris/articles/atomic_sparc/">http://developers.sun.com/solaris/articles/atomic_sparc/</a></li>
</ul>
<ul>
<li><a href="http://lists.canonical.org/pipermail/kragen-tol/1999-August/000457.html">http://lists.canonical.org/pipermail/kragen-tol/1999-August/000457.html</a></li>
</ul>
<ul>
<li><a href="http://www.angstrom-distribution.org/unstable/sources/libc_sources.redhat.com__20061019.tar.gz">http://www.angstrom-distribution.org/unstable/sources/libc_sources.redhat.com__20061019.tar.gz</a> <br>
 libc/sysdeps/i386/i486/bits/atomic.h</li>
</ul>
<ul>
<li>Intel's cmpxchg8b and cmpxchg16b instructions</li>
</ul>
<ul>
<li><a href="http://www.cse.msu.edu/~sdf/private/szumoframe-0.3.tar.gz">http://www.cse.msu.edu/~sdf/private/szumoframe-0.3.tar.gz</a> <br>
 szumoframe-0.3/src/szumoframe/szumo_preamble.h</li>
</ul>
<ul>
<li><a href="http://www.tml.tkk.fi/~rakajast/uvsr_renderer.tar.gz">http://www.tml.tkk.fi/~rakajast/uvsr_renderer.tar.gz</a> <br>
 uvsr_renderer/needed_externals/threadlib/src/fifo.c</li>
</ul>
<ul>
<li>qprof -&gt; atomic_ops library </li>
</ul>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="g7c8d6965c55b4461f4c93dbcd0e54e44"></a><!-- doxytag: member="non&#45;atomic.h::PMATH_DECLARE_ALIGNED" ref="g7c8d6965c55b4461f4c93dbcd0e54e44" args="(TYPE, NAME, ALIGNMENT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PMATH_DECLARE_ALIGNED          </td>
          <td>(</td>
          <td class="paramtype">TYPE,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NAME,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALIGNMENT&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Declares a variable with specified alignment. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TYPE</em>&nbsp;</td><td>The variable type, possibly including the <code>volatile</code> modifier. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NAME</em>&nbsp;</td><td>The variable name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ALIGNMENT</em>&nbsp;</td><td>The alignment in bytes </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gea9d23f3c2f74768863e67ff2a8d17df"></a><!-- doxytag: member="non&#45;atomic.h::PMATH_DECLARE_ATOMIC" ref="gea9d23f3c2f74768863e67ff2a8d17df" args="(NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PMATH_DECLARE_ATOMIC          </td>
          <td>(</td>
          <td class="paramtype">NAME&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Declares a volatile machine size integer with proper alignment. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NAME</em>&nbsp;</td><td>The variable name. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g2228cd9578858b0f60078fc87ef0774a"></a><!-- doxytag: member="non&#45;atomic.h::PMATH_DECLARE_ATOMIC_2" ref="g2228cd9578858b0f60078fc87ef0774a" args="(NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PMATH_DECLARE_ATOMIC_2          </td>
          <td>(</td>
          <td class="paramtype">NAME&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Declares a volatile double-machine-size integer with proper alignment. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NAME</em>&nbsp;</td><td>The variable name. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ge84bfddad2c018c6273b43164e6064ab"></a><!-- doxytag: member="non&#45;atomic.h::pmath_atomic_fetch_add" ref="ge84bfddad2c018c6273b43164e6064ab" args="(intptr_t volatile *atom, intptr_t delta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">intptr_t pmath_atomic_fetch_add           </td>
          <td>(</td>
          <td class="paramtype">intptr_t volatile *&nbsp;</td>
          <td class="paramname"> <em>atom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&nbsp;</td>
          <td class="paramname"> <em>delta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a value to another. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>atom</em>&nbsp;</td><td>A sizeof(void*) aligned pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delta</em>&nbsp;</td><td>The difference between the new and the old value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The old value of <code>*atom</code>.</dd></dl>
This function increments <code>*atom</code> atomically by <code>delta</code>. It has full memory barrier semantics. 
</div>
</div><p>
<a class="anchor" name="gc39a86500a2344c9c7f7f42d2d069334"></a><!-- doxytag: member="non&#45;atomic.h::pmath_atomic_fetch_set" ref="gc39a86500a2344c9c7f7f42d2d069334" args="(intptr_t volatile *atom, intptr_t new_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">intptr_t pmath_atomic_fetch_set           </td>
          <td>(</td>
          <td class="paramtype">intptr_t volatile *&nbsp;</td>
          <td class="paramname"> <em>atom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&nbsp;</td>
          <td class="paramname"> <em>new_value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Exchange a value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>atom</em>&nbsp;</td><td>A sizeof(void*) aligned pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_value</em>&nbsp;</td><td>The new value of <code>*atom</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The old value of <code>*atom</code>.</dd></dl>
This function sets <code>*atom</code> to <code>new_value</code> and returns the old value atomically. It has full memory barrier semantics. 
</div>
</div><p>
<a class="anchor" name="g0eb65b0a5caacf019bf1c97616f69603"></a><!-- doxytag: member="non&#45;atomic.h::pmath_atomic_fetch_compare_and_set" ref="g0eb65b0a5caacf019bf1c97616f69603" args="(intptr_t volatile *atom, intptr_t old_value, intptr_t new_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">intptr_t pmath_atomic_fetch_compare_and_set           </td>
          <td>(</td>
          <td class="paramtype">intptr_t volatile *&nbsp;</td>
          <td class="paramname"> <em>atom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&nbsp;</td>
          <td class="paramname"> <em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&nbsp;</td>
          <td class="paramname"> <em>new_value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Exchange a value if it equals another value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>atom</em>&nbsp;</td><td>A sizeof(void*) aligned pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old_value</em>&nbsp;</td><td>The comparisor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_value</em>&nbsp;</td><td>The possible new value of <code>*atom</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The old value of <code>*atom</code>.</dd></dl>
You should use <a class="el" href="group__atomic__ops.html#g8e2ec6134e5f1161aed5c890abb2e53b" title="Exchange a value if it equals another value.">pmath_atomic_compare_and_set()</a> if you don't need the exact old value of <code>*atom</code>, because this function might be non-existent on some systems. This function has aquire barrier semantics. 
</div>
</div><p>
<a class="anchor" name="g8e2ec6134e5f1161aed5c890abb2e53b"></a><!-- doxytag: member="non&#45;atomic.h::pmath_atomic_compare_and_set" ref="g8e2ec6134e5f1161aed5c890abb2e53b" args="(intptr_t volatile *atom, intptr_t old_value, intptr_t new_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a> pmath_atomic_compare_and_set           </td>
          <td>(</td>
          <td class="paramtype">intptr_t volatile *&nbsp;</td>
          <td class="paramname"> <em>atom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&nbsp;</td>
          <td class="paramname"> <em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&nbsp;</td>
          <td class="paramname"> <em>new_value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Exchange a value if it equals another value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>atom</em>&nbsp;</td><td>A sizeof(void*) aligned pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old_value</em>&nbsp;</td><td>The comparisor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_value</em>&nbsp;</td><td>The possible new value of <code>*atom</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the exchange was performed.</dd></dl>
This function compares <code>*atom</code> with <code>old_value</code> and iff both equal sets <code>*atom</code> to <code>new_value</code>, everything atomically and with aquire barrier semantics. 
</div>
</div><p>
<a class="anchor" name="g868adc2a74d7aafbb0670922f61a21cc"></a><!-- doxytag: member="non&#45;atomic.h::pmath_atomic_compare_and_set_2" ref="g868adc2a74d7aafbb0670922f61a21cc" args="(intptr_t volatile *atom, intptr_t old_value_fst, intptr_t old_value_snd, intptr_t new_value_fst, intptr_t new_value_snd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a> pmath_atomic_compare_and_set_2           </td>
          <td>(</td>
          <td class="paramtype">intptr_t volatile *&nbsp;</td>
          <td class="paramname"> <em>atom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&nbsp;</td>
          <td class="paramname"> <em>old_value_fst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&nbsp;</td>
          <td class="paramname"> <em>old_value_snd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&nbsp;</td>
          <td class="paramname"> <em>new_value_fst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&nbsp;</td>
          <td class="paramname"> <em>new_value_snd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Exchange two values value if they equal another two values. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*atom</em>&nbsp;</td><td>A 2*sizeof(void*) aligned pointer to two values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old_value_fst</em>&nbsp;</td><td>The first old value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old_value_snd</em>&nbsp;</td><td>The second old value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_value_fst</em>&nbsp;</td><td>The possible new value of <code>atom</code>[0]. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_value_snd</em>&nbsp;</td><td>The possible new value of <code>atom</code>[1]. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the exchange was performed or not.</dd></dl>
This function compares <code>old_value_fst</code> with <code>atom</code>[0] and <code>old_value_snd</code> with atom[1]. If they equal, <code>atom</code>[0] is set to <code>new_value_fst</code> and <code>atom</code>[1] is set to <code>new_value_snd</code> and TRUE is returned. Otherwise, FALSE will be returned.<p>
This function has aquire barrier semantics.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function is not available on all Platforms. You must not call it if <a class="el" href="group__atomic__ops.html#g9bc606e66ad7965f09dc9200f0b21bcc" title="Check, whether the CPU supports pmath_atomic_compare_and_set_2().">pmath_atomic_have_cas2()</a> returns FALSE. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9bc606e66ad7965f09dc9200f0b21bcc"></a><!-- doxytag: member="non&#45;atomic.h::pmath_atomic_have_cas2" ref="g9bc606e66ad7965f09dc9200f0b21bcc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a> pmath_atomic_have_cas2           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check, whether the CPU supports <a class="el" href="group__atomic__ops.html#g868adc2a74d7aafbb0670922f61a21cc" title="Exchange two values value if they equal another two values.">pmath_atomic_compare_and_set_2()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>whether <a class="el" href="group__atomic__ops.html#g868adc2a74d7aafbb0670922f61a21cc" title="Exchange two values value if they equal another two values.">pmath_atomic_compare_and_set_2()</a> is supported.</dd></dl>
Note, that a call to <a class="el" href="group__atomic__ops.html#g868adc2a74d7aafbb0670922f61a21cc" title="Exchange two values value if they equal another two values.">pmath_atomic_compare_and_set_2()</a> will crash your application on any platform that does not support the operation (e.g. pre-Pentiums, early AMD64). 
</div>
</div><p>
<a class="anchor" name="gf143a22332da6a2065bac14069ecbf7f"></a><!-- doxytag: member="non&#45;atomic.h::pmath_atomic_lock" ref="gf143a22332da6a2065bac14069ecbf7f" args="(intptr_t volatile *atom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pmath_atomic_lock           </td>
          <td>(</td>
          <td class="paramtype">intptr_t volatile *&nbsp;</td>
          <td class="paramname"> <em>atom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Try to aquire a lock. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>atom</em>&nbsp;</td><td>The lock. A sizeof(void*) aligned pointer.</td></tr>
  </table>
</dl>
This function implements a spin lock. It has aquire barrier semantics. Use it with <a class="el" href="group__atomic__ops.html#ga61bbbab4adc550cc66d1d5f9cf22afd" title="Release a previously aquired lock.">pmath_atomic_unlock()</a>: <div class="fragment"><pre class="fragment"><a class="code" href="group__atomic__ops.html#gea9d23f3c2f74768863e67ff2a8d17df" title="Declares a volatile machine size integer with proper alignment.">PMATH_DECLARE_ATOMIC</a>(spin);
...
pmath_atomic_lock(&amp;spin)
... critical section ...
pmath_atomic_unlock(&amp;spin);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="ga61bbbab4adc550cc66d1d5f9cf22afd"></a><!-- doxytag: member="non&#45;atomic.h::pmath_atomic_unlock" ref="ga61bbbab4adc550cc66d1d5f9cf22afd" args="(intptr_t volatile *atom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pmath_atomic_unlock           </td>
          <td>(</td>
          <td class="paramtype">intptr_t volatile *&nbsp;</td>
          <td class="paramname"> <em>atom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release a previously aquired lock. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>atom</em>&nbsp;</td><td>The lock. A sizeof(void*) aligned pointer.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__atomic__ops.html#gf143a22332da6a2065bac14069ecbf7f" title="Try to aquire a lock.">pmath_atomic_lock</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf92920164c2e99abfbbe092dfc5dae86"></a><!-- doxytag: member="non&#45;atomic.h::pmath_atomic_loop_nop" ref="gf92920164c2e99abfbbe092dfc5dae86" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pmath_atomic_loop_nop           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A no-operation for use in spin locks. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Apr 18 19:34:50 2010 for pMath by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
