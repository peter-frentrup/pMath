<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>pMath: Object Utility Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Object Utility Functions</h1>Utility functuions for pMath Objects and Expressions.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#g11afc6451921f3169224096723483c64">pmath_stack_walker_t</a> )(<a class="el" href="classpmath__t.html">pmath_t</a> head, void *closure)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A stack walker function.  <a href="#g11afc6451921f3169224096723483c64"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#g66eb580a000ee1d778b43dec124f170d">pmath_is_expr_of</a> (<a class="el" href="classpmath__t.html">pmath_t</a> obj, <a class="el" href="classpmath__symbol__t.html">pmath_symbol_t</a> head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if an object is an expression with a specified head.  <a href="#g66eb580a000ee1d778b43dec124f170d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#g68d264fe6b3db0931b4d0a8d5c7427f5">pmath_is_expr_of_len</a> (<a class="el" href="classpmath__t.html">pmath_t</a> obj, <a class="el" href="classpmath__symbol__t.html">pmath_symbol_t</a> head, size_t length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if an object is an expression with a specified head and length.  <a href="#g68d264fe6b3db0931b4d0a8d5c7427f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#g70aa270956b6c8f8eb43431f9775ae88">pmath_current_head</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the currently evaluated function.  <a href="#g70aa270956b6c8f8eb43431f9775ae88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#g55213cb0c89952b6aacf90f36ad4047b">pmath_walk_stack</a> (<a class="el" href="group__helpers.html#g11afc6451921f3169224096723483c64">pmath_stack_walker_t</a> walker, void *closure)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walk up the current thread's and its parents' stack.  <a href="#g55213cb0c89952b6aacf90f36ad4047b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#g077f3730ca4275b87d9a35bce6013e45">pmath_expr_t::pmath_gather_begin</a> (<a class="el" href="classpmath__t.html">pmath_t</a> pattern)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start gathering emitted objects.  <a href="#g077f3730ca4275b87d9a35bce6013e45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="classpmath__expr__t.html">pmath_expr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#ga2f732b35703986263e3a15592b4a46e">pmath_expr_t::pmath_gather_end</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finish gathering emitted objects.  <a href="#ga2f732b35703986263e3a15592b4a46e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#ga06135012f4d2a0faf696c0cd1111075">pmath_expr_t::pmath_emit</a> (<a class="el" href="classpmath__t.html">pmath_t</a> object, <a class="el" href="classpmath__t.html">pmath_t</a> tag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Emit an object to be gathered by the appropriate surounding <a class="el" href="group__helpers.html#g077f3730ca4275b87d9a35bce6013e45" title="Start gathering emitted objects.">pmath_gather_begin()</a> ... <a class="el" href="group__helpers.html#ga2f732b35703986263e3a15592b4a46e" title="Finish gathering emitted objects.">pmath_gather_end()</a> function pair.  <a href="#ga06135012f4d2a0faf696c0cd1111075"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#g96660afa0732edf675653eb6ddeab0a4">pmath_t::pmath_build_value_v</a> (const char *format, va_list args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a List of objects with a format string.  <a href="#g96660afa0732edf675653eb6ddeab0a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#g13a748aa283c5f5408cce037d3ad224d">pmath_t::pmath_build_value</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a List of objects with a format string.  <a href="#g13a748aa283c5f5408cce037d3ad224d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="classpmath__expr__t.html">pmath_expr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#g24403dfbd825b17fc4c6da5973922184">pmath_expr_t::pmath_options_extract</a> (<a class="el" href="classpmath__expr__t.html">pmath_expr_t</a> expr, size_t last_nonoption)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract custom option values from an expression.  <a href="#g24403dfbd825b17fc4c6da5973922184"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#gc244ab0720278b396976728a39f8bde6">pmath_expr_t::pmath_option_value</a> (<a class="el" href="classpmath__t.html">pmath_t</a> fn, <a class="el" href="classpmath__t.html">pmath_t</a> name, <a class="el" href="classpmath__t.html">pmath_t</a> extra)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a option value of a given function.  <a href="#gc244ab0720278b396976728a39f8bde6"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Utility functuions for pMath Objects and Expressions. 
<p>
Here are some utility functions that simplify access to Expressions (or pMath Objects in general), but do not realy fit one of these topics. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g11afc6451921f3169224096723483c64"></a><!-- doxytag: member="helpers.h::pmath_stack_walker_t" ref="g11afc6451921f3169224096723483c64" args=")(pmath_t head, void *closure)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a>(* <a class="el" href="group__helpers.html#g11afc6451921f3169224096723483c64">pmath_stack_walker_t</a>)(<a class="el" href="classpmath__t.html">pmath_t</a> head, void *closure)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A stack walker function. 
<p>
The return value specifies, whether the walk on the stack go on. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g66eb580a000ee1d778b43dec124f170d"></a><!-- doxytag: member="helpers.h::pmath_is_expr_of" ref="g66eb580a000ee1d778b43dec124f170d" args="(pmath_t obj, pmath_symbol_t head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a> pmath_is_expr_of           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmath__symbol__t.html">pmath_symbol_t</a>&nbsp;</td>
          <td class="paramname"> <em>head</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if an object is an expression with a specified head. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>A pMath object. It wont be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>A pMath symbol. It wont be freed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE iff obj is an expression with the given <em>head</em> which must be a symbol. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g68d264fe6b3db0931b4d0a8d5c7427f5"></a><!-- doxytag: member="helpers.h::pmath_is_expr_of_len" ref="g68d264fe6b3db0931b4d0a8d5c7427f5" args="(pmath_t obj, pmath_symbol_t head, size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a> pmath_is_expr_of_len           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmath__symbol__t.html">pmath_symbol_t</a>&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if an object is an expression with a specified head and length. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>A pMath object. It wont be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>A pMath symbol. It wont be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The requested expression length. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE iff obj is an expression with the given <em>length</em> and <em>head</em> which must be a symbol. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g70aa270956b6c8f8eb43431f9775ae88"></a><!-- doxytag: member="helpers.h::pmath_current_head" ref="g70aa270956b6c8f8eb43431f9775ae88" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="classpmath__t.html">pmath_t</a> pmath_current_head           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the currently evaluated function. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The head of the expression that is currently evaluated (in the calling thread). You have to destroy it. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g55213cb0c89952b6aacf90f36ad4047b"></a><!-- doxytag: member="helpers.h::pmath_walk_stack" ref="g55213cb0c89952b6aacf90f36ad4047b" args="(pmath_stack_walker_t walker, void *closure)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API void pmath_walk_stack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__helpers.html#g11afc6451921f3169224096723483c64">pmath_stack_walker_t</a>&nbsp;</td>
          <td class="paramname"> <em>walker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>closure</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Walk up the current thread's and its parents' stack. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>walker</em>&nbsp;</td><td>A callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>closure</em>&nbsp;</td><td>A pointer that will be provided to walker as the second argument. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g077f3730ca4275b87d9a35bce6013e45"></a><!-- doxytag: member="pmath_expr_t::pmath_gather_begin" ref="g077f3730ca4275b87d9a35bce6013e45" args="(pmath_t pattern)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API void pmath_gather_begin           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td>
          <td class="paramname"> <em>pattern</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start gathering emitted objects. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pattern</em>&nbsp;</td><td>A pattern that is used to determine which emitted objects should be gathered (testing the emit-tag, not the object itself). It will be freed.</td></tr>
  </table>
</dl>
Use <a class="el" href="group__helpers.html#ga2f732b35703986263e3a15592b4a46e" title="Finish gathering emitted objects.">pmath_gather_end()</a> to finish gathering. Calls to <a class="el" href="group__helpers.html#g077f3730ca4275b87d9a35bce6013e45" title="Start gathering emitted objects.">pmath_gather_begin()</a> ... <a class="el" href="group__helpers.html#ga2f732b35703986263e3a15592b4a46e" title="Finish gathering emitted objects.">pmath_gather_end()</a> can be nested.<p>
The emit-and-gather mechanism is useful when you want to create a list but do not know its final length in advance.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__helpers.html#ga06135012f4d2a0faf696c0cd1111075" title="Emit an object to be gathered by the appropriate surounding pmath_gather_begin()...">pmath_emit</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga2f732b35703986263e3a15592b4a46e"></a><!-- doxytag: member="pmath_expr_t::pmath_gather_end" ref="ga2f732b35703986263e3a15592b4a46e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="classpmath__expr__t.html">pmath_expr_t</a> pmath_gather_end           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finish gathering emitted objects. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A list of all emitted objects since the last <a class="el" href="group__helpers.html#g077f3730ca4275b87d9a35bce6013e45" title="Start gathering emitted objects.">pmath_gather_begin()</a> whose emit-tag matched the <code>pattern</code> parameter given to that <a class="el" href="group__helpers.html#g077f3730ca4275b87d9a35bce6013e45" title="Start gathering emitted objects.">pmath_gather_begin()</a>. You must free it.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__helpers.html#ga06135012f4d2a0faf696c0cd1111075" title="Emit an object to be gathered by the appropriate surounding pmath_gather_begin()...">pmath_emit</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga06135012f4d2a0faf696c0cd1111075"></a><!-- doxytag: member="pmath_expr_t::pmath_emit" ref="ga06135012f4d2a0faf696c0cd1111075" args="(pmath_t object, pmath_t tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API void pmath_emit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emit an object to be gathered by the appropriate surounding <a class="el" href="group__helpers.html#g077f3730ca4275b87d9a35bce6013e45" title="Start gathering emitted objects.">pmath_gather_begin()</a> ... <a class="el" href="group__helpers.html#ga2f732b35703986263e3a15592b4a46e" title="Finish gathering emitted objects.">pmath_gather_end()</a> function pair. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>The objcet to be emitted, it will be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A tag object. The sourounding Gather() with a pattern, that matches <code>tag</code> will collect the <code>object</code>. <code>tag</code> will be freed.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__helpers.html#g077f3730ca4275b87d9a35bce6013e45" title="Start gathering emitted objects.">pmath_gather_begin</a> <p>
<a class="el" href="group__helpers.html#ga2f732b35703986263e3a15592b4a46e" title="Finish gathering emitted objects.">pmath_gather_end</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g96660afa0732edf675653eb6ddeab0a4"></a><!-- doxytag: member="pmath_t::pmath_build_value_v" ref="g96660afa0732edf675653eb6ddeab0a4" args="(const char *format, va_list args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="classpmath__t.html">pmath_t</a> pmath_build_value_v           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a List of objects with a format string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>A string that specifies the tuple's item's type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>A va_list - variable argument list.</td></tr>
  </table>
</dl>
This function interface is only given if stdarg.h was included before.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__helpers.html#g13a748aa283c5f5408cce037d3ad224d" title="Generate a List of objects with a format string.">pmath_build_value</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g13a748aa283c5f5408cce037d3ad224d"></a><!-- doxytag: member="pmath_t::pmath_build_value" ref="g13a748aa283c5f5408cce037d3ad224d" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="classpmath__t.html">pmath_t</a> pmath_build_value           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a List of objects with a format string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>A string that specifies the tuple's item's type. See below. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>The tuple/list items</td></tr>
  </table>
</dl>
The format string characters specify the item's type:<ul>
<li><code>b</code> [int] converts a C int to True or False</li></ul>
<p>
<ul>
<li><code>i</code> [int]</li><li><code>l</code> [long int]</li><li><code>k</code> [long long int]</li><li><code>n</code> [ssize_t]</li></ul>
<p>
<ul>
<li><code>I</code> [unsigned int]</li><li><code>L</code> [unsigned long int]</li><li><code>K</code> [unsigned long long int]</li><li><code>N</code> [size_t]</li></ul>
<p>
<ul>
<li><code>f</code> [double] NaN's and Ininity are converted to Indeterminate and +/-Infinity</li></ul>
<p>
<ul>
<li><code>o</code> [<a class="el" href="classpmath__t.html" title="The basic type of all pMath objects.">pmath_t</a>] A pMath Object, the reference is stolen</li></ul>
<p>
<ul>
<li><code>c</code> [int] convert a C int representing a (unicode) character to a string of length 1.</li></ul>
<p>
<ul>
<li><code>s</code> [char*] converts a zero-terminated C string to a pMath string using Latin-1 encoding.</li></ul>
<p>
<ul>
<li><code>s#</code> [char*,int] takes a char buffer and a length to build a pMath string of that length using Latin-1 encoding.</li></ul>
<p>
<ul>
<li><code>z</code> [char*] a zero-terminated C string and converts it to a symbol using <a class="el" href="group__symbols.html#g597a971f788584cac3f327f1afdd5f41" title="Find a symbol in the current namespace search path.">pmath_symbol_find()</a>.</li></ul>
<p>
<ul>
<li><code>u</code> [char*] converts a zero-terminated C string to a pMath string using UTF-8 encoding.</li></ul>
<p>
<ul>
<li><code>u#</code> [char*,int] takes a char buffer and a length to build a pMath string of that length using UTF-8 encoding.</li></ul>
<p>
<ul>
<li><code>U</code> [uint16_t*] converts a zero-terminated double-byte C string to a pMath string using UTF-16 encoding. This is generally useful only where sizeof(uint16_t) == sizeof(wchar_t), e.g. on Windows but not on Linux.</li></ul>
<p>
<ul>
<li><code>U#</code> [uint16_t*,int] takes a character buffer and a length to build a pMath string of that length using UTF-16 encoding. This is generally useful only on platforms with sizeof(uint16_t) == sizeof(wchar_t), e.g. on Windows but not on Linux.</li></ul>
<p>
<ul>
<li><code>C<em>tt</em></code> [maching the 2 t's] build a complex value</li><li><code>Q<em>tt</em></code> [maching the 2 t's] build a rational value from two integers.</li></ul>
<p>
<ul>
<li><code>(items)</code> [matching items] constructs a sublist of items.</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When the format string denotes only one object, this object will be returned alone. So for a <a class="el" href="classpmath__t.html" title="The basic type of all pMath objects.">pmath_t</a> x, pmath_build_value("o", x) == x. <br>
 If you want to return a list in any case, use "(...)": "i" gives an integer, "ii" and "(ii)" a list of two integers and "(i)" a list of one integer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g24403dfbd825b17fc4c6da5973922184"></a><!-- doxytag: member="pmath_expr_t::pmath_options_extract" ref="g24403dfbd825b17fc4c6da5973922184" args="(pmath_expr_t expr, size_t last_nonoption)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="classpmath__expr__t.html">pmath_expr_t</a> pmath_options_extract           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmath__expr__t.html">pmath_expr_t</a>&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>last_nonoption</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract custom option values from an expression. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The expression that may custom option values. It wont be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last_nonoption</em>&nbsp;</td><td>The index of the last argument that is not an option rule. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A list of all given option values or NULL on error. You must destroy it.</dd></dl>
Imagine, <code>expr</code> = `f(a,b,A-&gt;1,B-&gt;2)` and <code>last_nonoption</code> is 2, then the result value is a list `{A-&gt;1, B-&gt;2}`. You can use this return value as the <code>extra</code> parameter in <a class="el" href="group__helpers.html#gc244ab0720278b396976728a39f8bde6" title="Retrieve a option value of a given function.">pmath_option_value()</a>.<p>
When <code>last_nonoption</code> was 1, a message would be generated (b is no rule ...) and the return value is NULL. In that case, the calling function should have no further effects and return. 
</div>
</div><p>
<a class="anchor" name="gc244ab0720278b396976728a39f8bde6"></a><!-- doxytag: member="pmath_expr_t::pmath_option_value" ref="gc244ab0720278b396976728a39f8bde6" args="(pmath_t fn, pmath_t name, pmath_t extra)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="classpmath__t.html">pmath_t</a> pmath_option_value           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td>
          <td class="paramname"> <em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td>
          <td class="paramname"> <em>extra</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve a option value of a given function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>The function for which the requested option value is defined. It wont be freed. If it is NULL, the current head (see <a class="el" href="group__helpers.html#g70aa270956b6c8f8eb43431f9775ae88">pmath_current_head</a> ) will be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the option value (in general, a symbol). It wont be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>extra</em>&nbsp;</td><td>A list of extra option rules or PMATH_UNDEFINED. It wont be freed. If it is not PMATH_UNDEFINED, it must be a rule (`a-&gt;b`, `a:&gt;b`) or a list of rules. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The requested option value. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Apr 18 19:34:50 2010 for pMath by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
