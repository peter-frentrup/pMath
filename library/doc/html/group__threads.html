<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>pMath: Multithreading with pMath</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Multithreading with pMath</h1>The Thread abstraction in pMath.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmath__threadlock__t.html">pmath_threadlock_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A reentrant lock for threads.  <a href="classpmath__threadlock__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmath__thread__t.html">pmath_thread_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Representation of a thread.  <a href="classpmath__thread__t.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#ga545e19cccf64ee4848a5506fa20cf21">pmath_thread_local_save</a> (<a class="el" href="classpmath__t.html">pmath_t</a> key, <a class="el" href="classpmath__t.html">pmath_t</a> value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store a thread/thread-local value.  <a href="#ga545e19cccf64ee4848a5506fa20cf21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#g64fe008ee1e3a4841eb98ca13e212537">pmath_thread_local_load</a> (<a class="el" href="classpmath__t.html">pmath_t</a> key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a thread/thread-local value.  <a href="#g64fe008ee1e3a4841eb98ca13e212537"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#gf1aa6d6603faaa4120207be6108e356c">pmath_throw</a> (<a class="el" href="classpmath__t.html">pmath_t</a> exception)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Throw an exception.  <a href="#gf1aa6d6603faaa4120207be6108e356c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#gf791e0088342297d6511a4481421f446">pmath_catch</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Catch any exception.  <a href="#gf791e0088342297d6511a4481421f446"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#gb75a9c87401fddb42b297ddb0495415f">pmath_aborting</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries whether pMath was requested to abort the evaluation of the current thread.  <a href="#gb75a9c87401fddb42b297ddb0495415f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#g84e45036b76764def6390af12d2070bf">pmath_abort_please</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Requests pMath to abort the current evaluation.  <a href="#g84e45036b76764def6390af12d2070bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g688141bacfb504b83dc319695f243b95"></a><!-- doxytag: member="threads::pmath_suspend_all_please" ref="g688141bacfb504b83dc319695f243b95" args="(void)" -->
PMATH_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#g688141bacfb504b83dc319695f243b95">pmath_suspend_all_please</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suspend all other threads. This function does not realy suspend threads immediately. Any other thread, that calls <a class="el" href="group__threads.html#gb75a9c87401fddb42b297ddb0495415f" title="Queries whether pMath was requested to abort the evaluation of the current thread...">pmath_aborting()</a> (or <a class="el" href="group__threads.html#g3932a5c364197c999dfab0aeb28e8779" title="Queries whether pMath was requested to abort the evaluation of a specific thread...">pmath_thread_aborting()</a>), will block until we call <a class="el" href="group__threads.html#gccf30e13ea6e65136fca6294267f00c2" title="Resume all other threads.">pmath_resume_all()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#gccf30e13ea6e65136fca6294267f00c2">pmath_resume_all</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resume all other threads.  <a href="#gccf30e13ea6e65136fca6294267f00c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#gfcbd1d376791cb95a78e102366b7b79a">pmath_threadlock_t::pmath_thread_call_locked</a> (<a class="el" href="classpmath__threadlock__t.html">pmath_threadlock_t</a> *threadlock_ptr, <a class="el" href="group__general__types.html#ge1a454657f18f3cc54508adeccccbcbc">pmath_callback_t</a> callback, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a function synchronized with a threadlock.  <a href="#gfcbd1d376791cb95a78e102366b7b79a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="classpmath__thread__t.html">pmath_thread_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#g908b6ee94115539a20530cfb051dc52c">pmath_thread_t::pmath_thread_get_current</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current pMath thread.  <a href="#g908b6ee94115539a20530cfb051dc52c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="classpmath__thread__t.html">pmath_thread_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#gb0e137fb921f9b329a8a9e7c4efa3b3d">pmath_thread_t::pmath_thread_get_parent</a> (<a class="el" href="classpmath__thread__t.html">pmath_thread_t</a> thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a thread's direct parent.  <a href="#gb0e137fb921f9b329a8a9e7c4efa3b3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#g4409c7f042a1809eee72329002635fb9">pmath_thread_t::pmath_thread_is_parent</a> (<a class="el" href="classpmath__thread__t.html">pmath_thread_t</a> parent, <a class="el" href="classpmath__thread__t.html">pmath_thread_t</a> child)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries whether a thread is one of the parents of another.  <a href="#g4409c7f042a1809eee72329002635fb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PMATH_API <a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#g3932a5c364197c999dfab0aeb28e8779">pmath_thread_t::pmath_thread_aborting</a> (<a class="el" href="classpmath__thread__t.html">pmath_thread_t</a> thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries whether pMath was requested to abort the evaluation of a specific thread or its parents.  <a href="#g3932a5c364197c999dfab0aeb28e8779"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The Thread abstraction in pMath. 
<p>
pMath stores several data local to a thread. Therefor, it maintains a <a class="el" href="classpmath__thread__t.html" title="The Representation of a thread.">pmath_thread_t</a> in every operating system thread it runs on. Those <a class="el" href="classpmath__thread__t.html" title="The Representation of a thread.">pmath_thread_t</a> variables are created and freed via <a class="el" href="group__frontend.html#gfb9f2c789bee5295c6794d16c0164943" title="Initialize the pMath CAS library.">pmath_init()</a> and <a class="el" href="group__frontend.html#g012705e1fd248a7cebf738bae6375dd9" title="Free all resources used by the pMath CAS library and unload all modules.">pmath_done()</a> respectively. Thus, you have to call those two functions once in every thread that uses pMath functions (and abort the thread if <a class="el" href="group__frontend.html#gfb9f2c789bee5295c6794d16c0164943" title="Initialize the pMath CAS library.">pmath_init()</a> fails).<p>
pMath Threads can have parents. While one thread is running, its parent thread waits (for all its children) and is effectively immutable. This way, child threads can read their parent thread's local variables.<h2><a class="anchor" name="section_thread_syncronization">
Synchronization</a></h2>
In other environments, you normaly do synchronization with mutexes and the like. But if we did so, a deadlock could occur when a mutex is allready locked by the parent thread, which in turn is waiting for its children to finish.<p>
The solution is to use pMath threadlocks: You simply synchronize with a <a class="el" href="classpmath__symbol__t.html">pmath_symbol_t</a> through <a class="el" href="group__symbols.html#g95b141d9cb33fba80d6a807f304ee3b7" title="Execute a function synchronized to a symbol.">pmath_symbol_synchronized()</a> or directly with a <a class="el" href="classpmath__threadlock__t.html">pmath_threadlock_t</a> and <a class="el" href="group__threads.html#gfcbd1d376791cb95a78e102366b7b79a" title="Execute a function synchronized with a threadlock.">pmath_thread_call_locked()</a>. This is reentrant and locks execution to a given thread <em>and</em> its child threads. pMath cares about avoiding deadlocks behind the scenes.<p>
Note that threadlocks are needed only if the syncronized code might create child threads or calls other code that utilizes thread locks. Threads might be created by <a class="el" href="classpmath__t.html#d95c86ef0de178de4d3560518c8a8157" title="Evaluate an object.">pmath_evaluate()</a> &amp; co.<p>
In other situations, you should use mutexes/semaphores from your operating system library or spinlocks (see <a class="el" href="group__atomic__ops.html#gf143a22332da6a2065bac14069ecbf7f" title="Try to aquire a lock.">pmath_atomic_lock()</a> and <a class="el" href="group__atomic__ops.html#ga61bbbab4adc550cc66d1d5f9cf22afd" title="Release a previously aquired lock.">pmath_atomic_unlock()</a> ), because they are much faster.<p>
For some simple changes on global integer/pointer variables, you can use <a class="el" href="group__atomic__ops.html">Atomic Operations</a>. <hr><h2>Function Documentation</h2>
<a class="anchor" name="ga545e19cccf64ee4848a5506fa20cf21"></a><!-- doxytag: member="threads.h::pmath_thread_local_save" ref="ga545e19cccf64ee4848a5506fa20cf21" args="(pmath_t key, pmath_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="classpmath__t.html">pmath_t</a> pmath_thread_local_save           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Store a thread/thread-local value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key that can be used to obtain the value with _pmath_thread_local_load(). It wont be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The thread/thread-local value. It will be freed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__objects.html#ge2646df76dcb0113715322b13a1f36f0">PMATH_UNDEFINED</a> or the previous value that was stored with the same key. You must destroy it.</dd></dl>
Note that keys of the form `symboltag` are used to store whether a message should be suppressed (value PMATH_SYMBOL_OFF) or not (value NULL).<p>
All keys that are <a class="el" href="group__objects.html#ge2646df76dcb0113715322b13a1f36f0">magic numbers</a>, have special meanings for <a class="el" href="group__threads.html#ga545e19cccf64ee4848a5506fa20cf21" title="Store a thread/thread-local value.">pmath_thread_local_save()</a>. You should not use them as the a key.<p>
Keys which are only symbols are used for thread-local symbols (<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__symbols.html#g5d508ec0d32d617b6c642de54907ee17" title="The (bitset) type of symbol attributes.">pmath_symbol_attributes_t</a>). </dd></dl>

</div>
</div><p>
<a class="anchor" name="g64fe008ee1e3a4841eb98ca13e212537"></a><!-- doxytag: member="threads.h::pmath_thread_local_load" ref="g64fe008ee1e3a4841eb98ca13e212537" args="(pmath_t key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="classpmath__t.html">pmath_t</a> pmath_thread_local_load           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load a thread/thread-local value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>A key that was used to save the value with _pmath_thread_local_save() before. It wont be freed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>PMATH_UNDEFINED or the stored value. You must destroy the it.</dd></dl>
If there is nothing stored for key in the current thread, its parent threads are processed. If none of them stores something under `key` and key is a symbol, The global value is used. 
</div>
</div><p>
<a class="anchor" name="gf1aa6d6603faaa4120207be6108e356c"></a><!-- doxytag: member="threads.h::pmath_throw" ref="gf1aa6d6603faaa4120207be6108e356c" args="(pmath_t exception)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API void pmath_throw           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmath__t.html">pmath_t</a>&nbsp;</td>
          <td class="paramname"> <em>exception</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Throw an exception. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exception</em>&nbsp;</td><td>The exception to be thrown. It will be freed. You cannot throw the <a class="el" href="group__objects.html#ge2646df76dcb0113715322b13a1f36f0">magic number PMATH_UNDEFINED</a>.</td></tr>
  </table>
</dl>
If there is already an uncought exception, this new exception is lost. 
</div>
</div><p>
<a class="anchor" name="gf791e0088342297d6511a4481421f446"></a><!-- doxytag: member="threads.h::pmath_catch" ref="gf791e0088342297d6511a4481421f446" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="classpmath__t.html">pmath_t</a> pmath_catch           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Catch any exception. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>exception The exception to be thrown. If there is no exception available, PMATH_UNDEFINED will be returned.</dd></dl>
If you cannot handle the exception, you can re-throw it with <a class="el" href="group__threads.html#gf1aa6d6603faaa4120207be6108e356c" title="Throw an exception.">pmath_throw()</a>. 
</div>
</div><p>
<a class="anchor" name="gb75a9c87401fddb42b297ddb0495415f"></a><!-- doxytag: member="threads.h::pmath_aborting" ref="gb75a9c87401fddb42b297ddb0495415f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a> pmath_aborting           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queries whether pMath was requested to abort the evaluation of the current thread. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the user called <a class="el" href="group__threads.html#g84e45036b76764def6390af12d2070bf" title="Requests pMath to abort the current evaluation.">pmath_abort_please()</a> or an exception was thrown or a time-out is passed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g84e45036b76764def6390af12d2070bf"></a><!-- doxytag: member="threads.h::pmath_abort_please" ref="g84e45036b76764def6390af12d2070bf" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API void pmath_abort_please           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Requests pMath to abort the current evaluation. 
<p>
This function is signal-safe.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__frontend.html#g4934c2dc54f852627f8b291543a21e43" title="Requests pMath to stop aborting the current evaluation.">pmath_continue_after_abort()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gccf30e13ea6e65136fca6294267f00c2"></a><!-- doxytag: member="threads.h::pmath_resume_all" ref="gccf30e13ea6e65136fca6294267f00c2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API void pmath_resume_all           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resume all other threads. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__threads.html#g688141bacfb504b83dc319695f243b95" title="Suspend all other threads. This function does not realy suspend threads immediately...">pmath_suspend_all_please</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfcbd1d376791cb95a78e102366b7b79a"></a><!-- doxytag: member="pmath_threadlock_t::pmath_thread_call_locked" ref="gfcbd1d376791cb95a78e102366b7b79a" args="(pmath_threadlock_t *threadlock_ptr, pmath_callback_t callback, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API void pmath_thread_call_locked           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmath__threadlock__t.html">pmath_threadlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>threadlock_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__general__types.html#ge1a454657f18f3cc54508adeccccbcbc">pmath_callback_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a function synchronized with a threadlock. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadlock_ptr</em>&nbsp;</td><td>A pointer to the threadlock. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>The function to be executed when the symbol is locked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer that will be passed to callback.</td></tr>
  </table>
</dl>
All you have to do is initialize the threadlock <code>threadlock_ptr</code> points to with NULL before you call this function for the first time: <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <a class="code" href="classpmath__threadlock__t.html" title="A reentrant lock for threads.">pmath_threadlock_t</a> lock = NULL;
...
pmath_thread_call_locked(&amp;lock, my_callback, my_data);
</pre></div><p>
To synchronize with a symbol, use <a class="el" href="group__symbols.html#g95b141d9cb33fba80d6a807f304ee3b7" title="Execute a function synchronized to a symbol.">pmath_symbol_synchronized()</a>. 
</div>
</div><p>
<a class="anchor" name="g908b6ee94115539a20530cfb051dc52c"></a><!-- doxytag: member="pmath_thread_t::pmath_thread_get_current" ref="g908b6ee94115539a20530cfb051dc52c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="classpmath__thread__t.html">pmath_thread_t</a> pmath_thread_get_current           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current pMath thread. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classpmath__thread__t.html">pmath_thread_t</a>. This is NULL, if you did not register the current thread to pMath via <a class="el" href="group__frontend.html#gfb9f2c789bee5295c6794d16c0164943" title="Initialize the pMath CAS library.">pmath_init()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb0e137fb921f9b329a8a9e7c4efa3b3d"></a><!-- doxytag: member="pmath_thread_t::pmath_thread_get_parent" ref="gb0e137fb921f9b329a8a9e7c4efa3b3d" args="(pmath_thread_t thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="classpmath__thread__t.html">pmath_thread_t</a> pmath_thread_get_parent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmath__thread__t.html">pmath_thread_t</a>&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a thread's direct parent. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>A thread. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The direct parent of thread. Usualy NULL. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4409c7f042a1809eee72329002635fb9"></a><!-- doxytag: member="pmath_thread_t::pmath_thread_is_parent" ref="g4409c7f042a1809eee72329002635fb9" args="(pmath_thread_t parent, pmath_thread_t child)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a> pmath_thread_is_parent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmath__thread__t.html">pmath_thread_t</a>&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmath__thread__t.html">pmath_thread_t</a>&nbsp;</td>
          <td class="paramname"> <em>child</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queries whether a thread is one of the parents of another. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>A thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>child</em>&nbsp;</td><td>A thread. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE, if parent is a parent thread of child or if parent == child. FALSE otherwise.</dd></dl>
It is important to know that a parent thread is never executed in parallel with its children. 
</div>
</div><p>
<a class="anchor" name="g3932a5c364197c999dfab0aeb28e8779"></a><!-- doxytag: member="pmath_thread_t::pmath_thread_aborting" ref="g3932a5c364197c999dfab0aeb28e8779" args="(pmath_thread_t thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PMATH_API <a class="el" href="group__general__types.html#gc92090cb0b56345d6c379ed2341d4ef4">pmath_bool_t</a> pmath_thread_aborting           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmath__thread__t.html">pmath_thread_t</a>&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queries whether pMath was requested to abort the evaluation of a specific thread or its parents. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>A thread that should be tested. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the given thread should abort evaluation.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__threads.html#gb75a9c87401fddb42b297ddb0495415f" title="Queries whether pMath was requested to abort the evaluation of the current thread...">pmath_aborting</a> </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Sep 18 18:13:03 2010 for pMath by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
