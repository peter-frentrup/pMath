
BeginPackage("Javassist`", {"Java`", "ExperimentalSyntax`"})

Javassist`ImplementJavaClass

Begin("Javassist`Private`")


Javassist`Private`DoCallback
Javassist`Private`javaThrow
Javassist`Private`BuildImplementationClass
Javassist`Private`GetImplementationClass


AddToClassPath(ToFileName(ParentDirectory($Input), "javassist.jar"))


ImplementJavaClass::usage:= "ImplementJavaClass(\(StyleBox(\"class\", \"Arg\")\), {\"\(StyleBox(\"meth\", \"Arg\")\)\(SubscriptBox(\"1\")\)\" \[Rule] \(StyleBox(\"sym\", \"Arg\")\)\(SubscriptBox(\"1\")\), \"\(StyleBox(\"meth\", \"Arg\")\)\(SubscriptBox(\"2\")\)\" \[Rule] \(StyleBox(\"sym\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) creates a new Java object of type \(StyleBox(\"class\", \"Arg\")\) with methods \(StyleBox(\"meth\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) implemented by \(StyleBox(\"pMath\", \"TI\")\) functions \(StyleBox(\"sym\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nImplementJavaClass({\(StyleBox(\"class\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"class\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \[Ellipsis]) allows multiple Java interfaces to be specified."


javaThrow(~ex)::= Throw(JavaException(ex, ex @ toString(), Map(ex @ getStackTrace(), # @ toString() &)))

Function DoCallback(~symbol, ~javaObject, ~methodName, ~argumentList) {
	javaThrow(JavaNew(
		"java.lang.UnsupportedOperationException", 
		"Not yet implemented: " ++ ClassName(javaObject) ++ "." ++ methodName ++ "(\[Ellipsis])"))
}
Protect(DoCallback)


ImplementJavaClass::multi:= "Cannot derive from multiple classes."
ImplementJavaClass::miss:= "No implementation for abstract method `1` given."
ImplementJavaClass::static:= "Cannot implement static method `1`."


Function BuildImplementationClass(classes: {~~~:JavaClass}, methods: {~~~:String}) {
	Local(class, m)
	With(pool:= JavaClass("javassist.ClassPool") @ getDefault())
	With(ctclasses:= classes.Map(pool @ get(First(#)) &))
	With(ctinterfaces:= ctclasses.Select(# @ isInterface() &))
	With(ctsuper:= Complement(ctclasses, ctinterfaces))
	With(abstract:= JavaClass("java.lang.reflect.Modifier") @ ABSTRACT)
	With(static:= JavaClass("java.lang.reflect.Modifier") @ STATIC)
	With(ctmethods:= ctclasses.Map(# @ getMethods() &).Flatten.Select(
			BitAnd(# @ getModifiers(), abstract) != 0 || 
			!methods.IsFreeOf(# @ getName()) &))
	
	If(Length(ctsuper) > 1) {
		Message(ImplementJavaClass::multi);
		Return($Failed)
	}
	
	Do(m -> ctmethods) {
		If(BitAnd(m @ getModifiers(), static) != 0) {
			Message(ImplementJavaClass::static, m @ toString());
			Return(Return($Failed));
		}
		If(methods.IsFreeOf(m @ getName())) {
			Message(ImplementJavaClass::miss, m @ toString());
			Return(Return($Failed));
		}
	}
	
	With(newCtClass:= pool @ makeClass("pmath.javabridge." ++ SymbolName(class)))
	With(classLoader:= First @ Select(
		{pool @ getClassLoader(), JavaClass("java.lang.ClassLoader") @ getSystemClassLoader()}, 
		# =!= /\/ &))
	
	Finally(
		Block {
			ctinterfaces.Scan(newCtClass @ addInterface(#) &);
			If(ctsuper.Length = 1) {
				newCtClass @ setSuperclass( First(ctsuper) )
			}
			
			newCtClass @ addField(JavaClass("javassist.CtField") @ make("private String __pmath_impl", newCtClass));
			newCtClass @ addMethod(
				JavaClass("javassist.CtNewMethod") @ make(
					"public void __pmath_init(String impl){ if(this.__pmath_impl == null) this.__pmath_impl = impl; }", 
					newCtClass));
			
			Do(m -> ctmethodsWithImpl) {
				With(origMethod:= m[1])
				With(implMethod:= Namespace(m[2]) ++ SymbolName(m[2]))
				With(modifiers:= BitAnd(origMethod @ getModifiers(), BitNot(abstract)))
				With(returnType:= origMethod @ getReturnType())
				With(parameters:= origMethod @ getParameterTypes())
				With(exceptions:= origMethod @ getExceptionTypes())
				With(methodName:= origMethod @ getName())
				With(javaBody:= "{ return ($r)pmath.Core.execute(\
									\"Javassist`Private`DoCallback(\" + this.__pmath_impl + \", `1`, " ++ (m @ getName()) ++ ", `2`)\", \
									new Object[]{ this, $args });\
								}")
				With(newMethod:= JavaClass("javassist.CtNewMethod") @ make(
										modifiers, returnType, methodName, parameters, exceptions, javaBody, newCtClass))
				
				newCtClass @ addMethod(newMethod)
			}
			
			Return(Evaluate(newCtClass @ toClass(classLoader, /\/)));
		},
		newCtClass @ prune()
	)
}

Function GetImplementationClass(classes: {~~~:JavaClass}, methods: {~~~:String}) {
	With(class:= BuildImplementationClass(classes, methods))
	If(class =!= $Failed) {
		GetImplementationClass(classes, methods):= class
	}
	Return(class)
}
	

Options(ImplementJavaClass):= {ConstructorArguments->{}}

ImplementJavaClass(class: (~:String | ~:JavaClass), methods: {(~:String -> ~:Symbol)***}, options: OptionsPattern())::=
	ImplementJavaClass({class}, methods, options)

ImplementJavaClass(classes: {(~:String | ~:JavaClass)***}, methods: {(~:String -> ~:Symbol)***}, options: OptionsPattern())::=
	ImplementJavaClass(classes.Map(If(IsString(#), JavaClass(#), #)&), methods, options)

Function ImplementJavaClass(classes: {~~~:JavaClass}, methods: {(~:String -> ~:Symbol)***}, OptionsPattern()) {
	With(class:= GetImplementationClass(Union(classes), Union(methods[All, 1])))
	If(class === $Failed) {
		Return($Failed)
	}
	
	With(obj:= JavaNew(class @ getName(), Sequence @@ OptionValue(ConstructorArguments)))
	If(obj =!= $Failed) {
		Local(impl, meth)
		Do(meth -> methods) {
			With(methodName:= meth[1], methodImpl:= meth[2])
			
			impl/: DoCallback(impl, ~this, methodName, {~~~args})::= methodImpl(args)
		}
		
		obj @ "__pmath_init"(LongForm(impl).ToString);
	}
	Return(obj);
}

Attributes(ImplementJavaClass):= {Protected, ReadProtected}


End()

EndPackage()
