
BeginPackage("Javassist`", {"Java`"})

Javassist`ImplementJavaClass

Begin("Javassist`Private`")


Javassist`Private`WithMultiple
Javassist`Private`DoCallback
Javassist`Private`javaThrow
Javassist`Private`BuildImplementationClass
Javassist`Private`GetImplementationClass


AddToClassPath(ToFileName(ParentDirectory($Input), "javassist.jar"))


ImplementJavaClass::usage:= "ImplementJavaClass(\(StyleBox(\"class\", \"Arg\")\), {\"\(StyleBox(\"meth\", \"Arg\")\)\(SubscriptBox(\"1\")\)\" \[Rule] \(StyleBox(\"sym\", \"Arg\")\)\(SubscriptBox(\"1\")\), \"\(StyleBox(\"meth\", \"Arg\")\)\(SubscriptBox(\"2\")\)\" \[Rule] \(StyleBox(\"sym\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}) creates a new Java object of type \(StyleBox(\"class\", \"Arg\")\) with methods \(StyleBox(\"meth\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\) implemented by \(StyleBox(\"pMath\", \"TI\")\) functions \(StyleBox(\"sym\", \"Arg\")\)\(SubscriptBox(StyleBox(\"i\", \"Arg\"))\).\nImplementJavaClass({\(StyleBox(\"class\", \"Arg\")\)\(SubscriptBox(\"1\")\), \(StyleBox(\"class\", \"Arg\")\)\(SubscriptBox(\"2\")\), \[Ellipsis]}, \[Ellipsis]) allows multiple Java interfaces to be specified."


javaThrow(~ex)::= Throw(JavaException(ex, ex @ toString(), Map(ex @ getStackTrace(), # @ toString() &)))

DoCallback(~symbol, ~javaObject, ~methodName, ~argumentList)::=
	javaThrow(JavaNew("java.lang.UnsupportedOperationException", "Not yet implemented: " ++ ClassName(javaClass) ++ "." ++ methodName ++ "(\[Ellipsis])"))
Protect(Javassist`Private`DoCallback)



/* WithMultiple({repl}, body) is like With(...) but the symbols in repl can be used in subsequent expressions inside repl.
 */
Attributes(WithMultiple):= {HoldAll}

WithMultiple({}, ~body)::= body
WithMultiple({~repl, ~~~rest}, ~body)::= With @@ HoldComplete({repl}, WithMultiple({rest}, body))



ImplementJavaClass::multi:= "Cannot derive from multiple classes."
ImplementJavaClass::miss:= "No implementation for abstract method `1` given."
ImplementJavaClass::static:= "Cannot implement static method `1`."


BuildImplementationClass(classes: {~~~:JavaClass}, methods: {~~~:String})::=
	Local({class},
		WithMultiple(
			{
				pool:=              JavaClass("javassist.ClassPool") @ getDefault();
				ctclasses:=         classes.Map(pool @ get(First(#)) &);
				ctinterfaces:=      ctclasses.Select(# @ isInterface() &);
				ctsuper:=           Complement(ctclasses, ctinterfaces);
				abstract:=          JavaClass("java.lang.reflect.Modifier") @ ABSTRACT;
				static:=            JavaClass("java.lang.reflect.Modifier") @ STATIC;
				ctmethods:=         ctclasses.Map(# @ getMethods() &).Flatten.Select(
				                       BitAnd(# @ getModifiers(), abstract) != 0 || 
				                       !methods.IsFreeOf(# @ getName()) &);
			},
			
			If(Length(ctsuper) > 1,
				Message(ImplementJavaClass::multi);
				Return($Failed));
				
			ctmethods.Scan(
				(
					If(BitAnd(# @ getModifiers(), static) != 0,
						Message(ImplementJavaClass::static, # @ toString());
						Return(Return($Failed));
						);
					If(methods.IsFreeOf(# @ getName()),
						Message(ImplementJavaClass::miss, # @ toString());
						Return(Return($Failed));
						);
				)&);
			
			WithMultiple(
				{
					newCtClass:=  pool @ makeClass("pmath.javabridge." ++ SymbolName(class));
					classLoader:= First({pool @ getClassLoader(), JavaClass("java.lang.ClassLoader") @ getSystemClassLoader()}.Select(# =!= /\/ &));
				},
				
				(
					ctinterfaces.Scan(newCtClass @ addInterface(#) &);
					If(ctsuper.Length = 1,
						newCtClass @ setSuperclass( First(ctsuper) ));
				
					newCtClass @ addField(JavaClass("javassist.CtField") @ make("private String __pmath_impl", newCtClass));
					newCtClass @ addMethod(
						JavaClass("javassist.CtNewMethod") @ make(
							"public void __pmath_init(String impl){ if(this.__pmath_impl == null) this.__pmath_impl = impl; }", 
							newCtClass));
				
					ctmethodsWithImpl.Scan(
						WithMultiple({
								origMethod:=  #[1],
								implMethod:=  Namespace(#[2]) ++ SymbolName(#[2]),
								modifiers:=   BitAnd(origMethod @ getModifiers(), BitNot(abstract)),
								returnType:=  origMethod @ getReturnType(),
								parameters:=  origMethod @ getParameterTypes(),
								exceptions:=  origMethod @ getExceptionTypes(),
								methodName:=  origMethod @ getName(),
								javaBody:=    "{ return ($r)pmath.Core.execute(\
													\"Javassist`Private`DoCallback(\" + this.__pmath_impl + \", `1`, " ++ (# @ getName()) ++ ", `2`)\", \
													new Object[]{ this, $args });\
											   }",
								newMethod:=   JavaClass("javassist.CtNewMethod") @ make(
												modifiers, returnType, methodName, parameters, exceptions, javaBody, newCtClass)
							},
							
							newCtClass @ addMethod(newMethod)
							)&);
					
					Return(Evaluate(newCtClass @ toClass(classLoader, /\/)));
					).Finally(newCtClass @ prune())
				)
			)
		)


GetImplementationClass(classes: {~~~:JavaClass}, methods: {~~~:String})::=
	With({class:= BuildImplementationClass(classes, methods)},
		If(class =!= $Failed,
			GetImplementationClass(classes, methods):= class); 
		class)
	

Options(ImplementJavaClass):= {ConstructorArguments->{}}

ImplementJavaClass(class: (~:String | ~:JavaClass), methods: {(~:String -> ~:Symbol)***}, options: OptionsPattern())::=
	ImplementJavaClass({class}, methods, options)

ImplementJavaClass(classes: {(~:String | ~:JavaClass)***}, methods: {(~:String -> ~:Symbol)***}, options: OptionsPattern())::=
	ImplementJavaClass(classes.Map(If(IsString(#), JavaClass(#), #)&), methods, options)

ImplementJavaClass(classes: {~~~:JavaClass}, methods: {(~:String -> ~:Symbol)***}, OptionsPattern())::=
	With({class:= GetImplementationClass(Union(classes), Union(methods[All, 1]))},
		If(class === $Failed,
			Return($Failed));
		
		With({obj:= JavaNew(class @ getName(), Sequence @@ OptionValue(ConstructorArguments))},
			If(obj =!= $Failed,
				Local({impl},
					methods.Scan(
						With({methodName:= #[1], methodImpl:= #[2]},
							impl/: DoCallback(impl, ~this, methodName, {~~~args})::= methodImpl(args)
							) &
						);
					obj @ "__pmath_init"(LongForm(impl).ToString);
					));
			Return(obj);
			)
		)

Attributes(ImplementJavaClass):= {Protected, ReadProtected}


End()

EndPackage()
