%
% Experimental syntax simplififcations.
%
% Reading and writing deeply nested expression trees (esp. nested With(...)) is hard. Espacially
% imperative definitions are hard to read because one can easily overlook a comma or miscount 
% parenthesis.
% This file enhances the pMath syntax with some syntactic suggar for With, Local, If, Do, While, 
% and related functions. This is highly experimental. Especially the performance impact on 
% MakeExpression needs to be investigated.
%
% These syntax enhancements are only active while ExperimentalSyntax` is in the current 
% $NamespacePath. So any package may include <<ExperimentalSyntax` without breaking other packages.
%
% Note that there must be no space before "(" and no line-break before "{". Also, the braces around
% blocks are mandatory. If ever mixed within (mathematical) expressions, these constructs should
% be placed in parenthesis.
% The reason is that inter-operand whitespace is treated by the internal parser (StringToBoxes) as 
% implicit multiplication.
%
% Note that ToBoxes() of expressions involving unevaluated products of Lists will not be 
% reparsed correctly when used in strange combination with the With/If/... functions.
% Example: Hold(If(a,b,c) * {1,2,3})
% This could be fixed by letting ToBoxes() insert "*" or "\[Times]" or "\[InvisibleTimes]" instead 
% of the implicit " " in front of opening braces, the same way they do it with opening parenthesis.
%
%
% Supported syntax additions are
% Conditional constructs:
%	If(cond1) {
%		block1
%	} Else If(cond2) {
%		block2
%	} Else {
%		block3
%	}
%
%	Switch(expr) {
%		Case(pat1) {
%			block1
%		}
%		Case(pat2) {
%			block2
%		}
%	}
%
% Looping constructs:
%	While(cond) {
%		block
%	}
%
%	Do(i->1..3) {
%		block
%	}
%
% Scoping constructs:
%	With(vars) {
%		block
%	}
%
%	Local(vars) {
%		block
%	}
%
% There is also a form to force parsing in block mode (because `{block}` alone gives a list).
%	Block {
%		block
%	}
%
% Defining functions also has a new syntax
%	Function name(~arg) {
%		body
%	}
%
%
% Moreover, within such a `block`, automatic scope nesting is applied
%	Do(1) {
%		Print(x)
%		With(x:= 5)
%		Print(x, " ", y);
%		Local(y, z:= 7)
%		Print(y, " ", z)
%	}
%
BeginPackage("ExperimentalSyntax`", {"Developer`"})

Begin("ExperimentalSyntax`Private`")


%
% Experimental syntax is only active if ExperimentalSyntax` is in current namespace path.
%
$HaveExperimentalSyntax::= $Namespace === "ExperimentalSyntax`" || !$NamespacePath.IsFreeOf("ExperimentalSyntax`")
Protect($HaveExperimentalSyntax)

%
% Copied from auto/core/graphics/init.pmath
%
composeHeldExpr(~sym, HoldComplete(~~~a))::= 
	HoldComplete(sym(a))
composeHeldExpr(~sym, HoldComplete(~~~a), HoldComplete(~~~b), ~~~c:HoldComplete)::=
	composeHeldExpr(sym, HoldComplete(a,b), c)
composeHeldExpr(~~~args)::= (
	Message(composeHeldExpr::inv, {args})
	$Failed)


debugEcho(~x)::= (Print(x); x)
debugEcho(~x, ~label)::= (Print(label, x); x)
debugEcho(~x, ~label, ~f)::= (Print(label, f(x)); x)
debugEchoFunction(~~~args)(~x)::= debugEcho(x, args)

Unprotect(MakeExpression)

%
% parsing statement blocks
%
makeBlockExpression()::= HoldComplete(/\/)
makeBlockExpression({})::= HoldComplete(/\/)
makeBlockExpression(~boxes)::=
	With({debugInfo:= GetDebugInfo(boxes), stmts:= Gather(emitMakeStatements(boxes)).Last.Apply(HoldComplete).Flatten(1)},
		If(Length(stmts) = 0, Return(HoldComplete(/\/)));
		If(Length(stmts) = 1, Return(stmts));
		Return(composeHeldExpr(EvaluationSequence, stmts).SetDebugInfoAt(debugInfo, 1))
		)

emitMakeStatements({}):= /\/
emitMakeStatements({~boxes})::= emitMakeStatements(boxes)
emitMakeStatements({"\[RawNewline]"**, ~x})::= emitMakeStatement(x)
emitMakeStatements({{"With" | {"\[RawNewline]"**, "With"}, "(", ~vars, ")"}, ";" | "\[RawNewline]", ~~~rest})::= 
	Emit @ composeHeldExpr(
		With,
		MakeExpression({"{", vars, "}"}),
		makeBlockExpression({rest}))
emitMakeStatements({"With" | {"\[RawNewline]"**, "With"}, "(", ~vars, ")"})::= 
	Emit @ composeHeldExpr(
		With,
		MakeExpression({"{", vars, "}"}),
		HoldComplete(/\/))
emitMakeStatements({{"Local" | {"\[RawNewline]"**, "Local"}, "(", ~vars, ")"}, ";" | "\[RawNewline]", ~~~rest})::= 
	Emit @ composeHeldExpr(
		Local,
		MakeExpression({"{", vars, "}"}),
		makeBlockExpression({rest}))
emitMakeStatements({"Local" | {"\[RawNewline]"**, "Local"}, "(", ~vars, ")"})::= 
	Emit @ composeHeldExpr(
		Local,
		MakeExpression({"{", vars, "}"}),
		HoldComplete(/\/))
emitMakeStatements({~stmt, ";" | "\[RawNewline]", ~~rest})::= (
	emitMakeStatements(stmt);
	emitMakeStatements({rest}))
emitMakeStatements({~boxes, ";"})::= (
	emitMakeStatements({boxes});
	Emit @ HoldComplete(/\/))
emitMakeStatements({~boxes, "\[RawNewline]"})::= emitMakeStatements({boxes})
emitMakeStatements(~boxes)::= Emit @ MakeExpression(boxes)


%
% TODO: flag an error in `If(a,b) {body}` instead of silently interpreting as `If(a && b) {body}`
%
asHeldCondition(p: HoldComplete(~))::= p
asHeldCondition(p: HoldComplete(~~~))::= 
	composeHeldExpr(And, p)

asHeldSwitchExpression(p: HoldComplete(~))::= p
asHeldSwitchExpression(p: HoldComplete(~~~))::= 
	composeHeldExpr(/\/, p)


%
% Function name(~arg) { body }
%
% TODO (?): Use `Function name(arg1, arg2) {body}` instead of patterns and check that only plain 
% symbols are used.
% TODO: support type annotations, for example `Function add(x -> Real, y -> Real) -> Real { x+y }`
% Caution, ` ` binds stronger than `->`:       \________________________________/    \__________/
%
MakeExpression({"Function" | {"\[RawNewline]"**, "Function"}, lhs: {~:String, "(", ~~~}, {"{", ~body, "}"}}) /? $HaveExperimentalSyntax ::=
	composeHeldExpr(
		AssignDelayed,
		MakeExpression(lhs),
		makeBlockExpression(body))


%
% If(cond) {trueBlock}
%
MakeExpression({{"If" | {"\[RawNewline]"**, "If"}, "(", ~cond, ")"}, {"{", ?trueBlock:{}, "}"}}) /? $HaveExperimentalSyntax ::=
	composeHeldExpr(
		If,
		asHeldCondition @ MakeExpression(cond),
		makeBlockExpression(trueBlock))

%
% If(cond) {trueBlock} Else {falseBlock}
%
MakeExpression({{"If" | {"\[RawNewline]"**, "If"}, "(", ~cond, ")"}, {"{", ?trueBlock:{}, "}"}, "Else", {"{", ?falseBlock:{}, "}"}}) /? $HaveExperimentalSyntax ::=
	composeHeldExpr(
		If,
		asHeldCondition @ MakeExpression(cond),
		makeBlockExpression(trueBlock),
		makeBlockExpression(falseBlock))

%
% If(cond) {trueBlock} Else If(cond2) ...
%
MakeExpression({{"If" | {"\[RawNewline]"**, "If"}, "(", ~cond, ")"}, {"{", ?trueBlock:{}, "}"}, "Else", rest: PatternSequence({"If", "(", ~, ")"}, ~~)}) /? $HaveExperimentalSyntax ::=
	composeHeldExpr(
		If,
		asHeldCondition @ MakeExpression(cond),
		makeBlockExpression(trueBlock),
		MakeExpression({rest}))

%
% Switch(expr) {Case(pat1) {block1} \[RawNewline] Case(pat2) {block2}  Case(pat3) {block3}}
%
getSwitchCases({})::= HoldComplete()
getSwitchCases({"\[RawNewline]"***, ~inner:List})::= getSwitchCases(inner)
getSwitchCases({{"Case" | {"\[RawNewline]"**, "Case"}, "(", ~pattern, ")"}, {"{", ~block, "}"}, ~~~more})::=
	Join(
		First @ composeHeldExpr(
			HoldComplete,
			asHeldSwitchExpression @ MakeExpression(pattern),
			makeBlockExpression(block)),
		getSwitchCases({more}))
getSwitchCases({~case, "\[RawNewline]", ~~~more})::= Join(getSwitchCases(case), getSwitchCases({more}))
getSwitchCases(~other)::= (
	Message(Syntax::switchcase, other)
	HoldComplete()
	)
MakeExpression({{"Switch" | {"\[RawNewline]"**, "Switch"}, "(", ~expr, ")"}, {"{", ?cases:{}, "}"}}) /? $HaveExperimentalSyntax ::=
	composeHeldExpr(
		Switch,
		asHeldSwitchExpression @ MakeExpression(expr),
		getSwitchCases({cases}))


%
% While(cond) { block } 
%
MakeExpression({{"While" | {"\[RawNewline]"**, "While"}, "(", ~cond, ")"}, {"{", ?block:{}, "}"}}) /? $HaveExperimentalSyntax ::=
	composeHeldExpr(
		While,
		asHeldCondition @ MakeExpression(cond),
		makeBlockExpression(block))

%
% Do(iter) { block } 
%
MakeExpression({{"Do" | {"\[RawNewline]"**, "Do"}, "(", ~iter, ")"}, {"{", ?block:{}, "}"}}) /? $HaveExperimentalSyntax ::=
	composeHeldExpr(
		Do,
		makeBlockExpression(block),
		MakeExpression(iter))

%
% Block { block } 
%
MakeExpression({"Block" | {"\[RawNewline]"**, "Block"}, {"{", ?block:{}, "}"}}) /? $HaveExperimentalSyntax ::=
	makeBlockExpression(block)

%
% Local(vars) { block } 
%
MakeExpression({{"Local" | {"\[RawNewline]"**, "Local"}, "(", ~vars, ")"}, {"{", ?block:{}, "}"}}) /? $HaveExperimentalSyntax ::=
	composeHeldExpr(
		Local,
		MakeExpression({"{", vars, "}"}),
		makeBlockExpression(block))

%
% With(vars) { block } 
%
MakeExpression({{"With" | {"\[RawNewline]"**, "With"}, "(", ~vars, ")"}, {"{", ?block:{}, "}"}}) /? $HaveExperimentalSyntax ::=
	composeHeldExpr(
		With,
		MakeExpression({"{", vars, "}"}),
		makeBlockExpression(block))



Protect(MakeExpression)


End()

EndPackage()
